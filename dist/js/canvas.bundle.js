/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/canvas.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/*! exports provided: CSSPlugin, default, _getBBox, _createElement, checkPrefix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getBBox", function() { return _getBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_createElement", function() { return _createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPrefix", function() { return _checkPropPrefix; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.6.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time) {
    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time;
      cache.width = parent[measureProperty];
    }
  }

  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getProperty"])(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_renderComplexString"]),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorStringFilter"])(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"]) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numWithUnitExp"].lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_relExp"].test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numExp"]).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"]);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["GSCache"](target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = !cache.uncache && target.getAttribute("data-svg-origin");

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.cos(skewX * _DEG2RAD));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a * a + b * b + c * c));
      scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleX);
  cache.scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleY);
  cache.rotation = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotation) + deg;
  cache.rotationX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationX) + deg;
  cache.rotationY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(start);
  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a11);
    a21 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a21);
    a12 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a12);
    a22 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xPercent / 100 * temp.width);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isString"])(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var style = _tempDivStyler.style,
      startCache = target._gsap,
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;
  style.cssText = getComputedStyle(target).cssText + ";position:absolute;display:block;"; //%-based translations will fail unless we set the width/height to match the original target (and padding/borders can affect it)

  style[_transformProp] = transforms;

  _doc.body.appendChild(_tempDivStyler);

  endCache = _parseTransform(_tempDivStyler, 1);

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);
      endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, startCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _doc.body.removeChild(_tempDivStyler);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_plugins"][p] && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_checkPlugin"])(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_replaceRandom"])(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);
        endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);
        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit) {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, target[p], endValue, index, targets);
          } else {
            Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_missingPlugin"])(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    hasPriority && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_sortPropTweensByPriority"])(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isUndefined"])(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getSetter"])(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/*! exports provided: GSCache, Animation, Timeline, Tween, PropTween, gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ, TweenMax, TweenLite, TimelineMax, TimelineLite, default, wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, mapRange, pipe, unitize, interpolate, shuffle, _getProperty, _numExp, _numWithUnitExp, _isString, _isUndefined, _renderComplexString, _relExp, _setDefaults, _removeLinkedListItem, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _replaceRandom, _checkPlugin, _plugins, _ticker, _config, _roundModifier, _round, _missingPlugin, _getSetter, _getCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSCache", function() { return GSCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTween", function() { return PropTween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return Power0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return Power1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return Power2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return Power3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return Power4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return Linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return Quad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return Cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return Quart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return Quint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return Strong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return Elastic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return Back; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return SteppedEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return Sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return Expo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return Circ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapYoyo", function() { return wrapYoyo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distribute", function() { return distribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnit", function() { return getUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitColor", function() { return splitColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapRange", function() { return mapRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitize", function() { return unitize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getProperty", function() { return _getProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numExp", function() { return _numExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numWithUnitExp", function() { return _numWithUnitExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isString", function() { return _isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isUndefined", function() { return _isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_renderComplexString", function() { return _renderComplexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_relExp", function() { return _relExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_setDefaults", function() { return _setDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_removeLinkedListItem", function() { return _removeLinkedListItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_forEachName", function() { return _forEachName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_sortPropTweensByPriority", function() { return _sortPropTweensByPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorStringFilter", function() { return _colorStringFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_replaceRandom", function() { return _replaceRandom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_checkPlugin", function() { return _checkPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_plugins", function() { return _plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ticker", function() { return _ticker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_config", function() { return _config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_roundModifier", function() { return _roundModifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_round", function() { return _round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_missingPlugin", function() { return _missingPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getSetter", function() { return _getSetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getCache", function() { return _getCache; });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.6.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
    _unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _parseVars = function _parseVars(params, type, parent) {
  //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars;

  isLegacy && (vars.duration = params[1]);
  vars.parent = parent;

  if (type) {
    irVars = vars;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return vars;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _round(position + child._delay);
  child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  timeline._recent = child;
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) || (tween._ts < 0 || tween._dp._ts < 0) && tween.data !== "isFromStart" && tween.data !== "isStart") ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    prevIteration = _animationCycle(tween._tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    suppressEvents || _callback(tween, "onStart");
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _round(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    i = position.charAt(0);

    if (i === "<" || i === ">") {
      return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);
    }

    i = position.indexOf("=");

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = +(position.charAt(i - 1) + position.substr(i + 1));
    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  if (typeof value !== "string") {
    return "";
  }

  var v = _unitExp.exec(value);

  return v ? value.substr(v.index + v[0].length) : "";
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars, time) {
    var parent = vars.parent || _globalTimeline;
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
    parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);
    vars.reversed && this.reverse();
    vars.paused && this.paused(true);
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detatched parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      this._rDelay = value;
      return _onUpdateTotalDuration(this);
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, time) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars, time) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _this.parent && _postAddChecks(_this.parent, _assertThisInitialized(_this));
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));
    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime !== this._time || prevPaused !== !this._ts) {
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      !prevTime && (time || !dur && totalTime >= 0) && !suppressEvents && _callback(this, "onStart");

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _round(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result;
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        tween = Tween.to(tl, _setDefaults({
      ease: "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();
        var duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());
        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart * end)) {
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);
    prevStartAt && prevStartAt.render(-1, true).kill();

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      if (immediateRender) {
        if (time > 0) {
          autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        } else if (dur && !(time < 0 && prevStartAt)) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, time, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      time.duration = vars;
      vars = time;
      time = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars), time) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = _this3.parent,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (keyframes) {
        _setDefaults(tl.vars.defaults, {
          ease: "none"
        });

        keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    parent && _postAddChecks(parent, _assertThisInitialized(_this3));

    if (immediateRender || !duration && !keyframes && _this3._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      time && !prevTime && !suppressEvents && _callback(this, "onStart");
      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return new Tween(targets, _parseVars(arguments, 1));
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return new Tween(targets, _parseVars(arguments, 2));
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref2) {
    var name = _ref2.name,
        effect = _ref2.effect,
        plugins = _ref2.plugins,
        defaults = _ref2.defaults,
        extendTimeline = _ref2.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.6.0";
_coreReady = 1;

if (_windowExists()) {
  _wake();
}

var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/*! exports provided: gsap, default, CSSPlugin, TweenMax, TweenLite, TimelineMax, TimelineLite, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsapWithCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsapWithCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return TweenMaxWithCSS; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Cubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Strong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Elastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Back"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["SteppedEase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Bounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Sine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Expo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Circ"]; });

/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]; });



var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"],
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./node_modules/mixpanel-browser/dist/mixpanel.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.cjs.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Config = {
    DEBUG: false,
    LIB_VERSION: '2.41.0'
};

// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file
var window$1;
if (typeof(window) === 'undefined') {
    var loc = {
        hostname: ''
    };
    window$1 = {
        navigator: { userAgent: '' },
        document: {
            location: loc,
            referrer: ''
        },
        screen: { width: 0, height: 0 },
        location: loc
    };
} else {
    window$1 = window;
}

/*
 * Saved references to long variable names, so that closure compiler can
 * minimize file size.
 */

var ArrayProto = Array.prototype;
var FuncProto = Function.prototype;
var ObjProto = Object.prototype;
var slice = ArrayProto.slice;
var toString = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;
var windowConsole = window$1.console;
var navigator$1 = window$1.navigator;
var document$1 = window$1.document;
var windowOpera = window$1.opera;
var screen = window$1.screen;
var userAgent = navigator$1.userAgent;
var nativeBind = FuncProto.bind;
var nativeForEach = ArrayProto.forEach;
var nativeIndexOf = ArrayProto.indexOf;
var nativeMap = ArrayProto.map;
var nativeIsArray = Array.isArray;
var breaker = {};
var _ = {
    trim: function(str) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
};

// Console override
var console = {
    /** @type {function(...*)} */
    log: function() {
        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
            try {
                windowConsole.log.apply(windowConsole, arguments);
            } catch (err) {
                _.each(arguments, function(arg) {
                    windowConsole.log(arg);
                });
            }
        }
    },
    /** @type {function(...*)} */
    warn: function() {
        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));
            try {
                windowConsole.warn.apply(windowConsole, args);
            } catch (err) {
                _.each(args, function(arg) {
                    windowConsole.warn(arg);
                });
            }
        }
    },
    /** @type {function(...*)} */
    error: function() {
        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
            var args = ['Mixpanel error:'].concat(_.toArray(arguments));
            try {
                windowConsole.error.apply(windowConsole, args);
            } catch (err) {
                _.each(args, function(arg) {
                    windowConsole.error(arg);
                });
            }
        }
    },
    /** @type {function(...*)} */
    critical: function() {
        if (!_.isUndefined(windowConsole) && windowConsole) {
            var args = ['Mixpanel error:'].concat(_.toArray(arguments));
            try {
                windowConsole.error.apply(windowConsole, args);
            } catch (err) {
                _.each(args, function(arg) {
                    windowConsole.error(arg);
                });
            }
        }
    }
};

var log_func_with_prefix = function(func, prefix) {
    return function() {
        arguments[0] = '[' + prefix + '] ' + arguments[0];
        return func.apply(console, arguments);
    };
};
var console_with_prefix = function(prefix) {
    return {
        log: log_func_with_prefix(console.log, prefix),
        error: log_func_with_prefix(console.error, prefix),
        critical: log_func_with_prefix(console.critical, prefix)
    };
};


// UNDERSCORE
// Embed part of the Underscore Library
_.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) {
        return nativeBind.apply(func, slice.call(arguments, 1));
    }
    if (!_.isFunction(func)) {
        throw new TypeError();
    }
    args = slice.call(arguments, 2);
    bound = function() {
        if (!(this instanceof bound)) {
            return func.apply(context, args.concat(slice.call(arguments)));
        }
        var ctor = {};
        ctor.prototype = func.prototype;
        var self = new ctor();
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
            return result;
        }
        return self;
    };
    return bound;
};

_.bind_instance_methods = function(obj) {
    for (var func in obj) {
        if (typeof(obj[func]) === 'function') {
            obj[func] = _.bind(obj[func], obj);
        }
    }
};

/**
 * @param {*=} obj
 * @param {function(...*)=} iterator
 * @param {Object=} context
 */
_.each = function(obj, iterator, context) {
    if (obj === null || obj === undefined) {
        return;
    }
    if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
                return;
            }
        }
    } else {
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                if (iterator.call(context, obj[key], key, obj) === breaker) {
                    return;
                }
            }
        }
    }
};

_.escapeHTML = function(s) {
    var escaped = s;
    if (escaped && _.isString(escaped)) {
        escaped = escaped
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    return escaped;
};

_.extend = function(obj) {
    _.each(slice.call(arguments, 1), function(source) {
        for (var prop in source) {
            if (source[prop] !== void 0) {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

_.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
};

// from a comment on http://dbj.org/dbj/?p=286
// fails on only one very rare and deliberate custom object:
// var bomb = { toString : undefined, valueOf: function(o) { return "function BOMBA!"; }};
_.isFunction = function(f) {
    try {
        return /^\s*\bfunction\b/.test(f);
    } catch (x) {
        return false;
    }
};

_.isArguments = function(obj) {
    return !!(obj && hasOwnProperty.call(obj, 'callee'));
};

_.toArray = function(iterable) {
    if (!iterable) {
        return [];
    }
    if (iterable.toArray) {
        return iterable.toArray();
    }
    if (_.isArray(iterable)) {
        return slice.call(iterable);
    }
    if (_.isArguments(iterable)) {
        return slice.call(iterable);
    }
    return _.values(iterable);
};

_.map = function(arr, callback, context) {
    if (nativeMap && arr.map === nativeMap) {
        return arr.map(callback, context);
    } else {
        var results = [];
        _.each(arr, function(item) {
            results.push(callback.call(context, item));
        });
        return results;
    }
};

_.keys = function(obj) {
    var results = [];
    if (obj === null) {
        return results;
    }
    _.each(obj, function(value, key) {
        results[results.length] = key;
    });
    return results;
};

_.values = function(obj) {
    var results = [];
    if (obj === null) {
        return results;
    }
    _.each(obj, function(value) {
        results[results.length] = value;
    });
    return results;
};

_.include = function(obj, target) {
    var found = false;
    if (obj === null) {
        return found;
    }
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {
        return obj.indexOf(target) != -1;
    }
    _.each(obj, function(value) {
        if (found || (found = (value === target))) {
            return breaker;
        }
    });
    return found;
};

_.includes = function(str, needle) {
    return str.indexOf(needle) !== -1;
};

// Underscore Addons
_.inherit = function(subclass, superclass) {
    subclass.prototype = new superclass();
    subclass.prototype.constructor = subclass;
    subclass.superclass = superclass.prototype;
    return subclass;
};

_.isObject = function(obj) {
    return (obj === Object(obj) && !_.isArray(obj));
};

_.isEmptyObject = function(obj) {
    if (_.isObject(obj)) {
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    return false;
};

_.isUndefined = function(obj) {
    return obj === void 0;
};

_.isString = function(obj) {
    return toString.call(obj) == '[object String]';
};

_.isDate = function(obj) {
    return toString.call(obj) == '[object Date]';
};

_.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
};

_.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
};

_.encodeDates = function(obj) {
    _.each(obj, function(v, k) {
        if (_.isDate(v)) {
            obj[k] = _.formatDate(v);
        } else if (_.isObject(v)) {
            obj[k] = _.encodeDates(v); // recurse
        }
    });
    return obj;
};

_.timestamp = function() {
    Date.now = Date.now || function() {
        return +new Date;
    };
    return Date.now();
};

_.formatDate = function(d) {
    // YYYY-MM-DDTHH:MM:SS in UTC
    function pad(n) {
        return n < 10 ? '0' + n : n;
    }
    return d.getUTCFullYear() + '-' +
        pad(d.getUTCMonth() + 1) + '-' +
        pad(d.getUTCDate()) + 'T' +
        pad(d.getUTCHours()) + ':' +
        pad(d.getUTCMinutes()) + ':' +
        pad(d.getUTCSeconds());
};

_.safewrap = function(f) {
    return function() {
        try {
            return f.apply(this, arguments);
        } catch (e) {
            console.critical('Implementation error. Please turn on debug and contact support@mixpanel.com.');
            if (Config.DEBUG){
                console.critical(e);
            }
        }
    };
};

_.safewrap_class = function(klass, functions) {
    for (var i = 0; i < functions.length; i++) {
        klass.prototype[functions[i]] = _.safewrap(klass.prototype[functions[i]]);
    }
};

_.safewrap_instance_methods = function(obj) {
    for (var func in obj) {
        if (typeof(obj[func]) === 'function') {
            obj[func] = _.safewrap(obj[func]);
        }
    }
};

_.strip_empty_properties = function(p) {
    var ret = {};
    _.each(p, function(v, k) {
        if (_.isString(v) && v.length > 0) {
            ret[k] = v;
        }
    });
    return ret;
};

/*
 * this function returns a copy of object after truncating it.  If
 * passed an Array or Object it will iterate through obj and
 * truncate all the values recursively.
 */
_.truncate = function(obj, length) {
    var ret;

    if (typeof(obj) === 'string') {
        ret = obj.slice(0, length);
    } else if (_.isArray(obj)) {
        ret = [];
        _.each(obj, function(val) {
            ret.push(_.truncate(val, length));
        });
    } else if (_.isObject(obj)) {
        ret = {};
        _.each(obj, function(val, key) {
            ret[key] = _.truncate(val, length);
        });
    } else {
        ret = obj;
    }

    return ret;
};

_.JSONEncode = (function() {
    return function(mixed_val) {
        var value = mixed_val;
        var quote = function(string) {
            var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g; // eslint-disable-line no-control-regex
            var meta = { // table of character substitutions
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"': '\\"',
                '\\': '\\\\'
            };

            escapable.lastIndex = 0;
            return escapable.test(string) ?
                '"' + string.replace(escapable, function(a) {
                    var c = meta[a];
                    return typeof c === 'string' ? c :
                        '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                }) + '"' :
                '"' + string + '"';
        };

        var str = function(key, holder) {
            var gap = '';
            var indent = '    ';
            var i = 0; // The loop counter.
            var k = ''; // The member key.
            var v = ''; // The member value.
            var length = 0;
            var mind = gap;
            var partial = [];
            var value = holder[key];

            // If the value has a toJSON method, call it to obtain a replacement value.
            if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }

            // What happens next depends on the value's type.
            switch (typeof value) {
                case 'string':
                    return quote(value);

                case 'number':
                    // JSON numbers must be finite. Encode non-finite numbers as null.
                    return isFinite(value) ? String(value) : 'null';

                case 'boolean':
                case 'null':
                    // If the value is a boolean or null, convert it to a string. Note:
                    // typeof null does not produce 'null'. The case is included here in
                    // the remote chance that this gets fixed someday.

                    return String(value);

                case 'object':
                    // If the type is 'object', we might be dealing with an object or an array or
                    // null.
                    // Due to a specification blunder in ECMAScript, typeof null is 'object',
                    // so watch out for that case.
                    if (!value) {
                        return 'null';
                    }

                    // Make an array to hold the partial results of stringifying this object value.
                    gap += indent;
                    partial = [];

                    // Is the value an array?
                    if (toString.apply(value) === '[object Array]') {
                        // The value is an array. Stringify every element. Use null as a placeholder
                        // for non-JSON values.

                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }

                        // Join all of the elements together, separated with commas, and wrap them in
                        // brackets.
                        v = partial.length === 0 ? '[]' :
                            gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                            mind + ']' :
                                '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }

                    // Iterate through all of the keys in the object.
                    for (k in value) {
                        if (hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }

                    // Join all of the member texts together, separated with commas,
                    // and wrap them in braces.
                    v = partial.length === 0 ? '{}' :
                        gap ? '{' + partial.join(',') + '' +
                        mind + '}' : '{' + partial.join(',') + '}';
                    gap = mind;
                    return v;
            }
        };

        // Make a fake root object containing our value under the key of ''.
        // Return the result of stringifying the value.
        return str('', {
            '': value
        });
    };
})();

/**
 * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
 * Slightly modified to throw a real Error rather than a POJO
 */
_.JSONDecode = (function() {
    var at, // The index of the current character
        ch, // The current character
        escapee = {
            '"': '"',
            '\\': '\\',
            '/': '/',
            'b': '\b',
            'f': '\f',
            'n': '\n',
            'r': '\r',
            't': '\t'
        },
        text,
        error = function(m) {
            var e = new SyntaxError(m);
            e.at = at;
            e.text = text;
            throw e;
        },
        next = function(c) {
            // If a c parameter is provided, verify that it matches the current character.
            if (c && c !== ch) {
                error('Expected \'' + c + '\' instead of \'' + ch + '\'');
            }
            // Get the next character. When there are no more characters,
            // return the empty string.
            ch = text.charAt(at);
            at += 1;
            return ch;
        },
        number = function() {
            // Parse a number value.
            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error('Bad number');
            } else {
                return number;
            }
        },

        string = function() {
            // Parse a string value.
            var hex,
                i,
                string = '',
                uffff;
            // When parsing for string values, we must look for " and \ characters.
            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error('Bad string');
        },
        white = function() {
            // Skip whitespace.
            while (ch && ch <= ' ') {
                next();
            }
        },
        word = function() {
            // true, false, or null.
            switch (ch) {
                case 't':
                    next('t');
                    next('r');
                    next('u');
                    next('e');
                    return true;
                case 'f':
                    next('f');
                    next('a');
                    next('l');
                    next('s');
                    next('e');
                    return false;
                case 'n':
                    next('n');
                    next('u');
                    next('l');
                    next('l');
                    return null;
            }
            error('Unexpected "' + ch + '"');
        },
        value, // Placeholder for the value function.
        array = function() {
            // Parse an array value.
            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array; // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error('Bad array');
        },
        object = function() {
            // Parse an object value.
            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object; // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error('Bad object');
        };

    value = function() {
        // Parse a JSON value. It could be an object, an array, a string,
        // a number, or a word.
        white();
        switch (ch) {
            case '{':
                return object();
            case '[':
                return array();
            case '"':
                return string();
            case '-':
                return number();
            default:
                return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

    // Return the json_parse function. It will have access to all of the
    // above functions and variables.
    return function(source) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error('Syntax error');
        }

        return result;
    };
})();

_.base64Encode = function(data) {
    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,
        ac = 0,
        enc = '',
        tmp_arr = [];

    if (!data) {
        return data;
    }

    data = _.utf8Encode(data);

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1 << 16 | o2 << 8 | o3;

        h1 = bits >> 18 & 0x3f;
        h2 = bits >> 12 & 0x3f;
        h3 = bits >> 6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
            break;
        case 2:
            enc = enc.slice(0, -1) + '=';
            break;
    }

    return enc;
};

_.utf8Encode = function(string) {
    string = (string + '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    var utftext = '',
        start,
        end;
    var stringl = 0,
        n;

    start = end = 0;
    stringl = string.length;

    for (n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;

        if (c1 < 128) {
            end++;
        } else if ((c1 > 127) && (c1 < 2048)) {
            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);
        } else {
            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.substring(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }

    if (end > start) {
        utftext += string.substring(start, string.length);
    }

    return utftext;
};

_.UUID = (function() {

    // Time/ticks information
    // 1*new Date() is a cross browser version of Date.now()
    var T = function() {
        var d = 1 * new Date(),
            i = 0;

        // this while loop figures how many browser ticks go by
        // before 1*new Date() returns a new number, ie the amount
        // of ticks that go by per millisecond
        while (d == 1 * new Date()) {
            i++;
        }

        return d.toString(16) + i.toString(16);
    };

    // Math.Random entropy
    var R = function() {
        return Math.random().toString(16).replace('.', '');
    };

    // User agent entropy
    // This function takes the user agent string, and then xors
    // together each sequence of 8 bytes.  This produces a final
    // sequence of 8 bytes which it returns as hex.
    var UA = function() {
        var ua = userAgent,
            i, ch, buffer = [],
            ret = 0;

        function xor(result, byte_array) {
            var j, tmp = 0;
            for (j = 0; j < byte_array.length; j++) {
                tmp |= (buffer[j] << j * 8);
            }
            return result ^ tmp;
        }

        for (i = 0; i < ua.length; i++) {
            ch = ua.charCodeAt(i);
            buffer.unshift(ch & 0xFF);
            if (buffer.length >= 4) {
                ret = xor(ret, buffer);
                buffer = [];
            }
        }

        if (buffer.length > 0) {
            ret = xor(ret, buffer);
        }

        return ret.toString(16);
    };

    return function() {
        var se = (screen.height * screen.width).toString(16);
        return (T() + '-' + R() + '-' + UA() + '-' + se + '-' + T());
    };
})();

// _.isBlockedUA()
// This is to block various web spiders from executing our JS and
// sending false tracking data
var BLOCKED_UA_STRS = [
    'baiduspider',
    'bingbot',
    'bingpreview',
    'facebookexternal',
    'pinterest',
    'screaming frog',
    'yahoo! slurp',
    'yandexbot',

    // a whole bunch of goog-specific crawlers
    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers
    'adsbot-google',
    'apis-google',
    'duplexweb-google',
    'feedfetcher-google',
    'google favicon',
    'google web preview',
    'google-read-aloud',
    'googlebot',
    'googleweblight',
    'mediapartners-google',
    'storebot-google'
];
_.isBlockedUA = function(ua) {
    var i;
    ua = ua.toLowerCase();
    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {
        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {
            return true;
        }
    }
    return false;
};

/**
 * @param {Object=} formdata
 * @param {string=} arg_separator
 */
_.HTTPBuildQuery = function(formdata, arg_separator) {
    var use_val, use_key, tmp_arr = [];

    if (_.isUndefined(arg_separator)) {
        arg_separator = '&';
    }

    _.each(formdata, function(val, key) {
        use_val = encodeURIComponent(val.toString());
        use_key = encodeURIComponent(key);
        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;
    });

    return tmp_arr.join(arg_separator);
};

_.getQueryParam = function(url, param) {
    // Expects a raw URL

    param = param.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
    var regexS = '[\\?&]' + param + '=([^&#]*)',
        regex = new RegExp(regexS),
        results = regex.exec(url);
    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {
        return '';
    } else {
        var result = results[1];
        try {
            result = decodeURIComponent(result);
        } catch(err) {
            console.error('Skipping decoding for malformed query param: ' + result);
        }
        return result.replace(/\+/g, ' ');
    }
};


// _.cookie
// Methods partially borrowed from quirksmode.org/js/cookies.html
_.cookie = {
    get: function(name) {
        var nameEQ = name + '=';
        var ca = document$1.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
        }
        return null;
    },

    parse: function(name) {
        var cookie;
        try {
            cookie = _.JSONDecode(_.cookie.get(name)) || {};
        } catch (err) {
            // noop
        }
        return cookie;
    },

    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {
        var cdomain = '',
            expires = '',
            secure = '';

        if (domain_override) {
            cdomain = '; domain=' + domain_override;
        } else if (is_cross_subdomain) {
            var domain = extract_domain(document$1.location.hostname);
            cdomain = domain ? '; domain=.' + domain : '';
        }

        if (seconds) {
            var date = new Date();
            date.setTime(date.getTime() + (seconds * 1000));
            expires = '; expires=' + date.toGMTString();
        }

        if (is_cross_site) {
            is_secure = true;
            secure = '; SameSite=None';
        }
        if (is_secure) {
            secure += '; secure';
        }

        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;
    },

    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {
        var cdomain = '', expires = '', secure = '';

        if (domain_override) {
            cdomain = '; domain=' + domain_override;
        } else if (is_cross_subdomain) {
            var domain = extract_domain(document$1.location.hostname);
            cdomain = domain ? '; domain=.' + domain : '';
        }

        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = '; expires=' + date.toGMTString();
        }

        if (is_cross_site) {
            is_secure = true;
            secure = '; SameSite=None';
        }
        if (is_secure) {
            secure += '; secure';
        }

        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;
        document$1.cookie = new_cookie_val;
        return new_cookie_val;
    },

    remove: function(name, is_cross_subdomain, domain_override) {
        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);
    }
};

var _localStorageSupported = null;
var localStorageSupported = function(storage, forceCheck) {
    if (_localStorageSupported !== null && !forceCheck) {
        return _localStorageSupported;
    }

    var supported = true;
    try {
        storage = storage || window.localStorage;
        var key = '__mplss_' + cheap_guid(8),
            val = 'xyz';
        storage.setItem(key, val);
        if (storage.getItem(key) !== val) {
            supported = false;
        }
        storage.removeItem(key);
    } catch (err) {
        supported = false;
    }

    _localStorageSupported = supported;
    return supported;
};

// _.localStorage
_.localStorage = {
    is_supported: function(force_check) {
        var supported = localStorageSupported(null, force_check);
        if (!supported) {
            console.error('localStorage unsupported; falling back to cookie store');
        }
        return supported;
    },

    error: function(msg) {
        console.error('localStorage error: ' + msg);
    },

    get: function(name) {
        try {
            return window.localStorage.getItem(name);
        } catch (err) {
            _.localStorage.error(err);
        }
        return null;
    },

    parse: function(name) {
        try {
            return _.JSONDecode(_.localStorage.get(name)) || {};
        } catch (err) {
            // noop
        }
        return null;
    },

    set: function(name, value) {
        try {
            window.localStorage.setItem(name, value);
        } catch (err) {
            _.localStorage.error(err);
        }
    },

    remove: function(name) {
        try {
            window.localStorage.removeItem(name);
        } catch (err) {
            _.localStorage.error(err);
        }
    }
};

_.register_event = (function() {
    // written by Dean Edwards, 2005
    // with input from Tino Zijdel - crisp@xs4all.nl
    // with input from Carl Sverre - mail@carlsverre.com
    // with input from Mixpanel
    // http://dean.edwards.name/weblog/2005/10/add-event/
    // https://gist.github.com/1930440

    /**
     * @param {Object} element
     * @param {string} type
     * @param {function(...*)} handler
     * @param {boolean=} oldSchool
     * @param {boolean=} useCapture
     */
    var register_event = function(element, type, handler, oldSchool, useCapture) {
        if (!element) {
            console.error('No valid element provided to register_event');
            return;
        }

        if (element.addEventListener && !oldSchool) {
            element.addEventListener(type, handler, !!useCapture);
        } else {
            var ontype = 'on' + type;
            var old_handler = element[ontype]; // can be undefined
            element[ontype] = makeHandler(element, handler, old_handler);
        }
    };

    function makeHandler(element, new_handler, old_handlers) {
        var handler = function(event) {
            event = event || fixEvent(window.event);

            // this basically happens in firefox whenever another script
            // overwrites the onload callback and doesn't pass the event
            // object to previously defined callbacks.  All the browsers
            // that don't define window.event implement addEventListener
            // so the dom_loaded handler will still be fired as usual.
            if (!event) {
                return undefined;
            }

            var ret = true;
            var old_result, new_result;

            if (_.isFunction(old_handlers)) {
                old_result = old_handlers(event);
            }
            new_result = new_handler.call(element, event);

            if ((false === old_result) || (false === new_result)) {
                ret = false;
            }

            return ret;
        };

        return handler;
    }

    function fixEvent(event) {
        if (event) {
            event.preventDefault = fixEvent.preventDefault;
            event.stopPropagation = fixEvent.stopPropagation;
        }
        return event;
    }
    fixEvent.preventDefault = function() {
        this.returnValue = false;
    };
    fixEvent.stopPropagation = function() {
        this.cancelBubble = true;
    };

    return register_event;
})();


var TOKEN_MATCH_REGEX = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');

_.dom_query = (function() {
    /* document.getElementsBySelector(selector)
    - returns an array of element objects from the current document
    matching the CSS selector. Selectors can contain element names,
    class names and ids and can be nested. For example:

    elements = document.getElementsBySelector('div#main p a.external')

    Will return an array of all 'a' elements with 'external' in their
    class attribute that are contained inside 'p' elements that are
    contained inside the 'div' element which has id="main"

    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:
    See http://www.w3.org/TR/css3-selectors/#attribute-selectors

    Version 0.4 - Simon Willison, March 25th 2003
    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows
    -- Opera 7 fails

    Version 0.5 - Carl Sverre, Jan 7th 2013
    -- Now uses jQuery-esque `hasClass` for testing class name
    equality.  This fixes a bug related to '-' characters being
    considered not part of a 'word' in regex.
    */

    function getAllChildren(e) {
        // Returns all children of element. Workaround required for IE5/Windows. Ugh.
        return e.all ? e.all : e.getElementsByTagName('*');
    }

    var bad_whitespace = /[\t\r\n]/g;

    function hasClass(elem, selector) {
        var className = ' ' + selector + ' ';
        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);
    }

    function getElementsBySelector(selector) {
        // Attempt to fail gracefully in lesser browsers
        if (!document$1.getElementsByTagName) {
            return [];
        }
        // Split selector in to tokens
        var tokens = selector.split(' ');
        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;
        var currentContext = [document$1];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i].replace(/^\s+/, '').replace(/\s+$/, '');
            if (token.indexOf('#') > -1) {
                // Token is an ID selector
                bits = token.split('#');
                tagName = bits[0];
                var id = bits[1];
                var element = document$1.getElementById(id);
                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {
                    // element not found or tag with that ID not found, return false
                    return [];
                }
                // Set currentContext to contain just this element
                currentContext = [element];
                continue; // Skip to next token
            }
            if (token.indexOf('.') > -1) {
                // Token contains a class selector
                bits = token.split('.');
                tagName = bits[0];
                var className = bits[1];
                if (!tagName) {
                    tagName = '*';
                }
                // Get elements matching tag, filter them for class selector
                found = [];
                foundCount = 0;
                for (j = 0; j < currentContext.length; j++) {
                    if (tagName == '*') {
                        elements = getAllChildren(currentContext[j]);
                    } else {
                        elements = currentContext[j].getElementsByTagName(tagName);
                    }
                    for (k = 0; k < elements.length; k++) {
                        found[foundCount++] = elements[k];
                    }
                }
                currentContext = [];
                currentContextIndex = 0;
                for (j = 0; j < found.length; j++) {
                    if (found[j].className &&
                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings
                        hasClass(found[j], className)
                    ) {
                        currentContext[currentContextIndex++] = found[j];
                    }
                }
                continue; // Skip to next token
            }
            // Code to deal with attribute selectors
            var token_match = token.match(TOKEN_MATCH_REGEX);
            if (token_match) {
                tagName = token_match[1];
                var attrName = token_match[2];
                var attrOperator = token_match[3];
                var attrValue = token_match[4];
                if (!tagName) {
                    tagName = '*';
                }
                // Grab all of the tagName elements within current context
                found = [];
                foundCount = 0;
                for (j = 0; j < currentContext.length; j++) {
                    if (tagName == '*') {
                        elements = getAllChildren(currentContext[j]);
                    } else {
                        elements = currentContext[j].getElementsByTagName(tagName);
                    }
                    for (k = 0; k < elements.length; k++) {
                        found[foundCount++] = elements[k];
                    }
                }
                currentContext = [];
                currentContextIndex = 0;
                var checkFunction; // This function will be used to filter the elements
                switch (attrOperator) {
                    case '=': // Equality
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName) == attrValue);
                        };
                        break;
                    case '~': // Match one of space seperated words
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName).match(new RegExp('\\b' + attrValue + '\\b')));
                        };
                        break;
                    case '|': // Match start with value followed by optional hyphen
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));
                        };
                        break;
                    case '^': // Match starts with value
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);
                        };
                        break;
                    case '$': // Match ends with value - fails with "Warning" in Opera 7
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);
                        };
                        break;
                    case '*': // Match ends with value
                        checkFunction = function(e) {
                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);
                        };
                        break;
                    default:
                        // Just test for existence of attribute
                        checkFunction = function(e) {
                            return e.getAttribute(attrName);
                        };
                }
                currentContext = [];
                currentContextIndex = 0;
                for (j = 0; j < found.length; j++) {
                    if (checkFunction(found[j])) {
                        currentContext[currentContextIndex++] = found[j];
                    }
                }
                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);
                continue; // Skip to next token
            }
            // If we get here, token is JUST an element (not a class or ID selector)
            tagName = token;
            found = [];
            foundCount = 0;
            for (j = 0; j < currentContext.length; j++) {
                elements = currentContext[j].getElementsByTagName(tagName);
                for (k = 0; k < elements.length; k++) {
                    found[foundCount++] = elements[k];
                }
            }
            currentContext = found;
        }
        return currentContext;
    }

    return function(query) {
        if (_.isElement(query)) {
            return [query];
        } else if (_.isObject(query) && !_.isUndefined(query.length)) {
            return query;
        } else {
            return getElementsBySelector.call(this, query);
        }
    };
})();

_.info = {
    campaignParams: function() {
        var campaign_keywords = 'utm_source utm_medium utm_campaign utm_content utm_term'.split(' '),
            kw = '',
            params = {};
        _.each(campaign_keywords, function(kwkey) {
            kw = _.getQueryParam(document$1.URL, kwkey);
            if (kw.length) {
                params[kwkey] = kw;
            }
        });

        return params;
    },

    searchEngine: function(referrer) {
        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {
            return 'google';
        } else if (referrer.search('https?://(.*)bing.com') === 0) {
            return 'bing';
        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {
            return 'yahoo';
        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {
            return 'duckduckgo';
        } else {
            return null;
        }
    },

    searchInfo: function(referrer) {
        var search = _.info.searchEngine(referrer),
            param = (search != 'yahoo') ? 'q' : 'p',
            ret = {};

        if (search !== null) {
            ret['$search_engine'] = search;

            var keyword = _.getQueryParam(referrer, param);
            if (keyword.length) {
                ret['mp_keyword'] = keyword;
            }
        }

        return ret;
    },

    /**
     * This function detects which browser is running this script.
     * The order of the checks are important since many user agents
     * include key words used in later checks.
     */
    browser: function(user_agent, vendor, opera) {
        vendor = vendor || ''; // vendor is undefined for at least IE9
        if (opera || _.includes(user_agent, ' OPR/')) {
            if (_.includes(user_agent, 'Mini')) {
                return 'Opera Mini';
            }
            return 'Opera';
        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
            return 'BlackBerry';
        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {
            return 'Internet Explorer Mobile';
        } else if (_.includes(user_agent, 'SamsungBrowser/')) {
            // https://developer.samsung.com/internet/user-agent-string-format
            return 'Samsung Internet';
        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {
            return 'Microsoft Edge';
        } else if (_.includes(user_agent, 'FBIOS')) {
            return 'Facebook Mobile';
        } else if (_.includes(user_agent, 'Chrome')) {
            return 'Chrome';
        } else if (_.includes(user_agent, 'CriOS')) {
            return 'Chrome iOS';
        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {
            return 'UC Browser';
        } else if (_.includes(user_agent, 'FxiOS')) {
            return 'Firefox iOS';
        } else if (_.includes(vendor, 'Apple')) {
            if (_.includes(user_agent, 'Mobile')) {
                return 'Mobile Safari';
            }
            return 'Safari';
        } else if (_.includes(user_agent, 'Android')) {
            return 'Android Mobile';
        } else if (_.includes(user_agent, 'Konqueror')) {
            return 'Konqueror';
        } else if (_.includes(user_agent, 'Firefox')) {
            return 'Firefox';
        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {
            return 'Internet Explorer';
        } else if (_.includes(user_agent, 'Gecko')) {
            return 'Mozilla';
        } else {
            return '';
        }
    },

    /**
     * This function detects which browser version is running this script,
     * parsing major and minor version (e.g., 42.1). User agent strings from:
     * http://www.useragentstring.com/pages/useragentstring.php
     */
    browserVersion: function(userAgent, vendor, opera) {
        var browser = _.info.browser(userAgent, vendor, opera);
        var versionRegexs = {
            'Internet Explorer Mobile': /rv:(\d+(\.\d+)?)/,
            'Microsoft Edge': /Edge?\/(\d+(\.\d+)?)/,
            'Chrome': /Chrome\/(\d+(\.\d+)?)/,
            'Chrome iOS': /CriOS\/(\d+(\.\d+)?)/,
            'UC Browser' : /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
            'Safari': /Version\/(\d+(\.\d+)?)/,
            'Mobile Safari': /Version\/(\d+(\.\d+)?)/,
            'Opera': /(Opera|OPR)\/(\d+(\.\d+)?)/,
            'Firefox': /Firefox\/(\d+(\.\d+)?)/,
            'Firefox iOS': /FxiOS\/(\d+(\.\d+)?)/,
            'Konqueror': /Konqueror:(\d+(\.\d+)?)/,
            'BlackBerry': /BlackBerry (\d+(\.\d+)?)/,
            'Android Mobile': /android\s(\d+(\.\d+)?)/,
            'Samsung Internet': /SamsungBrowser\/(\d+(\.\d+)?)/,
            'Internet Explorer': /(rv:|MSIE )(\d+(\.\d+)?)/,
            'Mozilla': /rv:(\d+(\.\d+)?)/
        };
        var regex = versionRegexs[browser];
        if (regex === undefined) {
            return null;
        }
        var matches = userAgent.match(regex);
        if (!matches) {
            return null;
        }
        return parseFloat(matches[matches.length - 2]);
    },

    os: function() {
        var a = userAgent;
        if (/Windows/i.test(a)) {
            if (/Phone/.test(a) || /WPDesktop/.test(a)) {
                return 'Windows Phone';
            }
            return 'Windows';
        } else if (/(iPhone|iPad|iPod)/.test(a)) {
            return 'iOS';
        } else if (/Android/.test(a)) {
            return 'Android';
        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {
            return 'BlackBerry';
        } else if (/Mac/i.test(a)) {
            return 'Mac OS X';
        } else if (/Linux/.test(a)) {
            return 'Linux';
        } else if (/CrOS/.test(a)) {
            return 'Chrome OS';
        } else {
            return '';
        }
    },

    device: function(user_agent) {
        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {
            return 'Windows Phone';
        } else if (/iPad/.test(user_agent)) {
            return 'iPad';
        } else if (/iPod/.test(user_agent)) {
            return 'iPod Touch';
        } else if (/iPhone/.test(user_agent)) {
            return 'iPhone';
        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
            return 'BlackBerry';
        } else if (/Android/.test(user_agent)) {
            return 'Android';
        } else {
            return '';
        }
    },

    referringDomain: function(referrer) {
        var split = referrer.split('/');
        if (split.length >= 3) {
            return split[2];
        }
        return '';
    },

    properties: function() {
        return _.extend(_.strip_empty_properties({
            '$os': _.info.os(),
            '$browser': _.info.browser(userAgent, navigator$1.vendor, windowOpera),
            '$referrer': document$1.referrer,
            '$referring_domain': _.info.referringDomain(document$1.referrer),
            '$device': _.info.device(userAgent)
        }), {
            '$current_url': window$1.location.href,
            '$browser_version': _.info.browserVersion(userAgent, navigator$1.vendor, windowOpera),
            '$screen_height': screen.height,
            '$screen_width': screen.width,
            'mp_lib': 'web',
            '$lib_version': Config.LIB_VERSION,
            '$insert_id': cheap_guid(),
            'time': _.timestamp() / 1000 // epoch time in seconds
        });
    },

    people_properties: function() {
        return _.extend(_.strip_empty_properties({
            '$os': _.info.os(),
            '$browser': _.info.browser(userAgent, navigator$1.vendor, windowOpera)
        }), {
            '$browser_version': _.info.browserVersion(userAgent, navigator$1.vendor, windowOpera)
        });
    },

    pageviewInfo: function(page) {
        return _.strip_empty_properties({
            'mp_page': page,
            'mp_referrer': document$1.referrer,
            'mp_browser': _.info.browser(userAgent, navigator$1.vendor, windowOpera),
            'mp_platform': _.info.os()
        });
    }
};

var cheap_guid = function(maxlen) {
    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
    return maxlen ? guid.substring(0, maxlen) : guid;
};

/**
 * Check deterministically whether to include or exclude from a feature rollout/test based on the
 * given string and the desired percentage to include.
 * @param {String} str - string to run the check against (for instance a project's token)
 * @param {String} feature - name of feature (for inclusion in hash, to ensure different results
 * for different features)
 * @param {Number} percent_allowed - percentage chance that a given string will be included
 * @returns {Boolean} whether the given string should be included
 */
var determine_eligibility = _.safewrap(function(str, feature, percent_allowed) {
    str = str + feature;

    // Bernstein's hash: http://www.cse.yorku.ca/~oz/hash.html#djb2
    var hash = 5381;
    for (var i = 0; i < str.length; i++) {
        hash = ((hash << 5) + hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    var dart = (hash >>> 0) % 100;
    return dart < percent_allowed;
});

// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)
var SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i;
// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk
var DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
/**
 * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For
 * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we
 * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).
 * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy
 * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel
 * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date
 * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK
 * offers the 'cookie_domain' config option to set it explicitly.
 * @example
 * extract_domain('my.sub.example.com')
 * // 'example.com'
 */
var extract_domain = function(hostname) {
    var domain_regex = DOMAIN_MATCH_REGEX;
    var parts = hostname.split('.');
    var tld = parts[parts.length - 1];
    if (tld.length > 4 || tld === 'com' || tld === 'org') {
        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;
    }
    var matches = hostname.match(domain_regex);
    return matches ? matches[0] : '';
};

var JSONStringify = null;
var JSONParse = null;
if (typeof JSON !== 'undefined') {
    JSONStringify = JSON.stringify;
    JSONParse = JSON.parse;
}
JSONStringify = JSONStringify || _.JSONEncode;
JSONParse = JSONParse || _.JSONDecode;

// EXPORTS (for closure compiler)
_['toArray']                = _.toArray;
_['isObject']               = _.isObject;
_['JSONEncode']             = _.JSONEncode;
_['JSONDecode']             = _.JSONDecode;
_['isBlockedUA']            = _.isBlockedUA;
_['isEmptyObject']          = _.isEmptyObject;
_['info']                   = _.info;
_['info']['device']         = _.info.device;
_['info']['browser']        = _.info.browser;
_['info']['browserVersion'] = _.info.browserVersion;
_['info']['properties']     = _.info.properties;

/**
 * DomTracker Object
 * @constructor
 */
var DomTracker = function() {};


// interface
DomTracker.prototype.create_properties = function() {};
DomTracker.prototype.event_handler = function() {};
DomTracker.prototype.after_track_handler = function() {};

DomTracker.prototype.init = function(mixpanel_instance) {
    this.mp = mixpanel_instance;
    return this;
};

/**
 * @param {Object|string} query
 * @param {string} event_name
 * @param {Object=} properties
 * @param {function=} user_callback
 */
DomTracker.prototype.track = function(query, event_name, properties, user_callback) {
    var that = this;
    var elements = _.dom_query(query);

    if (elements.length === 0) {
        console.error('The DOM query (' + query + ') returned 0 elements');
        return;
    }

    _.each(elements, function(element) {
        _.register_event(element, this.override_event, function(e) {
            var options = {};
            var props = that.create_properties(properties, this);
            var timeout = that.mp.get_config('track_links_timeout');

            that.event_handler(e, this, options);

            // in case the mixpanel servers don't get back to us in time
            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);

            // fire the tracking event
            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));
        });
    }, this);

    return true;
};

/**
 * @param {function} user_callback
 * @param {Object} props
 * @param {boolean=} timeout_occured
 */
DomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {
    timeout_occured = timeout_occured || false;
    var that = this;

    return function() {
        // options is referenced from both callbacks, so we can have
        // a 'lock' of sorts to ensure only one fires
        if (options.callback_fired) { return; }
        options.callback_fired = true;

        if (user_callback && user_callback(timeout_occured, props) === false) {
            // user can prevent the default functionality by
            // returning false from their callback
            return;
        }

        that.after_track_handler(props, options, timeout_occured);
    };
};

DomTracker.prototype.create_properties = function(properties, element) {
    var props;

    if (typeof(properties) === 'function') {
        props = properties(element);
    } else {
        props = _.extend({}, properties);
    }

    return props;
};

/**
 * LinkTracker Object
 * @constructor
 * @extends DomTracker
 */
var LinkTracker = function() {
    this.override_event = 'click';
};
_.inherit(LinkTracker, DomTracker);

LinkTracker.prototype.create_properties = function(properties, element) {
    var props = LinkTracker.superclass.create_properties.apply(this, arguments);

    if (element.href) { props['url'] = element.href; }

    return props;
};

LinkTracker.prototype.event_handler = function(evt, element, options) {
    options.new_tab = (
        evt.which === 2 ||
        evt.metaKey ||
        evt.ctrlKey ||
        element.target === '_blank'
    );
    options.href = element.href;

    if (!options.new_tab) {
        evt.preventDefault();
    }
};

LinkTracker.prototype.after_track_handler = function(props, options) {
    if (options.new_tab) { return; }

    setTimeout(function() {
        window.location = options.href;
    }, 0);
};

/**
 * FormTracker Object
 * @constructor
 * @extends DomTracker
 */
var FormTracker = function() {
    this.override_event = 'submit';
};
_.inherit(FormTracker, DomTracker);

FormTracker.prototype.event_handler = function(evt, element, options) {
    options.element = element;
    evt.preventDefault();
};

FormTracker.prototype.after_track_handler = function(props, options) {
    setTimeout(function() {
        options.element.submit();
    }, 0);
};

// eslint-disable-line camelcase

var logger$2 = console_with_prefix('lock');

/**
 * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser
 * window/tab at a time will be able to access shared resources.
 *
 * Based on the Alur and Taubenfeld fast lock
 * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)
 * with an added timeout to ensure there will be eventual progress in the event
 * that a window is closed in the middle of the callback.
 *
 * Implementation based on the original version by David Wolever (https://github.com/wolever)
 * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.
 *
 * @example
 * const myLock = new SharedLock('some-key');
 * myLock.withLock(function() {
 *   console.log('I hold the mutex!');
 * });
 *
 * @constructor
 */
var SharedLock = function(key, options) {
    options = options || {};

    this.storageKey = key;
    this.storage = options.storage || window.localStorage;
    this.pollIntervalMS = options.pollIntervalMS || 100;
    this.timeoutMS = options.timeoutMS || 2000;
};

// pass in a specific pid to test contention scenarios; otherwise
// it is chosen randomly for each acquisition attempt
SharedLock.prototype.withLock = function(lockedCB, errorCB, pid) {
    if (!pid && typeof errorCB !== 'function') {
        pid = errorCB;
        errorCB = null;
    }

    var i = pid || (new Date().getTime() + '|' + Math.random());
    var startTime = new Date().getTime();

    var key = this.storageKey;
    var pollIntervalMS = this.pollIntervalMS;
    var timeoutMS = this.timeoutMS;
    var storage = this.storage;

    var keyX = key + ':X';
    var keyY = key + ':Y';
    var keyZ = key + ':Z';

    var reportError = function(err) {
        errorCB && errorCB(err);
    };

    var delay = function(cb) {
        if (new Date().getTime() - startTime > timeoutMS) {
            logger$2.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');
            storage.removeItem(keyZ);
            storage.removeItem(keyY);
            loop();
            return;
        }
        setTimeout(function() {
            try {
                cb();
            } catch(err) {
                reportError(err);
            }
        }, pollIntervalMS * (Math.random() + 0.1));
    };

    var waitFor = function(predicate, cb) {
        if (predicate()) {
            cb();
        } else {
            delay(function() {
                waitFor(predicate, cb);
            });
        }
    };

    var getSetY = function() {
        var valY = storage.getItem(keyY);
        if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)
            return false;
        } else {
            storage.setItem(keyY, i);
            if (storage.getItem(keyY) === i) {
                return true;
            } else {
                if (!localStorageSupported(storage, true)) {
                    throw new Error('localStorage support dropped while acquiring lock');
                }
                return false;
            }
        }
    };

    var loop = function() {
        storage.setItem(keyX, i);

        waitFor(getSetY, function() {
            if (storage.getItem(keyX) === i) {
                criticalSection();
                return;
            }

            delay(function() {
                if (storage.getItem(keyY) !== i) {
                    loop();
                    return;
                }
                waitFor(function() {
                    return !storage.getItem(keyZ);
                }, criticalSection);
            });
        });
    };

    var criticalSection = function() {
        storage.setItem(keyZ, '1');
        try {
            lockedCB();
        } finally {
            storage.removeItem(keyZ);
            if (storage.getItem(keyY) === i) {
                storage.removeItem(keyY);
            }
            if (storage.getItem(keyX) === i) {
                storage.removeItem(keyX);
            }
        }
    };

    try {
        if (localStorageSupported(storage, true)) {
            loop();
        } else {
            throw new Error('localStorage support check failed');
        }
    } catch(err) {
        reportError(err);
    }
};

// eslint-disable-line camelcase

var logger$1 = console_with_prefix('batch');

/**
 * RequestQueue: queue for batching API requests with localStorage backup for retries.
 * Maintains an in-memory queue which represents the source of truth for the current
 * page, but also writes all items out to a copy in the browser's localStorage, which
 * can be read on subsequent pageloads and retried. For batchability, all the request
 * items in the queue should be of the same type (events, people updates, group updates)
 * so they can be sent in a single request to the same API endpoint.
 *
 * LocalStorage keying and locking: In order for reloads and subsequent pageloads of
 * the same site to access the same persisted data, they must share the same localStorage
 * key (for instance based on project token and queue type). Therefore access to the
 * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent
 * simultaneously open windows/tabs from overwriting each other's data (which would lead
 * to data loss in some situations).
 * @constructor
 */
var RequestQueue = function(storageKey, options) {
    options = options || {};
    this.storageKey = storageKey;
    this.storage = options.storage || window.localStorage;
    this.lock = new SharedLock(storageKey, {storage: this.storage});

    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios

    this.memQueue = [];
};

/**
 * Add one item to queues (memory and localStorage). The queued entry includes
 * the given item along with an auto-generated ID and a "flush-after" timestamp.
 * It is expected that the item will be sent over the network and dequeued
 * before the flush-after time; if this doesn't happen it is considered orphaned
 * (e.g., the original tab where it was enqueued got closed before it could be
 * sent) and the item can be sent by any tab that finds it in localStorage.
 *
 * The final callback param is called with a param indicating success or
 * failure of the enqueue operation; it is asynchronous because the localStorage
 * lock is asynchronous.
 */
RequestQueue.prototype.enqueue = function(item, flushInterval, cb) {
    var queueEntry = {
        'id': cheap_guid(),
        'flushAfter': new Date().getTime() + flushInterval * 2,
        'payload': item
    };

    this.lock.withLock(_.bind(function lockAcquired() {
        var succeeded;
        try {
            var storedQueue = this.readFromStorage();
            storedQueue.push(queueEntry);
            succeeded = this.saveToStorage(storedQueue);
            if (succeeded) {
                // only add to in-memory queue when storage succeeds
                this.memQueue.push(queueEntry);
            }
        } catch(err) {
            logger$1.error('Error enqueueing item', item);
            succeeded = false;
        }
        if (cb) {
            cb(succeeded);
        }
    }, this), function lockFailure(err) {
        logger$1.error('Error acquiring storage lock', err);
        if (cb) {
            cb(false);
        }
    }, this.pid);
};

/**
 * Read out the given number of queue entries. If this.memQueue
 * has fewer than batchSize items, then look for "orphaned" items
 * in the persisted queue (items where the 'flushAfter' time has
 * already passed).
 */
RequestQueue.prototype.fillBatch = function(batchSize) {
    var batch = this.memQueue.slice(0, batchSize);
    if (batch.length < batchSize) {
        // don't need lock just to read events; localStorage is thread-safe
        // and the worst that could happen is a duplicate send of some
        // orphaned events, which will be deduplicated on the server side
        var storedQueue = this.readFromStorage();
        if (storedQueue.length) {
            // item IDs already in batch; don't duplicate out of storage
            var idsInBatch = {}; // poor man's Set
            _.each(batch, function(item) { idsInBatch[item['id']] = true; });

            for (var i = 0; i < storedQueue.length; i++) {
                var item = storedQueue[i];
                if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {
                    item.orphaned = true;
                    batch.push(item);
                    if (batch.length >= batchSize) {
                        break;
                    }
                }
            }
        }
    }
    return batch;
};

/**
 * Remove items with matching 'id' from array (immutably)
 * also remove any item without a valid id (e.g., malformed
 * storage entries).
 */
var filterOutIDsAndInvalid = function(items, idSet) {
    var filteredItems = [];
    _.each(items, function(item) {
        if (item['id'] && !idSet[item['id']]) {
            filteredItems.push(item);
        }
    });
    return filteredItems;
};

/**
 * Remove items with matching IDs from both in-memory queue
 * and persisted queue
 */
RequestQueue.prototype.removeItemsByID = function(ids, cb) {
    var idSet = {}; // poor man's Set
    _.each(ids, function(id) { idSet[id] = true; });

    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);
    this.lock.withLock(_.bind(function lockAcquired() {
        var succeeded;
        try {
            var storedQueue = this.readFromStorage();
            storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);
            succeeded = this.saveToStorage(storedQueue);
        } catch(err) {
            logger$1.error('Error removing items', ids);
            succeeded = false;
        }
        if (cb) {
            cb(succeeded);
        }
    }, this), function lockFailure(err) {
        logger$1.error('Error acquiring storage lock', err);
        if (cb) {
            cb(false);
        }
    }, this.pid);
};

// internal helper for RequestQueue.updatePayloads
var updatePayloads = function(existingItems, itemsToUpdate) {
    var newItems = [];
    _.each(existingItems, function(item) {
        var id = item['id'];
        if (id in itemsToUpdate) {
            var newPayload = itemsToUpdate[id];
            if (newPayload !== null) {
                item['payload'] = newPayload;
                newItems.push(item);
            }
        } else {
            // no update
            newItems.push(item);
        }
    });
    return newItems;
};

/**
 * Update payloads of given items in both in-memory queue and
 * persisted queue. Items set to null are removed from queues.
 */
RequestQueue.prototype.updatePayloads = function(itemsToUpdate, cb) {
    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);
    this.lock.withLock(_.bind(function lockAcquired() {
        var succeeded;
        try {
            var storedQueue = this.readFromStorage();
            storedQueue = updatePayloads(storedQueue, itemsToUpdate);
            succeeded = this.saveToStorage(storedQueue);
        } catch(err) {
            logger$1.error('Error updating items', itemsToUpdate);
            succeeded = false;
        }
        if (cb) {
            cb(succeeded);
        }
    }, this), function lockFailure(err) {
        logger$1.error('Error acquiring storage lock', err);
        if (cb) {
            cb(false);
        }
    }, this.pid);
};

/**
 * Read and parse items array from localStorage entry, handling
 * malformed/missing data if necessary.
 */
RequestQueue.prototype.readFromStorage = function() {
    var storageEntry;
    try {
        storageEntry = this.storage.getItem(this.storageKey);
        if (storageEntry) {
            storageEntry = JSONParse(storageEntry);
            if (!_.isArray(storageEntry)) {
                logger$1.error('Invalid storage entry:', storageEntry);
                storageEntry = null;
            }
        }
    } catch (err) {
        logger$1.error('Error retrieving queue', err);
        storageEntry = null;
    }
    return storageEntry || [];
};

/**
 * Serialize the given items array to localStorage.
 */
RequestQueue.prototype.saveToStorage = function(queue) {
    try {
        this.storage.setItem(this.storageKey, JSONStringify(queue));
        return true;
    } catch (err) {
        logger$1.error('Error saving queue', err);
        return false;
    }
};

/**
 * Clear out queues (memory and localStorage).
 */
RequestQueue.prototype.clear = function() {
    this.memQueue = [];
    this.storage.removeItem(this.storageKey);
};

// eslint-disable-line camelcase

// maximum interval between request retries after exponential backoff
var MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes

var logger = console_with_prefix('batch');

/**
 * RequestBatcher: manages the queueing, flushing, retry etc of requests of one
 * type (events, people, groups).
 * Uses RequestQueue to manage the backing store.
 * @constructor
 */
var RequestBatcher = function(storageKey, options) {
    this.queue = new RequestQueue(storageKey, {storage: options.storage});

    this.libConfig = options.libConfig;
    this.sendRequest = options.sendRequestFunc;
    this.beforeSendHook = options.beforeSendHook;

    // seed variable batch size + flush interval with configured values
    this.batchSize = this.libConfig['batch_size'];
    this.flushInterval = this.libConfig['batch_flush_interval_ms'];

    this.stopped = !this.libConfig['batch_autostart'];
};

/**
 * Add one item to queue.
 */
RequestBatcher.prototype.enqueue = function(item, cb) {
    this.queue.enqueue(item, this.flushInterval, cb);
};

/**
 * Start flushing batches at the configured time interval. Must call
 * this method upon SDK init in order to send anything over the network.
 */
RequestBatcher.prototype.start = function() {
    this.stopped = false;
    this.flush();
};

/**
 * Stop flushing batches. Can be restarted by calling start().
 */
RequestBatcher.prototype.stop = function() {
    this.stopped = true;
    if (this.timeoutID) {
        clearTimeout(this.timeoutID);
        this.timeoutID = null;
    }
};

/**
 * Clear out queue.
 */
RequestBatcher.prototype.clear = function() {
    this.queue.clear();
};

/**
 * Restore batch size configuration to whatever is set in the main SDK.
 */
RequestBatcher.prototype.resetBatchSize = function() {
    this.batchSize = this.libConfig['batch_size'];
};

/**
 * Restore flush interval time configuration to whatever is set in the main SDK.
 */
RequestBatcher.prototype.resetFlush = function() {
    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);
};

/**
 * Schedule the next flush in the given number of milliseconds.
 */
RequestBatcher.prototype.scheduleFlush = function(flushMS) {
    this.flushInterval = flushMS;
    if (!this.stopped) { // don't schedule anymore if batching has been stopped
        this.timeoutID = setTimeout(_.bind(this.flush, this), this.flushInterval);
    }
};

/**
 * Flush one batch to network. Depending on success/failure modes, it will either
 * remove the batch from the queue or leave it in for retry, and schedule the next
 * flush. In cases of most network or API failures, it will back off exponentially
 * when retrying.
 * @param {Object} [options]
 * @param {boolean} [options.sendBeacon] - whether to send batch with
 * navigator.sendBeacon (only useful for sending batches before page unloads, as
 * sendBeacon offers no callbacks or status indications)
 */
RequestBatcher.prototype.flush = function(options) {
    try {

        if (this.requestInProgress) {
            logger.log('Flush: Request already in progress');
            return;
        }

        options = options || {};
        var timeoutMS = this.libConfig['batch_request_timeout_ms'];
        var startTime = new Date().getTime();
        var currentBatchSize = this.batchSize;
        var batch = this.queue.fillBatch(currentBatchSize);
        var dataForRequest = [];
        var transformedItems = {};
        _.each(batch, function(item) {
            var payload = item['payload'];
            if (this.beforeSendHook && !item.orphaned) {
                payload = this.beforeSendHook(payload);
            }
            if (payload) {
                dataForRequest.push(payload);
            }
            transformedItems[item['id']] = payload;
        }, this);
        if (dataForRequest.length < 1) {
            this.resetFlush();
            return; // nothing to do
        }

        this.requestInProgress = true;

        var batchSendCallback = _.bind(function(res) {
            this.requestInProgress = false;

            try {

                // handle API response in a try-catch to make sure we can reset the
                // flush operation if something goes wrong

                var removeItemsFromQueue = false;
                if (options.unloading) {
                    // update persisted data to include hook transformations
                    this.queue.updatePayloads(transformedItems);
                } else if (
                    _.isObject(res) &&
                    res.error === 'timeout' &&
                    new Date().getTime() - startTime >= timeoutMS
                ) {
                    logger.error('Network timeout; retrying');
                    this.flush();
                } else if (
                    _.isObject(res) &&
                    res.xhr_req &&
                    (res.xhr_req['status'] >= 500 || res.xhr_req['status'] <= 0)
                ) {
                    // network or API error, retry
                    var retryMS = this.flushInterval * 2;
                    var headers = res.xhr_req['responseHeaders'];
                    if (headers) {
                        var retryAfter = headers['Retry-After'];
                        if (retryAfter) {
                            retryMS = (parseInt(retryAfter, 10) * 1000) || retryMS;
                        }
                    }
                    retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);
                    logger.error('Error; retry in ' + retryMS + ' ms');
                    this.scheduleFlush(retryMS);
                } else if (_.isObject(res) && res.xhr_req && res.xhr_req['status'] === 413) {
                    // 413 Payload Too Large
                    if (batch.length > 1) {
                        var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));
                        this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);
                        logger.error('413 response; reducing batch size to ' + this.batchSize);
                        this.resetFlush();
                    } else {
                        logger.error('Single-event request too large; dropping', batch);
                        this.resetBatchSize();
                        removeItemsFromQueue = true;
                    }
                } else {
                    // successful network request+response; remove each item in batch from queue
                    // (even if it was e.g. a 400, in which case retrying won't help)
                    removeItemsFromQueue = true;
                }

                if (removeItemsFromQueue) {
                    this.queue.removeItemsByID(
                        _.map(batch, function(item) { return item['id']; }),
                        _.bind(this.flush, this) // handle next batch if the queue isn't empty
                    );
                }

            } catch(err) {
                logger.error('Error handling API response', err);
                this.resetFlush();
            }
        }, this);
        var requestOptions = {
            method: 'POST',
            verbose: true,
            ignore_json_errors: true, // eslint-disable-line camelcase
            timeout_ms: timeoutMS // eslint-disable-line camelcase
        };
        if (options.unloading) {
            requestOptions.transport = 'sendBeacon';
        }
        logger.log('MIXPANEL REQUEST:', dataForRequest);
        this.sendRequest(dataForRequest, requestOptions, batchSendCallback);

    } catch(err) {
        logger.error('Error flushing request queue', err);
        this.resetFlush();
    }
};

/**
 * A function used to track a Mixpanel event (e.g. MixpanelLib.track)
 * @callback trackFunction
 * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.
 * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.
 * @param {Function} [callback] If provided, the callback function will be called after tracking the event.
 */

/** Public **/

var GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';

/**
 * Opt the user in to data tracking and cookies/localstorage for the given token
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action
 * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action
 * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action
 * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires
 * @param {string} [options.cookieDomain] - custom cookie domain
 * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled
 * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not
 * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not
 */
function optIn(token, options) {
    _optInOut(true, token, options);
}

/**
 * Opt the user out of data tracking and cookies/localstorage for the given token
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires
 * @param {string} [options.cookieDomain] - custom cookie domain
 * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled
 * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not
 * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not
 */
function optOut(token, options) {
    _optInOut(false, token, options);
}

/**
 * Check whether the user has opted in to data tracking and cookies/localstorage for the given token
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @returns {boolean} whether the user has opted in to the given opt type
 */
function hasOptedIn(token, options) {
    return _getStorageValue(token, options) === '1';
}

/**
 * Check whether the user has opted out of data tracking and cookies/localstorage for the given token
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false
 * @returns {boolean} whether the user has opted out of the given opt type
 */
function hasOptedOut(token, options) {
    if (_hasDoNotTrackFlagOn(options)) {
        console.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"');
        return true;
    }
    var optedOut = _getStorageValue(token, options) === '0';
    if (optedOut) {
        console.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');
    }
    return optedOut;
}

/**
 * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token
 * If the user has opted out, return early instead of executing the method.
 * If a callback argument was provided, execute it passing the 0 error code.
 * @param {function} method - wrapped method to be executed if the user has not opted out
 * @returns {*} the result of executing method OR undefined if the user has opted out
 */
function addOptOutCheckMixpanelLib(method) {
    return _addOptOutCheck(method, function(name) {
        return this.get_config(name);
    });
}

/**
 * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token
 * If the user has opted out, return early instead of executing the method.
 * If a callback argument was provided, execute it passing the 0 error code.
 * @param {function} method - wrapped method to be executed if the user has not opted out
 * @returns {*} the result of executing method OR undefined if the user has opted out
 */
function addOptOutCheckMixpanelPeople(method) {
    return _addOptOutCheck(method, function(name) {
        return this._get_config(name);
    });
}

/**
 * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token
 * If the user has opted out, return early instead of executing the method.
 * If a callback argument was provided, execute it passing the 0 error code.
 * @param {function} method - wrapped method to be executed if the user has not opted out
 * @returns {*} the result of executing method OR undefined if the user has opted out
 */
function addOptOutCheckMixpanelGroup(method) {
    return _addOptOutCheck(method, function(name) {
        return this._get_config(name);
    });
}

/**
 * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires
 * @param {string} [options.cookieDomain] - custom cookie domain
 * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled
 * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not
 * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not
 */
function clearOptInOut(token, options) {
    options = options || {};
    _getStorage(options).remove(
        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain
    );
}

/** Private **/

/**
 * Get storage util
 * @param {Object} [options]
 * @param {string} [options.persistenceType]
 * @returns {object} either _.cookie or _.localstorage
 */
function _getStorage(options) {
    options = options || {};
    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;
}

/**
 * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @returns {string} the name of the cookie for the given opt type
 */
function _getStorageKey(token, options) {
    options = options || {};
    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;
}

/**
 * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @returns {string} the value of the cookie for the given opt type
 */
function _getStorageValue(token, options) {
    return _getStorage(options).get(_getStorageKey(token, options));
}

/**
 * Check whether the user has set the DNT/doNotTrack setting to true in their browser
 * @param {Object} [options]
 * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests
 * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false
 * @returns {boolean} whether the DNT setting is true
 */
function _hasDoNotTrackFlagOn(options) {
    if (options && options.ignoreDnt) {
        return false;
    }
    var win = (options && options.window) || window$1;
    var nav = win['navigator'] || {};
    var hasDntOn = false;

    _.each([
        nav['doNotTrack'], // standard
        nav['msDoNotTrack'],
        win['doNotTrack']
    ], function(dntValue) {
        if (_.includes([true, 1, '1', 'yes'], dntValue)) {
            hasDntOn = true;
        }
    });

    return hasDntOn;
}

/**
 * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type
 * @param {boolean} optValue - whether to opt the user in or out for the given opt type
 * @param {string} token - Mixpanel project tracking token
 * @param {Object} [options]
 * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action
 * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action
 * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action
 * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires
 * @param {string} [options.cookieDomain] - custom cookie domain
 * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled
 * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not
 * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not
 */
function _optInOut(optValue, token, options) {
    if (!_.isString(token) || !token.length) {
        console.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');
        return;
    }

    options = options || {};

    _getStorage(options).set(
        _getStorageKey(token, options),
        optValue ? 1 : 0,
        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,
        !!options.crossSubdomainCookie,
        !!options.secureCookie,
        !!options.crossSiteCookie,
        options.cookieDomain
    );

    if (options.track && optValue) { // only track event if opting in (optValue=true)
        options.track(options.trackEventName || '$opt_in', options.trackProperties, {
            'send_immediately': true
        });
    }
}

/**
 * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token
 * If the user has opted out, return early instead of executing the method.
 * If a callback argument was provided, execute it passing the 0 error code.
 * @param {function} method - wrapped method to be executed if the user has not opted out
 * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check
 * @returns {*} the result of executing method OR undefined if the user has opted out
 */
function _addOptOutCheck(method, getConfigValue) {
    return function() {
        var optedOut = false;

        try {
            var token = getConfigValue.call(this, 'token');
            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');
            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');
            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');
            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests

            if (token) { // if there was an issue getting the token, continue method execution as normal
                optedOut = hasOptedOut(token, {
                    ignoreDnt: ignoreDnt,
                    persistenceType: persistenceType,
                    persistencePrefix: persistencePrefix,
                    window: win
                });
            }
        } catch(err) {
            console.error('Unexpected error when checking tracking opt-out status: ' + err);
        }

        if (!optedOut) {
            return method.apply(this, arguments);
        }

        var callback = arguments[arguments.length - 1];
        if (typeof(callback) === 'function') {
            callback(0);
        }

        return;
    };
}

/** @const */ var SET_ACTION      = '$set';
/** @const */ var SET_ONCE_ACTION = '$set_once';
/** @const */ var UNSET_ACTION    = '$unset';
/** @const */ var ADD_ACTION      = '$add';
/** @const */ var APPEND_ACTION   = '$append';
/** @const */ var UNION_ACTION    = '$union';
/** @const */ var REMOVE_ACTION   = '$remove';
/** @const */ var DELETE_ACTION   = '$delete';

// Common internal methods for mixpanel.people and mixpanel.group APIs.
// These methods shouldn't involve network I/O.
var apiActions = {
    set_action: function(prop, to) {
        var data = {};
        var $set = {};
        if (_.isObject(prop)) {
            _.each(prop, function(v, k) {
                if (!this._is_reserved_property(k)) {
                    $set[k] = v;
                }
            }, this);
        } else {
            $set[prop] = to;
        }

        data[SET_ACTION] = $set;
        return data;
    },

    unset_action: function(prop) {
        var data = {};
        var $unset = [];
        if (!_.isArray(prop)) {
            prop = [prop];
        }

        _.each(prop, function(k) {
            if (!this._is_reserved_property(k)) {
                $unset.push(k);
            }
        }, this);

        data[UNSET_ACTION] = $unset;
        return data;
    },

    set_once_action: function(prop, to) {
        var data = {};
        var $set_once = {};
        if (_.isObject(prop)) {
            _.each(prop, function(v, k) {
                if (!this._is_reserved_property(k)) {
                    $set_once[k] = v;
                }
            }, this);
        } else {
            $set_once[prop] = to;
        }
        data[SET_ONCE_ACTION] = $set_once;
        return data;
    },

    union_action: function(list_name, values) {
        var data = {};
        var $union = {};
        if (_.isObject(list_name)) {
            _.each(list_name, function(v, k) {
                if (!this._is_reserved_property(k)) {
                    $union[k] = _.isArray(v) ? v : [v];
                }
            }, this);
        } else {
            $union[list_name] = _.isArray(values) ? values : [values];
        }
        data[UNION_ACTION] = $union;
        return data;
    },

    append_action: function(list_name, value) {
        var data = {};
        var $append = {};
        if (_.isObject(list_name)) {
            _.each(list_name, function(v, k) {
                if (!this._is_reserved_property(k)) {
                    $append[k] = v;
                }
            }, this);
        } else {
            $append[list_name] = value;
        }
        data[APPEND_ACTION] = $append;
        return data;
    },

    remove_action: function(list_name, value) {
        var data = {};
        var $remove = {};
        if (_.isObject(list_name)) {
            _.each(list_name, function(v, k) {
                if (!this._is_reserved_property(k)) {
                    $remove[k] = v;
                }
            }, this);
        } else {
            $remove[list_name] = value;
        }
        data[REMOVE_ACTION] = $remove;
        return data;
    },

    delete_action: function() {
        var data = {};
        data[DELETE_ACTION] = '';
        return data;
    }
};

/**
 * Mixpanel Group Object
 * @constructor
 */
var MixpanelGroup = function() {};

_.extend(MixpanelGroup.prototype, apiActions);

MixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {
    this._mixpanel = mixpanel_instance;
    this._group_key = group_key;
    this._group_id = group_id;
};

/**
 * Set properties on a group.
 *
 * ### Usage:
 *
 *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');
 *
 *     // or set multiple properties at once
 *     mixpanel.get_group('company', 'mixpanel').set({
 *          'Location': '405 Howard',
 *          'Founded' : 2009,
 *     });
 *     // properties can be strings, integers, dates, or lists
 *
 * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
 * @param {*} [to] A value to set on the given property name
 * @param {Function} [callback] If provided, the callback will be called after the tracking event
 */
MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {
    var data = this.set_action(prop, to);
    if (_.isObject(prop)) {
        callback = to;
    }
    return this._send_request(data, callback);
});

/**
 * Set properties on a group, only if they do not yet exist.
 * This will not overwrite previous group property values, unlike
 * group.set().
 *
 * ### Usage:
 *
 *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');
 *
 *     // or set multiple properties at once
 *     mixpanel.get_group('company', 'mixpanel').set_once({
 *          'Location': '405 Howard',
 *          'Founded' : 2009,
 *     });
 *     // properties can be strings, integers, lists or dates
 *
 * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
 * @param {*} [to] A value to set on the given property name
 * @param {Function} [callback] If provided, the callback will be called after the tracking event
 */
MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {
    var data = this.set_once_action(prop, to);
    if (_.isObject(prop)) {
        callback = to;
    }
    return this._send_request(data, callback);
});

/**
 * Unset properties on a group permanently.
 *
 * ### Usage:
 *
 *     mixpanel.get_group('company', 'mixpanel').unset('Founded');
 *
 * @param {String} prop The name of the property.
 * @param {Function} [callback] If provided, the callback will be called after the tracking event
 */
MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {
    var data = this.unset_action(prop);
    return this._send_request(data, callback);
});

/**
 * Merge a given list with a list-valued group property, excluding duplicate values.
 *
 * ### Usage:
 *
 *     // merge a value to a list, creating it if needed
 *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);
 *
 * @param {String} list_name Name of the property.
 * @param {Array} values Values to merge with the given property
 * @param {Function} [callback] If provided, the callback will be called after the tracking event
 */
MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {
    if (_.isObject(list_name)) {
        callback = values;
    }
    var data = this.union_action(list_name, values);
    return this._send_request(data, callback);
});

/**
 * Permanently delete a group.
 *
 * ### Usage:
 *     mixpanel.get_group('company', 'mixpanel').delete();
 */
MixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {
    var data = this.delete_action();
    return this._send_request(data, callback);
});

/**
 * Remove a property from a group. The value will be ignored if doesn't exist.
 *
 * ### Usage:
 *
 *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');
 *
 * @param {String} list_name Name of the property.
 * @param {Object} value Value to remove from the given group property
 * @param {Function} [callback] If provided, the callback will be called after the tracking event
 */
MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {
    var data = this.remove_action(list_name, value);
    return this._send_request(data, callback);
});

MixpanelGroup.prototype._send_request = function(data, callback) {
    data['$group_key'] = this._group_key;
    data['$group_id'] = this._group_id;
    data['$token'] = this._get_config('token');

    var date_encoded_data = _.encodeDates(data);
    return this._mixpanel._track_or_batch({
        type: 'groups',
        data: date_encoded_data,
        endpoint: this._get_config('api_host') + '/groups/',
        batcher: this._mixpanel.request_batchers.groups
    }, callback);
};

MixpanelGroup.prototype._is_reserved_property = function(prop) {
    return prop === '$group_key' || prop === '$group_id';
};

MixpanelGroup.prototype._get_config = function(conf) {
    return this._mixpanel.get_config(conf);
};

MixpanelGroup.prototype.toString = function() {
    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;
};

// MixpanelGroup Exports
MixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;
MixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;
MixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;
MixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;
MixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;
MixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;

/*
 * Constants
 */
/** @const */ var SET_QUEUE_KEY          = '__mps';
/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';
/** @const */ var UNSET_QUEUE_KEY        = '__mpus';
/** @const */ var ADD_QUEUE_KEY          = '__mpa';
/** @const */ var APPEND_QUEUE_KEY       = '__mpap';
/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';
/** @const */ var UNION_QUEUE_KEY        = '__mpu';
// This key is deprecated, but we want to check for it to see whether aliasing is allowed.
/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';
/** @const */ var ALIAS_ID_KEY           = '__alias';
/** @const */ var CAMPAIGN_IDS_KEY       = '__cmpns';
/** @const */ var EVENT_TIMERS_KEY       = '__timers';
/** @const */ var RESERVED_PROPERTIES = [
    SET_QUEUE_KEY,
    SET_ONCE_QUEUE_KEY,
    UNSET_QUEUE_KEY,
    ADD_QUEUE_KEY,
    APPEND_QUEUE_KEY,
    REMOVE_QUEUE_KEY,
    UNION_QUEUE_KEY,
    PEOPLE_DISTINCT_ID_KEY,
    ALIAS_ID_KEY,
    CAMPAIGN_IDS_KEY,
    EVENT_TIMERS_KEY
];

/**
 * Mixpanel Persistence Object
 * @constructor
 */
var MixpanelPersistence = function(config) {
    this['props'] = {};
    this.campaign_params_saved = false;

    if (config['persistence_name']) {
        this.name = 'mp_' + config['persistence_name'];
    } else {
        this.name = 'mp_' + config['token'] + '_mixpanel';
    }

    var storage_type = config['persistence'];
    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {
        console.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');
        storage_type = config['persistence'] = 'cookie';
    }

    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {
        this.storage = _.localStorage;
    } else {
        this.storage = _.cookie;
    }

    this.load();
    this.update_config(config);
    this.upgrade(config);
    this.save();
};

MixpanelPersistence.prototype.properties = function() {
    var p = {};
    // Filter out reserved properties
    _.each(this['props'], function(v, k) {
        if (!_.include(RESERVED_PROPERTIES, k)) {
            p[k] = v;
        }
    });
    return p;
};

MixpanelPersistence.prototype.load = function() {
    if (this.disabled) { return; }

    var entry = this.storage.parse(this.name);

    if (entry) {
        this['props'] = _.extend({}, entry);
    }
};

MixpanelPersistence.prototype.upgrade = function(config) {
    var upgrade_from_old_lib = config['upgrade'],
        old_cookie_name,
        old_cookie;

    if (upgrade_from_old_lib) {
        old_cookie_name = 'mp_super_properties';
        // Case where they had a custom cookie name before.
        if (typeof(upgrade_from_old_lib) === 'string') {
            old_cookie_name = upgrade_from_old_lib;
        }

        old_cookie = this.storage.parse(old_cookie_name);

        // remove the cookie
        this.storage.remove(old_cookie_name);
        this.storage.remove(old_cookie_name, true);

        if (old_cookie) {
            this['props'] = _.extend(
                this['props'],
                old_cookie['all'],
                old_cookie['events']
            );
        }
    }

    if (!config['cookie_name'] && config['name'] !== 'mixpanel') {
        // special case to handle people with cookies of the form
        // mp_TOKEN_INSTANCENAME from the first release of this library
        old_cookie_name = 'mp_' + config['token'] + '_' + config['name'];
        old_cookie = this.storage.parse(old_cookie_name);

        if (old_cookie) {
            this.storage.remove(old_cookie_name);
            this.storage.remove(old_cookie_name, true);

            // Save the prop values that were in the cookie from before -
            // this should only happen once as we delete the old one.
            this.register_once(old_cookie);
        }
    }

    if (this.storage === _.localStorage) {
        old_cookie = _.cookie.parse(this.name);

        _.cookie.remove(this.name);
        _.cookie.remove(this.name, true);

        if (old_cookie) {
            this.register_once(old_cookie);
        }
    }
};

MixpanelPersistence.prototype.save = function() {
    if (this.disabled) { return; }
    this._expire_notification_campaigns();
    this.storage.set(
        this.name,
        _.JSONEncode(this['props']),
        this.expire_days,
        this.cross_subdomain,
        this.secure,
        this.cross_site,
        this.cookie_domain
    );
};

MixpanelPersistence.prototype.remove = function() {
    // remove both domain and subdomain cookies
    this.storage.remove(this.name, false, this.cookie_domain);
    this.storage.remove(this.name, true, this.cookie_domain);
};

// removes the storage entry and deletes all loaded data
// forced name for tests
MixpanelPersistence.prototype.clear = function() {
    this.remove();
    this['props'] = {};
};

/**
* @param {Object} props
* @param {*=} default_value
* @param {number=} days
*/
MixpanelPersistence.prototype.register_once = function(props, default_value, days) {
    if (_.isObject(props)) {
        if (typeof(default_value) === 'undefined') { default_value = 'None'; }
        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;

        _.each(props, function(val, prop) {
            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {
                this['props'][prop] = val;
            }
        }, this);

        this.save();

        return true;
    }
    return false;
};

/**
* @param {Object} props
* @param {number=} days
*/
MixpanelPersistence.prototype.register = function(props, days) {
    if (_.isObject(props)) {
        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;

        _.extend(this['props'], props);

        this.save();

        return true;
    }
    return false;
};

MixpanelPersistence.prototype.unregister = function(prop) {
    if (prop in this['props']) {
        delete this['props'][prop];
        this.save();
    }
};

MixpanelPersistence.prototype._expire_notification_campaigns = _.safewrap(function() {
    var campaigns_shown = this['props'][CAMPAIGN_IDS_KEY],
        EXPIRY_TIME = Config.DEBUG ? 60 * 1000 : 60 * 60 * 1000; // 1 minute (Config.DEBUG) / 1 hour (PDXN)
    if (!campaigns_shown) {
        return;
    }
    for (var campaign_id in campaigns_shown) {
        if (1 * new Date() - campaigns_shown[campaign_id] > EXPIRY_TIME) {
            delete campaigns_shown[campaign_id];
        }
    }
    if (_.isEmptyObject(campaigns_shown)) {
        delete this['props'][CAMPAIGN_IDS_KEY];
    }
});

MixpanelPersistence.prototype.update_campaign_params = function() {
    if (!this.campaign_params_saved) {
        this.register_once(_.info.campaignParams());
        this.campaign_params_saved = true;
    }
};

MixpanelPersistence.prototype.update_search_keyword = function(referrer) {
    this.register(_.info.searchInfo(referrer));
};

// EXPORTED METHOD, we test this directly.
MixpanelPersistence.prototype.update_referrer_info = function(referrer) {
    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.
    this.register_once({
        '$initial_referrer': referrer || '$direct',
        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'
    }, '');
};

MixpanelPersistence.prototype.get_referrer_info = function() {
    return _.strip_empty_properties({
        '$initial_referrer': this['props']['$initial_referrer'],
        '$initial_referring_domain': this['props']['$initial_referring_domain']
    });
};

// safely fills the passed in object with stored properties,
// does not override any properties defined in both
// returns the passed in object
MixpanelPersistence.prototype.safe_merge = function(props) {
    _.each(this['props'], function(val, prop) {
        if (!(prop in props)) {
            props[prop] = val;
        }
    });

    return props;
};

MixpanelPersistence.prototype.update_config = function(config) {
    this.default_expiry = this.expire_days = config['cookie_expiration'];
    this.set_disabled(config['disable_persistence']);
    this.set_cookie_domain(config['cookie_domain']);
    this.set_cross_site(config['cross_site_cookie']);
    this.set_cross_subdomain(config['cross_subdomain_cookie']);
    this.set_secure(config['secure_cookie']);
};

MixpanelPersistence.prototype.set_disabled = function(disabled) {
    this.disabled = disabled;
    if (this.disabled) {
        this.remove();
    } else {
        this.save();
    }
};

MixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {
    if (cookie_domain !== this.cookie_domain) {
        this.remove();
        this.cookie_domain = cookie_domain;
        this.save();
    }
};

MixpanelPersistence.prototype.set_cross_site = function(cross_site) {
    if (cross_site !== this.cross_site) {
        this.cross_site = cross_site;
        this.remove();
        this.save();
    }
};

MixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {
    if (cross_subdomain !== this.cross_subdomain) {
        this.cross_subdomain = cross_subdomain;
        this.remove();
        this.save();
    }
};

MixpanelPersistence.prototype.get_cross_subdomain = function() {
    return this.cross_subdomain;
};

MixpanelPersistence.prototype.set_secure = function(secure) {
    if (secure !== this.secure) {
        this.secure = secure ? true : false;
        this.remove();
        this.save();
    }
};

MixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {
    var q_key = this._get_queue_key(queue),
        q_data = data[queue],
        set_q = this._get_or_create_queue(SET_ACTION),
        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),
        unset_q = this._get_or_create_queue(UNSET_ACTION),
        add_q = this._get_or_create_queue(ADD_ACTION),
        union_q = this._get_or_create_queue(UNION_ACTION),
        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),
        append_q = this._get_or_create_queue(APPEND_ACTION, []);

    if (q_key === SET_QUEUE_KEY) {
        // Update the set queue - we can override any existing values
        _.extend(set_q, q_data);
        // if there was a pending increment, override it
        // with the set.
        this._pop_from_people_queue(ADD_ACTION, q_data);
        // if there was a pending union, override it
        // with the set.
        this._pop_from_people_queue(UNION_ACTION, q_data);
        this._pop_from_people_queue(UNSET_ACTION, q_data);
    } else if (q_key === SET_ONCE_QUEUE_KEY) {
        // only queue the data if there is not already a set_once call for it.
        _.each(q_data, function(v, k) {
            if (!(k in set_once_q)) {
                set_once_q[k] = v;
            }
        });
        this._pop_from_people_queue(UNSET_ACTION, q_data);
    } else if (q_key === UNSET_QUEUE_KEY) {
        _.each(q_data, function(prop) {

            // undo previously-queued actions on this key
            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {
                if (prop in enqueued_obj) {
                    delete enqueued_obj[prop];
                }
            });
            _.each(append_q, function(append_obj) {
                if (prop in append_obj) {
                    delete append_obj[prop];
                }
            });

            unset_q[prop] = true;

        });
    } else if (q_key === ADD_QUEUE_KEY) {
        _.each(q_data, function(v, k) {
            // If it exists in the set queue, increment
            // the value
            if (k in set_q) {
                set_q[k] += v;
            } else {
                // If it doesn't exist, update the add
                // queue
                if (!(k in add_q)) {
                    add_q[k] = 0;
                }
                add_q[k] += v;
            }
        }, this);
        this._pop_from_people_queue(UNSET_ACTION, q_data);
    } else if (q_key === UNION_QUEUE_KEY) {
        _.each(q_data, function(v, k) {
            if (_.isArray(v)) {
                if (!(k in union_q)) {
                    union_q[k] = [];
                }
                // We may send duplicates, the server will dedup them.
                union_q[k] = union_q[k].concat(v);
            }
        });
        this._pop_from_people_queue(UNSET_ACTION, q_data);
    } else if (q_key === REMOVE_QUEUE_KEY) {
        remove_q.push(q_data);
        this._pop_from_people_queue(APPEND_ACTION, q_data);
    } else if (q_key === APPEND_QUEUE_KEY) {
        append_q.push(q_data);
        this._pop_from_people_queue(UNSET_ACTION, q_data);
    }

    console.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');
    console.log(data);

    this.save();
};

MixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {
    var q = this._get_queue(queue);
    if (!_.isUndefined(q)) {
        _.each(data, function(v, k) {
            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {
                // list actions: only remove if both k+v match
                // e.g. remove should not override append in a case like
                // append({foo: 'bar'}); remove({foo: 'qux'})
                _.each(q, function(queued_action) {
                    if (queued_action[k] === v) {
                        delete queued_action[k];
                    }
                });
            } else {
                delete q[k];
            }
        }, this);

        this.save();
    }
};

MixpanelPersistence.prototype._get_queue_key = function(queue) {
    if (queue === SET_ACTION) {
        return SET_QUEUE_KEY;
    } else if (queue === SET_ONCE_ACTION) {
        return SET_ONCE_QUEUE_KEY;
    } else if (queue === UNSET_ACTION) {
        return UNSET_QUEUE_KEY;
    } else if (queue === ADD_ACTION) {
        return ADD_QUEUE_KEY;
    } else if (queue === APPEND_ACTION) {
        return APPEND_QUEUE_KEY;
    } else if (queue === REMOVE_ACTION) {
        return REMOVE_QUEUE_KEY;
    } else if (queue === UNION_ACTION) {
        return UNION_QUEUE_KEY;
    } else {
        console.error('Invalid queue:', queue);
    }
};

MixpanelPersistence.prototype._get_queue = function(queue) {
    return this['props'][this._get_queue_key(queue)];
};
MixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {
    var key = this._get_queue_key(queue);
    default_val = _.isUndefined(default_val) ? {} : default_val;

    return this['props'][key] || (this['props'][key] = default_val);
};

MixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {
    var timers = this['props'][EVENT_TIMERS_KEY] || {};
    timers[event_name] = timestamp;
    this['props'][EVENT_TIMERS_KEY] = timers;
    this.save();
};

MixpanelPersistence.prototype.remove_event_timer = function(event_name) {
    var timers = this['props'][EVENT_TIMERS_KEY] || {};
    var timestamp = timers[event_name];
    if (!_.isUndefined(timestamp)) {
        delete this['props'][EVENT_TIMERS_KEY][event_name];
        this.save();
    }
    return timestamp;
};

/*
 * This file is a js implementation for a subset in eval_node.c
 */

/*
 * Constants
 */
// Metadata keys
/** @const */   var OPERATOR_KEY                  = 'operator';
/** @const */   var PROPERTY_KEY                  = 'property';
/** @const */   var WINDOW_KEY                    = 'window';
/** @const */   var UNIT_KEY                      = 'unit';
/** @const */   var VALUE_KEY                     = 'value';
/** @const */   var HOUR_KEY                      = 'hour';
/** @const */   var DAY_KEY                       = 'day';
/** @const */   var WEEK_KEY                      = 'week';
/** @const */   var MONTH_KEY                     = 'month';

// Operands
/** @const */   var EVENT_PROPERTY         = 'event';
/** @const */   var LITERAL_PROPERTY       = 'literal';

// Binary Operators
/** @const */   var AND_OPERATOR           = 'and';
/** @const */   var OR_OPERATOR            = 'or';
/** @const */   var IN_OPERATOR            = 'in';
/** @const */   var NOT_IN_OPERATOR        = 'not in';
/** @const */   var PLUS_OPERATOR          = '+';
/** @const */   var MINUS_OPERATOR         = '-';
/** @const */   var MUL_OPERATOR           = '*';
/** @const */   var DIV_OPERATOR           = '/';
/** @const */   var MOD_OPERATOR           = '%';
/** @const */   var EQUALS_OPERATOR        = '==';
/** @const */   var NOT_EQUALS_OPERATOR    = '!=';
/** @const */   var GREATER_OPERATOR       = '>';
/** @const */   var LESS_OPERATOR          = '<';
/** @const */   var GREATER_EQUAL_OPERATOR = '>=';
/** @const */   var LESS_EQUAL_OPERATOR    = '<=';

// Typecast Operators
/** @const */   var BOOLEAN_OPERATOR       = 'boolean';
/** @const */   var DATETIME_OPERATOR      = 'datetime';
/** @const */   var LIST_OPERATOR          = 'list';
/** @const */   var NUMBER_OPERATOR        = 'number';
/** @const */   var STRING_OPERATOR        = 'string';

// Unary Operators
/** @const */   var NOT_OPERATOR           = 'not';
/** @const */   var DEFINED_OPERATOR       = 'defined';
/** @const */   var NOT_DEFINED_OPERATOR   = 'not defined';

// Special literals
/** @const */   var NOW_LITERAL            = 'now';

// Type cast functions
function toNumber(value) {
    if (value === null) {
        return null;
    }

    switch (typeof(value)) {
        case 'object':
            if (_.isDate(value) && value.getTime() >= 0) {
                return value.getTime();
            }
            return null;
        case 'boolean':
            return Number(value);
        case 'number':
            return value;
        case 'string':
            value = Number(value);
            if (!isNaN(value)) {
                return value;
            }
            return 0;
    }
    return null;
}

function evaluateNumber(op, properties) {
    if (!op['operator'] || op['operator'] !== NUMBER_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid cast operator: number ' + op);
    }

    return toNumber(evaluateSelector(op['children'][0], properties));
}

function toBoolean(value) {
    if (value === null) {
        return false;
    }

    switch (typeof value) {
        case 'boolean':
            return value;
        case 'number':
            return value !== 0.0;
        case 'string':
            return value.length > 0;
        case 'object':
            if (_.isArray(value) && value.length > 0) {
                return true;
            }
            if (_.isDate(value) && value.getTime() > 0) {
                return true;
            }
            if (_.isObject(value) && !_.isEmptyObject(value)) {
                return true;
            }
            return false;
    }
    return false;
}

function evaluateBoolean(op, properties) {
    if (!op['operator'] || op['operator'] !== BOOLEAN_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid cast operator: boolean ' + op);
    }

    return toBoolean(evaluateSelector(op['children'][0], properties));
}

function evaluateDateTime(op, properties) {
    if (!op['operator'] || op['operator'] !== DATETIME_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid cast operator: datetime ' + op);
    }

    var v = evaluateSelector(op['children'][0], properties);
    if (v === null) {
        return null;
    }

    switch (typeof(v)) {
        case 'number':
        case 'string':
            var d = new Date(v);
            if (isNaN(d.getTime())) {
                return null;
            }
            return d;
        case 'object':
            if (_.isDate(v)) {
                return v;
            }
    }

    return null;
}

function evaluateList(op, properties) {
    if (!op['operator'] || op['operator'] !== LIST_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid cast operator: list ' + op);
    }

    var v = evaluateSelector(op['children'][0], properties);
    if (v === null) {
        return null;
    }

    if (_.isArray(v)) {
        return v;
    }

    return null;
}

function evaluateString(op, properties) {
    if (!op['operator'] || op['operator'] !== STRING_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid cast operator: string ' + op);
    }

    var v = evaluateSelector(op['children'][0], properties);
    switch (typeof(v)) {
        case 'object':
            if (_.isDate(v)) {
                return v.toJSON();
            }
            return JSON.stringify(v);
    }
    return String(v);
}

// Operators
function evaluateAnd(op, properties) {
    if (!op['operator'] || op['operator'] !== AND_OPERATOR || !op['children'] || op['children'].length !== 2) {
        throw ('Invalid operator: AND ' + op);
    }

    return toBoolean(evaluateSelector(op['children'][0], properties)) && toBoolean(evaluateSelector(op['children'][1], properties));
}

function evaluateOr(op, properties) {
    if (!op['operator'] || op['operator'] !== OR_OPERATOR || !op['children'] || op['children'].length !== 2) {
        throw ('Invalid operator: OR ' + op);
    }

    return toBoolean(evaluateSelector(op['children'][0], properties)) || toBoolean(evaluateSelector(op['children'][1], properties));
}

function evaluateIn(op, properties) {
    if (!op['operator'] || [IN_OPERATOR, NOT_IN_OPERATOR].indexOf(op['operator']) === -1 || !op['children'] || op['children'].length !== 2) {
        throw ('Invalid operator: IN/NOT IN ' + op);
    }
    var leftValue = evaluateSelector(op['children'][0], properties);
    var rightValue = evaluateSelector(op['children'][1], properties);

    if (!_.isArray(rightValue) && !_.isString(rightValue)) {
        throw ('Invalid operand for operator IN: invalid type' + rightValue);
    }

    var v = rightValue.indexOf(leftValue) > -1;
    if (op['operator'] === NOT_IN_OPERATOR) {
        return !v;
    }
    return v;
}

function evaluatePlus(op, properties) {
    if (!op['operator'] || op['operator'] !== PLUS_OPERATOR || !op['children'] || op['children'].length < 2) {
        throw ('Invalid operator: PLUS ' + op);
    }
    var l = evaluateSelector(op['children'][0], properties);
    var r = evaluateSelector(op['children'][1], properties);

    if (typeof l === 'number' && typeof r === 'number') {
        return l + r;
    }
    if (typeof l === 'string' && typeof r === 'string') {
        return l + r;
    }
    return null;
}

function evaluateArithmetic(op, properties) {
    if (!op['operator'] || [MINUS_OPERATOR, MUL_OPERATOR, DIV_OPERATOR, MOD_OPERATOR].indexOf(op['operator']) === -1 ||
        !op['children'] || op['children'].length < 2) {
        throw ('Invalid arithmetic operator ' + op);
    }

    var l = evaluateSelector(op['children'][0], properties);
    var r = evaluateSelector(op['children'][1], properties);

    if (typeof l === 'number' && typeof r === 'number') {
        switch (op['operator']) {
            case MINUS_OPERATOR:
                return l - r;
            case MUL_OPERATOR:
                return l * r;
            case DIV_OPERATOR:
                if (r !== 0) {
                    return l / r;
                }
                return null;
            case MOD_OPERATOR:
                if (r === 0) {
                    return null;
                }
                if (l === 0) {
                    return 0;
                }
                if ((l < 0 && r > 0) || (l > 0 && r < 0)) {
                    /* Mimic python modulo - result takes sign of the divisor
                     * if one operand is negative. */
                    return -(Math.floor(l / r) * r - l);
                }
                return l % r;
            default:
                throw('Unknown operator: ' + op['operator']);
        }
    }

    return null;
}

function _isArrayEqual(l, r) {
    if (l === r) return true;
    if (l === null || r === null) return false;
    if (l.length !== r.length) return false;

    for (var i = 0; i < l.length; i++) {
        if (l[i] !== r[i]) {
            return false;
        }
    }

    return true;
}

function _isEqual(l, r) {
    if ( l === null && l === r ) {
        return true;
    }
    if (typeof l === typeof r) {
        switch (typeof l) {
            case 'number':
            case 'string':
            case 'boolean':
                return l === r;
            case 'object':
                if (_.isArray(l) && _.isArray(r)) {
                    return _isArrayEqual(l, r);
                }
                if (_.isDate(l) && _.isDate(r)) {
                    return l.getTime() === r.getTime();
                }
                if (_.isObject(l) && _.isObject(r)) {
                    return JSON.stringify(l) === JSON.stringify(r);
                }
        }
    }
    return false;
}

function evaluateEquality(op, properties) {
    if (!op['operator'] || [EQUALS_OPERATOR, NOT_EQUALS_OPERATOR].indexOf(op['operator']) === -1 || !op['children'] || op['children'].length !== 2) {
        throw ('Invalid equality operator ' + op);
    }

    var v = _isEqual(evaluateSelector(op['children'][0], properties), evaluateSelector(op['children'][1], properties));

    switch (op['operator']) {
        case EQUALS_OPERATOR:
            return v;
        case NOT_EQUALS_OPERATOR:
            return !v;
    }
}

function evaluateComparison(op, properties) {
    if (!op['operator'] ||
        [GREATER_OPERATOR, GREATER_EQUAL_OPERATOR, LESS_OPERATOR, LESS_EQUAL_OPERATOR].indexOf(op['operator']) === -1 ||
        !op['children'] || op['children'].length !== 2) {
        throw ('Invalid comparison operator ' + op);
    }
    var l = evaluateSelector(op['children'][0], properties);
    var r = evaluateSelector(op['children'][1], properties);

    if (typeof(l) === typeof(r)) {
        if (typeof(r) === 'number' || _.isDate(r)) {
            l = toNumber(l);
            r = toNumber(r);
            switch (op['operator']) {
                case GREATER_OPERATOR:
                    return l > r;
                case GREATER_EQUAL_OPERATOR:
                    return l >= r;
                case LESS_OPERATOR:
                    return l < r;
                case LESS_EQUAL_OPERATOR:
                    return l <= r;
            }
        } else if (typeof(r) === 'string') {
            var compare = l.localeCompare(r);
            switch (op['operator']) {
                case GREATER_OPERATOR:
                    return compare > 0;
                case GREATER_EQUAL_OPERATOR:
                    return compare >= 0;
                case LESS_OPERATOR:
                    return compare < 0;
                case LESS_EQUAL_OPERATOR:
                    return compare <= 0;
            }
        }
    }

    return null;
}

function evaluateDefined(op, properties) {
    if (!op['operator'] || [DEFINED_OPERATOR, NOT_DEFINED_OPERATOR].indexOf(op['operator']) === -1 ||
        !op['children'] || op['children'].length !== 1) {
        throw ('Invalid defined/not defined operator: ' + op);
    }

    var b = evaluateSelector(op['children'][0], properties) !== null;
    if (op['operator'] === NOT_DEFINED_OPERATOR) {
        return !b;
    }

    return b;
}

function evaluateNot(op, properties) {
    if (!op['operator'] || op['operator'] !== NOT_OPERATOR || !op['children'] || op['children'].length !== 1) {
        throw ('Invalid not operator: ' + op);
    }

    var v = evaluateSelector(op['children'][0], properties);
    if (v === null) {
        return true;
    }

    if (typeof(v) === 'boolean') {
        return !v;
    }

    return null;
}

function evaluateOperator(op, properties) {
    if (!op['operator']) {
        throw ('Invalid operator: operator key missing ' + op);
    }

    switch (op['operator']) {
        case AND_OPERATOR:
            return evaluateAnd(op, properties);
        case OR_OPERATOR:
            return evaluateOr(op, properties);
        case IN_OPERATOR:
        case NOT_IN_OPERATOR:
            return evaluateIn(op, properties);
        case PLUS_OPERATOR:
            return evaluatePlus(op, properties);
        case MINUS_OPERATOR:
        case MUL_OPERATOR:
        case DIV_OPERATOR:
        case MOD_OPERATOR:
            return evaluateArithmetic(op, properties);
        case EQUALS_OPERATOR:
        case NOT_EQUALS_OPERATOR:
            return evaluateEquality(op, properties);
        case GREATER_OPERATOR:
        case LESS_OPERATOR:
        case GREATER_EQUAL_OPERATOR:
        case LESS_EQUAL_OPERATOR:
            return evaluateComparison(op, properties);
        case BOOLEAN_OPERATOR:
            return evaluateBoolean(op, properties);
        case DATETIME_OPERATOR:
            return evaluateDateTime(op, properties);
        case LIST_OPERATOR:
            return evaluateList(op, properties);
        case NUMBER_OPERATOR:
            return evaluateNumber(op, properties);
        case STRING_OPERATOR:
            return evaluateString(op, properties);
        case DEFINED_OPERATOR:
        case NOT_DEFINED_OPERATOR:
            return evaluateDefined(op, properties);
        case NOT_OPERATOR:
            return evaluateNot(op, properties);
    }
}

function evaluateWindow(value) {
    var win = value[WINDOW_KEY];
    if (!win || !win[UNIT_KEY] || !win[VALUE_KEY]) {
        throw('Invalid window: missing required keys ' + JSON.stringify(value));
    }
    var out = new Date();
    switch (win[UNIT_KEY]) {
        case HOUR_KEY:
            out.setTime(out.getTime() + (win[VALUE_KEY]*-1*60*60*1000));
            break;
        case DAY_KEY:
            out.setTime(out.getTime() + (win[VALUE_KEY]*-1*24*60*60*1000));
            break;
        case WEEK_KEY:
            out.setTime(out.getTime() + (win[VALUE_KEY]*-1*7*24*60*60*1000));
            break;
        case MONTH_KEY:
            out.setTime(out.getTime() + (win[VALUE_KEY]*-1*30*24*60*60*1000));
            break;
        default:
            throw('Invalid unit: ' + win[UNIT_KEY]);
    }

    return out;
}

function evaluateOperand(op, properties) {
    if (!op['property'] || !op['value']) {
        throw('Invalid operand: missing required keys ' + op);
    }
    switch (op['property']) {
        case EVENT_PROPERTY:
            if (properties[op['value']] !== undefined) {
                return properties[op['value']];
            }
            return null;
        case LITERAL_PROPERTY:
            if (op['value'] === NOW_LITERAL) {
                return new Date();
            }
            if (typeof(op['value']) === 'object') {
                return evaluateWindow(op['value']);
            }
            return op['value'];
        default:
            throw('Invalid operand: Invalid property type ' + op['property']);
    }
}

function evaluateSelector(filters, properties) {
    if (filters[PROPERTY_KEY]) {
        return evaluateOperand(filters, properties);
    }
    if (filters[OPERATOR_KEY]) {
        return evaluateOperator(filters, properties);
    }
}

// Internal class for notification display

var MixpanelNotification = function(notif_data, mixpanel_instance) {
    _.bind_instance_methods(this);

    this.mixpanel          = mixpanel_instance;
    this.persistence       = this.mixpanel['persistence'];
    this.resource_protocol = this.mixpanel.get_config('inapp_protocol');
    this.cdn_host          = this.mixpanel.get_config('cdn');

    this.campaign_id = _.escapeHTML(notif_data['id']);
    this.message_id  = _.escapeHTML(notif_data['message_id']);

    this.body            = (_.escapeHTML(notif_data['body']) || '').replace(/\n/g, '<br/>');
    this.cta             = _.escapeHTML(notif_data['cta']) || 'Close';
    this.notif_type      = _.escapeHTML(notif_data['type']) || 'takeover';
    this.style           = _.escapeHTML(notif_data['style']) || 'light';
    this.title           = _.escapeHTML(notif_data['title']) || '';
    this.video_width     = MixpanelNotification.VIDEO_WIDTH;
    this.video_height    = MixpanelNotification.VIDEO_HEIGHT;

    this.display_triggers = notif_data['display_triggers'] || [];

    // These fields are url-sanitized in the backend already.
    this.dest_url        = notif_data['cta_url'] || null;
    this.image_url       = notif_data['image_url'] || null;
    this.thumb_image_url = notif_data['thumb_image_url'] || null;
    this.video_url       = notif_data['video_url'] || null;

    if (this.thumb_image_url && this.thumb_image_url.indexOf('//') === 0) {
        this.thumb_image_url = this.thumb_image_url.replace('//', this.resource_protocol);
    }

    this.clickthrough = true;
    if (!this.dest_url) {
        this.dest_url = '#dismiss';
        this.clickthrough = false;
    }

    this.mini = this.notif_type === 'mini';
    if (!this.mini) {
        this.notif_type = 'takeover';
    }
    this.notif_width = !this.mini ? MixpanelNotification.NOTIF_WIDTH : MixpanelNotification.NOTIF_WIDTH_MINI;

    this._set_client_config();
    this.imgs_to_preload = this._init_image_html();
    this._init_video();
};

MixpanelNotification.ANIM_TIME         = 200;
MixpanelNotification.MARKUP_PREFIX     = 'mixpanel-notification';
MixpanelNotification.BG_OPACITY        = 0.6;
MixpanelNotification.NOTIF_TOP         = 25;
MixpanelNotification.NOTIF_START_TOP   = 200;
MixpanelNotification.NOTIF_WIDTH       = 388;
MixpanelNotification.NOTIF_WIDTH_MINI  = 420;
MixpanelNotification.NOTIF_HEIGHT_MINI = 85;
MixpanelNotification.THUMB_BORDER_SIZE = 5;
MixpanelNotification.THUMB_IMG_SIZE    = 60;
MixpanelNotification.THUMB_OFFSET      = Math.round(MixpanelNotification.THUMB_IMG_SIZE / 2);
MixpanelNotification.VIDEO_WIDTH       = 595;
MixpanelNotification.VIDEO_HEIGHT      = 334;

MixpanelNotification.prototype.show = function() {
    var self = this;
    this._set_client_config();

    // don't display until HTML body exists
    if (!this.body_el) {
        setTimeout(function() { self.show(); }, 300);
        return;
    }

    this._init_styles();
    this._init_notification_el();

    // wait for any images to load before showing notification
    this._preload_images(this._attach_and_animate);
};

MixpanelNotification.prototype.dismiss = _.safewrap(function() {
    if (!this.marked_as_shown) {
        // unexpected condition: user interacted with notif even though we didn't consider it
        // visible (see _mark_as_shown()); send tracking signals to mark delivery
        this._mark_delivery({'invisible': true});
    }

    var exiting_el = this.showing_video ? this._get_el('video') : this._get_notification_display_el();
    if (this.use_transitions) {
        this._remove_class('bg', 'visible');
        this._add_class(exiting_el, 'exiting');
        setTimeout(this._remove_notification_el, MixpanelNotification.ANIM_TIME);
    } else {
        var notif_attr, notif_start, notif_goal;
        if (this.mini) {
            notif_attr  = 'right';
            notif_start = 20;
            notif_goal  = -100;
        } else {
            notif_attr  = 'top';
            notif_start = MixpanelNotification.NOTIF_TOP;
            notif_goal  = MixpanelNotification.NOTIF_START_TOP + MixpanelNotification.NOTIF_TOP;
        }
        this._animate_els([
            {
                el:    this._get_el('bg'),
                attr:  'opacity',
                start: MixpanelNotification.BG_OPACITY,
                goal:  0.0
            },
            {
                el:    exiting_el,
                attr:  'opacity',
                start: 1.0,
                goal:  0.0
            },
            {
                el:    exiting_el,
                attr:  notif_attr,
                start: notif_start,
                goal:  notif_goal
            }
        ], MixpanelNotification.ANIM_TIME, this._remove_notification_el);
    }
});

MixpanelNotification.prototype._add_class = _.safewrap(function(el, class_name) {
    class_name = MixpanelNotification.MARKUP_PREFIX + '-' + class_name;
    if (typeof el === 'string') {
        el = this._get_el(el);
    }
    if (!el.className) {
        el.className = class_name;
    } else if (!~(' ' + el.className + ' ').indexOf(' ' + class_name + ' ')) {
        el.className += ' ' + class_name;
    }
});
MixpanelNotification.prototype._remove_class = _.safewrap(function(el, class_name) {
    class_name = MixpanelNotification.MARKUP_PREFIX + '-' + class_name;
    if (typeof el === 'string') {
        el = this._get_el(el);
    }
    if (el.className) {
        el.className = (' ' + el.className + ' ')
            .replace(' ' + class_name + ' ', '')
            .replace(/^[\s\xA0]+/, '')
            .replace(/[\s\xA0]+$/, '');
    }
});

MixpanelNotification.prototype._animate_els = _.safewrap(function(anims, mss, done_cb, start_time) {
    var self = this,
        in_progress = false,
        ai, anim,
        cur_time = 1 * new Date(), time_diff;

    start_time = start_time || cur_time;
    time_diff = cur_time - start_time;

    for (ai = 0; ai < anims.length; ai++) {
        anim = anims[ai];
        if (typeof anim.val === 'undefined') {
            anim.val = anim.start;
        }
        if (anim.val !== anim.goal) {
            in_progress = true;
            var anim_diff = anim.goal - anim.start,
                anim_dir = anim.goal >= anim.start ? 1 : -1;
            anim.val = anim.start + anim_diff * time_diff / mss;
            if (anim.attr !== 'opacity') {
                anim.val = Math.round(anim.val);
            }
            if ((anim_dir > 0 && anim.val >= anim.goal) || (anim_dir < 0 && anim.val <= anim.goal)) {
                anim.val = anim.goal;
            }
        }
    }
    if (!in_progress) {
        if (done_cb) {
            done_cb();
        }
        return;
    }

    for (ai = 0; ai < anims.length; ai++) {
        anim = anims[ai];
        if (anim.el) {
            var suffix = anim.attr === 'opacity' ? '' : 'px';
            anim.el.style[anim.attr] = String(anim.val) + suffix;
        }
    }
    setTimeout(function() { self._animate_els(anims, mss, done_cb, start_time); }, 10);
});

MixpanelNotification.prototype._attach_and_animate = _.safewrap(function() {
    var self = this;

    // no possibility to double-display
    if (this.shown || this._get_shown_campaigns()[this.campaign_id]) {
        return;
    }
    this.shown = true;

    this.body_el.appendChild(this.notification_el);
    setTimeout(function() {
        var notif_el = self._get_notification_display_el();
        if (self.use_transitions) {
            if (!self.mini) {
                self._add_class('bg', 'visible');
            }
            self._add_class(notif_el, 'visible');
            self._mark_as_shown();
        } else {
            var notif_attr, notif_start, notif_goal;
            if (self.mini) {
                notif_attr  = 'right';
                notif_start = -100;
                notif_goal  = 20;
            } else {
                notif_attr  = 'top';
                notif_start = MixpanelNotification.NOTIF_START_TOP + MixpanelNotification.NOTIF_TOP;
                notif_goal  = MixpanelNotification.NOTIF_TOP;
            }
            self._animate_els([
                {
                    el:    self._get_el('bg'),
                    attr:  'opacity',
                    start: 0.0,
                    goal:  MixpanelNotification.BG_OPACITY
                },
                {
                    el:    notif_el,
                    attr:  'opacity',
                    start: 0.0,
                    goal:  1.0
                },
                {
                    el:    notif_el,
                    attr:  notif_attr,
                    start: notif_start,
                    goal:  notif_goal
                }
            ], MixpanelNotification.ANIM_TIME, self._mark_as_shown);
        }
    }, 100);
    _.register_event(self._get_el('cancel'), 'click', function(e) {
        e.preventDefault();
        self.dismiss();
    });
    var click_el = self._get_el('button') ||
                        self._get_el('mini-content');
    _.register_event(click_el, 'click', function(e) {
        e.preventDefault();
        if (self.show_video) {
            self._track_event('$campaign_open', {'$resource_type': 'video'});
            self._switch_to_video();
        } else {
            self.dismiss();
            if (self.clickthrough) {
                var tracking_cb = null;
                if (self.mixpanel.get_config('inapp_link_new_window')) {
                    window.open(self.dest_url);
                } else {
                    tracking_cb = function() {
                        window.location.href = self.dest_url;
                    };
                }
                self._track_event('$campaign_open', {'$resource_type': 'link'}, tracking_cb);
            }
        }
    });
});

MixpanelNotification.prototype._get_el = function(id) {
    return document.getElementById(MixpanelNotification.MARKUP_PREFIX + '-' + id);
};

MixpanelNotification.prototype._get_notification_display_el = function() {
    return this._get_el(this.notif_type);
};

MixpanelNotification.prototype._get_shown_campaigns = function() {
    return this.persistence['props'][CAMPAIGN_IDS_KEY] || (this.persistence['props'][CAMPAIGN_IDS_KEY] = {});
};

MixpanelNotification.prototype._matches_event_data = _.safewrap(function(event_data) {
    var event_name = event_data['event'] || '';
    for (var i = 0; i < this.display_triggers.length; i++) {
        var display_trigger = this.display_triggers[i];
        var match_event = display_trigger['event'] || '';
        if (match_event === '$any_event' || event_name === display_trigger['event']) {
            if (display_trigger['selector'] && !_.isEmptyObject(display_trigger['selector'])) {
                if (evaluateSelector(display_trigger['selector'], event_data['properties'])) {
                    return true;
                }
            } else {
                return true;
            }
        }
    }
    return false;
});


MixpanelNotification.prototype._browser_lte = function(browser, version) {
    return this.browser_versions[browser] && this.browser_versions[browser] <= version;
};

MixpanelNotification.prototype._init_image_html = function() {
    var imgs_to_preload = [];

    if (!this.mini) {
        if (this.image_url) {
            imgs_to_preload.push(this.image_url);
            this.img_html = '<img id="img" src="' + this.image_url + '"/>';
        } else {
            this.img_html = '';
        }
        if (this.thumb_image_url) {
            imgs_to_preload.push(this.thumb_image_url);
            this.thumb_img_html =
                    '<div id="thumbborder-wrapper"><div id="thumbborder"></div></div>' +
                    '<img id="thumbnail"' +
                        ' src="' + this.thumb_image_url + '"' +
                        ' width="' + MixpanelNotification.THUMB_IMG_SIZE + '"' +
                        ' height="' + MixpanelNotification.THUMB_IMG_SIZE + '"' +
                    '/>' +
                    '<div id="thumbspacer"></div>';
        } else {
            this.thumb_img_html = '';
        }
    } else {
        this.thumb_image_url = this.thumb_image_url || (this.cdn_host + '/site_media/images/icons/notifications/mini-news-dark.png');
        imgs_to_preload.push(this.thumb_image_url);
    }

    return imgs_to_preload;
};

MixpanelNotification.prototype._init_notification_el = function() {
    var notification_html = '';
    var video_src         = '';
    var video_html        = '';
    var cancel_html       = '<div id="cancel">' +
                                    '<div id="cancel-icon"></div>' +
                                '</div>';

    this.notification_el = document.createElement('div');
    this.notification_el.id = MixpanelNotification.MARKUP_PREFIX + '-wrapper';
    if (!this.mini) {
        // TAKEOVER notification
        var close_html  = (this.clickthrough || this.show_video) ? '' : '<div id="button-close"></div>',
            play_html   = this.show_video ? '<div id="button-play"></div>' : '';
        if (this._browser_lte('ie', 7)) {
            close_html = '';
            play_html = '';
        }
        notification_html =
                '<div id="takeover">' +
                    this.thumb_img_html +
                    '<div id="mainbox">' +
                        cancel_html +
                        '<div id="content">' +
                            this.img_html +
                            '<div id="title">' + this.title + '</div>' +
                            '<div id="body">' + this.body + '</div>' +
                            '<div id="tagline">' +
                                '<a href="http://mixpanel.com?from=inapp" target="_blank">POWERED BY MIXPANEL</a>' +
                            '</div>' +
                        '</div>' +
                        '<div id="button">' +
                            close_html +
                            '<a id="button-link" href="' + this.dest_url + '">' + this.cta + '</a>' +
                            play_html +
                        '</div>' +
                    '</div>' +
                '</div>';
    } else {
        // MINI notification
        notification_html =
                '<div id="mini">' +
                    '<div id="mainbox">' +
                        cancel_html +
                        '<div id="mini-content">' +
                            '<div id="mini-icon">' +
                                '<div id="mini-icon-img"></div>' +
                            '</div>' +
                            '<div id="body">' +
                                '<div id="body-text"><div>' + this.body + '</div></div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div id="mini-border"></div>' +
                '</div>';
    }
    if (this.youtube_video) {
        video_src = this.resource_protocol + 'www.youtube.com/embed/' + this.youtube_video +
                '?wmode=transparent&showinfo=0&modestbranding=0&rel=0&autoplay=1&loop=0&vq=hd1080';
        if (this.yt_custom) {
            video_src += '&enablejsapi=1&html5=1&controls=0';
            video_html =
                    '<div id="video-controls">' +
                        '<div id="video-progress" class="video-progress-el">' +
                            '<div id="video-progress-total" class="video-progress-el"></div>' +
                            '<div id="video-elapsed" class="video-progress-el"></div>' +
                        '</div>' +
                        '<div id="video-time" class="video-progress-el"></div>' +
                    '</div>';
        }
    } else if (this.vimeo_video) {
        video_src = this.resource_protocol + 'player.vimeo.com/video/' + this.vimeo_video + '?autoplay=1&title=0&byline=0&portrait=0';
    }
    if (this.show_video) {
        this.video_iframe =
                '<iframe id="' + MixpanelNotification.MARKUP_PREFIX + '-video-frame" ' +
                    'width="' + this.video_width + '" height="' + this.video_height + '" ' +
                    ' src="' + video_src + '"' +
                    ' frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen="1" scrolling="no"' +
                '></iframe>';
        video_html =
                '<div id="video-' + (this.flip_animate ? '' : 'no') + 'flip">' +
                    '<div id="video">' +
                        '<div id="video-holder"></div>' +
                        video_html +
                    '</div>' +
                '</div>';
    }
    var main_html = video_html + notification_html;
    if (this.flip_animate) {
        main_html =
                (this.mini ? notification_html : '') +
                '<div id="flipcontainer"><div id="flipper">' +
                    (this.mini ? video_html : main_html) +
                '</div></div>';
    }

    this.notification_el.innerHTML =
        ('<div id="overlay" class="' + this.notif_type + '">' +
            '<div id="campaignid-' + this.campaign_id + '">' +
                '<div id="bgwrapper">' +
                    '<div id="bg"></div>' +
                    main_html +
                '</div>' +
            '</div>' +
        '</div>')
            .replace(/class="/g, 'class="' + MixpanelNotification.MARKUP_PREFIX + '-')
            .replace(/id="/g, 'id="' + MixpanelNotification.MARKUP_PREFIX + '-');
};

MixpanelNotification.prototype._init_styles = function() {
    if (this.style === 'dark') {
        this.style_vals = {
            bg:             '#1d1f25',
            bg_actions:     '#282b32',
            bg_hover:       '#3a4147',
            bg_light:       '#4a5157',
            border_gray:    '#32353c',
            cancel_opacity: '0.4',
            mini_hover:     '#2a3137',
            text_title:     '#fff',
            text_main:      '#9498a3',
            text_tagline:   '#464851',
            text_hover:     '#ddd'
        };
    } else {
        this.style_vals = {
            bg:             '#fff',
            bg_actions:     '#e7eaee',
            bg_hover:       '#eceff3',
            bg_light:       '#f5f5f5',
            border_gray:    '#e4ecf2',
            cancel_opacity: '1.0',
            mini_hover:     '#fafafa',
            text_title:     '#5c6578',
            text_main:      '#8b949b',
            text_tagline:   '#ced9e6',
            text_hover:     '#7c8598'
        };
    }
    var shadow = '0px 0px 35px 0px rgba(45, 49, 56, 0.7)',
        video_shadow = shadow,
        mini_shadow = shadow,
        thumb_total_size = MixpanelNotification.THUMB_IMG_SIZE + MixpanelNotification.THUMB_BORDER_SIZE * 2,
        anim_seconds = (MixpanelNotification.ANIM_TIME / 1000) + 's';
    if (this.mini) {
        shadow = 'none';
    }

    // don't display on small viewports
    var notif_media_queries = {},
        min_width = MixpanelNotification.NOTIF_WIDTH_MINI + 20;
    notif_media_queries['@media only screen and (max-width: ' + (min_width - 1) + 'px)'] = {
        '#overlay': {
            'display': 'none'
        }
    };
    var notif_styles = {
        '.flipped': {
            'transform': 'rotateY(180deg)'
        },
        '#overlay': {
            'position': 'fixed',
            'top': '0',
            'left': '0',
            'width': '100%',
            'height': '100%',
            'overflow': 'auto',
            'text-align': 'center',
            'z-index': '10000',
            'font-family': '"Helvetica", "Arial", sans-serif',
            '-webkit-font-smoothing': 'antialiased',
            '-moz-osx-font-smoothing': 'grayscale'
        },
        '#overlay.mini': {
            'height': '0',
            'overflow': 'visible'
        },
        '#overlay a': {
            'width': 'initial',
            'padding': '0',
            'text-decoration': 'none',
            'text-transform': 'none',
            'color': 'inherit'
        },
        '#bgwrapper': {
            'position': 'relative',
            'width': '100%',
            'height': '100%'
        },
        '#bg': {
            'position': 'fixed',
            'top': '0',
            'left': '0',
            'width': '100%',
            'height': '100%',
            'min-width': this.doc_width * 4 + 'px',
            'min-height': this.doc_height * 4 + 'px',
            'background-color': 'black',
            'opacity': '0.0',
            '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=60)', // IE8
            'filter': 'alpha(opacity=60)', // IE5-7
            'transition': 'opacity ' + anim_seconds
        },
        '#bg.visible': {
            'opacity': MixpanelNotification.BG_OPACITY
        },
        '.mini #bg': {
            'width': '0',
            'height': '0',
            'min-width': '0'
        },
        '#flipcontainer': {
            'perspective': '1000px',
            'position': 'absolute',
            'width': '100%'
        },
        '#flipper': {
            'position': 'relative',
            'transform-style': 'preserve-3d',
            'transition': '0.3s'
        },
        '#takeover': {
            'position': 'absolute',
            'left': '50%',
            'width': MixpanelNotification.NOTIF_WIDTH + 'px',
            'margin-left': Math.round(-MixpanelNotification.NOTIF_WIDTH / 2) + 'px',
            'backface-visibility': 'hidden',
            'transform': 'rotateY(0deg)',
            'opacity': '0.0',
            'top': MixpanelNotification.NOTIF_START_TOP + 'px',
            'transition': 'opacity ' + anim_seconds + ', top ' + anim_seconds
        },
        '#takeover.visible': {
            'opacity': '1.0',
            'top': MixpanelNotification.NOTIF_TOP + 'px'
        },
        '#takeover.exiting': {
            'opacity': '0.0',
            'top': MixpanelNotification.NOTIF_START_TOP + 'px'
        },
        '#thumbspacer': {
            'height': MixpanelNotification.THUMB_OFFSET + 'px'
        },
        '#thumbborder-wrapper': {
            'position': 'absolute',
            'top': (-MixpanelNotification.THUMB_BORDER_SIZE) + 'px',
            'left': (MixpanelNotification.NOTIF_WIDTH / 2 - MixpanelNotification.THUMB_OFFSET - MixpanelNotification.THUMB_BORDER_SIZE) + 'px',
            'width': thumb_total_size + 'px',
            'height': (thumb_total_size / 2) + 'px',
            'overflow': 'hidden'
        },
        '#thumbborder': {
            'position': 'absolute',
            'width': thumb_total_size + 'px',
            'height': thumb_total_size + 'px',
            'border-radius': thumb_total_size + 'px',
            'background-color': this.style_vals.bg_actions,
            'opacity': '0.5'
        },
        '#thumbnail': {
            'position': 'absolute',
            'top': '0px',
            'left': (MixpanelNotification.NOTIF_WIDTH / 2 - MixpanelNotification.THUMB_OFFSET) + 'px',
            'width': MixpanelNotification.THUMB_IMG_SIZE + 'px',
            'height': MixpanelNotification.THUMB_IMG_SIZE + 'px',
            'overflow': 'hidden',
            'z-index': '100',
            'border-radius': MixpanelNotification.THUMB_IMG_SIZE + 'px'
        },
        '#mini': {
            'position': 'absolute',
            'right': '20px',
            'top': MixpanelNotification.NOTIF_TOP + 'px',
            'width': this.notif_width + 'px',
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI * 2 + 'px',
            'margin-top': 20 - MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'backface-visibility': 'hidden',
            'opacity': '0.0',
            'transform': 'rotateX(90deg)',
            'transition': 'opacity 0.3s, transform 0.3s, right 0.3s'
        },
        '#mini.visible': {
            'opacity': '1.0',
            'transform': 'rotateX(0deg)'
        },
        '#mini.exiting': {
            'opacity': '0.0',
            'right': '-150px'
        },
        '#mainbox': {
            'border-radius': '4px',
            'box-shadow': shadow,
            'text-align': 'center',
            'background-color': this.style_vals.bg,
            'font-size': '14px',
            'color': this.style_vals.text_main
        },
        '#mini #mainbox': {
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'margin-top': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'border-radius': '3px',
            'transition': 'background-color ' + anim_seconds
        },
        '#mini-border': {
            'height': (MixpanelNotification.NOTIF_HEIGHT_MINI + 6) + 'px',
            'width': (MixpanelNotification.NOTIF_WIDTH_MINI + 6) + 'px',
            'position': 'absolute',
            'top': '-3px',
            'left': '-3px',
            'margin-top': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'border-radius': '6px',
            'opacity': '0.25',
            'background-color': '#fff',
            'z-index': '-1',
            'box-shadow': mini_shadow
        },
        '#mini-icon': {
            'position': 'relative',
            'display': 'inline-block',
            'width': '75px',
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'border-radius': '3px 0 0 3px',
            'background-color': this.style_vals.bg_actions,
            'background': 'linear-gradient(135deg, ' + this.style_vals.bg_light + ' 0%, ' + this.style_vals.bg_actions + ' 100%)',
            'transition': 'background-color ' + anim_seconds
        },
        '#mini:hover #mini-icon': {
            'background-color': this.style_vals.mini_hover
        },
        '#mini:hover #mainbox': {
            'background-color': this.style_vals.mini_hover
        },
        '#mini-icon-img': {
            'position': 'absolute',
            'background-image': 'url(' + this.thumb_image_url + ')',
            'width': '48px',
            'height': '48px',
            'top': '20px',
            'left': '12px'
        },
        '#content': {
            'padding': '30px 20px 0px 20px'
        },
        '#mini-content': {
            'text-align': 'left',
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'cursor': 'pointer'
        },
        '#img': {
            'width': '328px',
            'margin-top': '30px',
            'border-radius': '5px'
        },
        '#title': {
            'max-height': '600px',
            'overflow': 'hidden',
            'word-wrap': 'break-word',
            'padding': '25px 0px 20px 0px',
            'font-size': '19px',
            'font-weight': 'bold',
            'color': this.style_vals.text_title
        },
        '#body': {
            'max-height': '600px',
            'margin-bottom': '25px',
            'overflow': 'hidden',
            'word-wrap': 'break-word',
            'line-height': '21px',
            'font-size': '15px',
            'font-weight': 'normal',
            'text-align': 'left'
        },
        '#mini #body': {
            'display': 'inline-block',
            'max-width': '250px',
            'margin': '0 0 0 30px',
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px',
            'font-size': '16px',
            'letter-spacing': '0.8px',
            'color': this.style_vals.text_title
        },
        '#mini #body-text': {
            'display': 'table',
            'height': MixpanelNotification.NOTIF_HEIGHT_MINI + 'px'
        },
        '#mini #body-text div': {
            'display': 'table-cell',
            'vertical-align': 'middle'
        },
        '#tagline': {
            'margin-bottom': '15px',
            'font-size': '10px',
            'font-weight': '600',
            'letter-spacing': '0.8px',
            'color': '#ccd7e0',
            'text-align': 'left'
        },
        '#tagline a': {
            'color': this.style_vals.text_tagline,
            'transition': 'color ' + anim_seconds
        },
        '#tagline a:hover': {
            'color': this.style_vals.text_hover
        },
        '#cancel': {
            'position': 'absolute',
            'right': '0',
            'width': '8px',
            'height': '8px',
            'padding': '10px',
            'border-radius': '20px',
            'margin': '12px 12px 0 0',
            'box-sizing': 'content-box',
            'cursor': 'pointer',
            'transition': 'background-color ' + anim_seconds
        },
        '#mini #cancel': {
            'margin': '7px 7px 0 0'
        },
        '#cancel-icon': {
            'width': '8px',
            'height': '8px',
            'overflow': 'hidden',
            'background-image': 'url(' + this.cdn_host + '/site_media/images/icons/notifications/cancel-x.png)',
            'opacity': this.style_vals.cancel_opacity
        },
        '#cancel:hover': {
            'background-color': this.style_vals.bg_hover
        },
        '#button': {
            'display': 'block',
            'height': '60px',
            'line-height': '60px',
            'text-align': 'center',
            'background-color': this.style_vals.bg_actions,
            'border-radius': '0 0 4px 4px',
            'overflow': 'hidden',
            'cursor': 'pointer',
            'transition': 'background-color ' + anim_seconds
        },
        '#button-close': {
            'display': 'inline-block',
            'width': '9px',
            'height': '60px',
            'margin-right': '8px',
            'vertical-align': 'top',
            'background-image': 'url(' + this.cdn_host + '/site_media/images/icons/notifications/close-x-' + this.style + '.png)',
            'background-repeat': 'no-repeat',
            'background-position': '0px 25px'
        },
        '#button-play': {
            'display': 'inline-block',
            'width': '30px',
            'height': '60px',
            'margin-left': '15px',
            'background-image': 'url(' + this.cdn_host + '/site_media/images/icons/notifications/play-' + this.style + '-small.png)',
            'background-repeat': 'no-repeat',
            'background-position': '0px 15px'
        },
        'a#button-link': {
            'display': 'inline-block',
            'vertical-align': 'top',
            'text-align': 'center',
            'font-size': '17px',
            'font-weight': 'bold',
            'overflow': 'hidden',
            'word-wrap': 'break-word',
            'color': this.style_vals.text_title,
            'transition': 'color ' + anim_seconds
        },
        '#button:hover': {
            'background-color': this.style_vals.bg_hover,
            'color': this.style_vals.text_hover
        },
        '#button:hover a': {
            'color': this.style_vals.text_hover
        },

        '#video-noflip': {
            'position': 'relative',
            'top': (-this.video_height * 2) + 'px'
        },
        '#video-flip': {
            'backface-visibility': 'hidden',
            'transform': 'rotateY(180deg)'
        },
        '#video': {
            'position': 'absolute',
            'width': (this.video_width - 1) + 'px',
            'height': this.video_height + 'px',
            'top': MixpanelNotification.NOTIF_TOP + 'px',
            'margin-top': '100px',
            'left': '50%',
            'margin-left': Math.round(-this.video_width / 2) + 'px',
            'overflow': 'hidden',
            'border-radius': '5px',
            'box-shadow': video_shadow,
            'transform': 'translateZ(1px)', // webkit rendering bug http://stackoverflow.com/questions/18167981/clickable-link-area-unexpectedly-smaller-after-css-transform
            'transition': 'opacity ' + anim_seconds + ', top ' + anim_seconds
        },
        '#video.exiting': {
            'opacity': '0.0',
            'top': this.video_height + 'px'
        },
        '#video-holder': {
            'position': 'absolute',
            'width': (this.video_width - 1) + 'px',
            'height': this.video_height + 'px',
            'overflow': 'hidden',
            'border-radius': '5px'
        },
        '#video-frame': {
            'margin-left': '-1px',
            'width': this.video_width + 'px'
        },
        '#video-controls': {
            'opacity': '0',
            'transition': 'opacity 0.5s'
        },
        '#video:hover #video-controls': {
            'opacity': '1.0'
        },
        '#video .video-progress-el': {
            'position': 'absolute',
            'bottom': '0',
            'height': '25px',
            'border-radius': '0 0 0 5px'
        },
        '#video-progress': {
            'width': '90%'
        },
        '#video-progress-total': {
            'width': '100%',
            'background-color': this.style_vals.bg,
            'opacity': '0.7'
        },
        '#video-elapsed': {
            'width': '0',
            'background-color': '#6cb6f5',
            'opacity': '0.9'
        },
        '#video #video-time': {
            'width': '10%',
            'right': '0',
            'font-size': '11px',
            'line-height': '25px',
            'color': this.style_vals.text_main,
            'background-color': '#666',
            'border-radius': '0 0 5px 0'
        }
    };

    // IE hacks
    if (this._browser_lte('ie', 8)) {
        _.extend(notif_styles, {
            '* html #overlay': {
                'position': 'absolute'
            },
            '* html #bg': {
                'position': 'absolute'
            },
            'html, body': {
                'height': '100%'
            }
        });
    }
    if (this._browser_lte('ie', 7)) {
        _.extend(notif_styles, {
            '#mini #body': {
                'display': 'inline',
                'zoom': '1',
                'border': '1px solid ' + this.style_vals.bg_hover
            },
            '#mini #body-text': {
                'padding': '20px'
            },
            '#mini #mini-icon': {
                'display': 'none'
            }
        });
    }

    // add vendor-prefixed style rules
    var VENDOR_STYLES = [
            'backface-visibility', 'border-radius', 'box-shadow', 'opacity',
            'perspective', 'transform', 'transform-style', 'transition'
        ],
        VENDOR_PREFIXES = ['khtml', 'moz', 'ms', 'o', 'webkit'];
    for (var selector in notif_styles) {
        for (var si = 0; si < VENDOR_STYLES.length; si++) {
            var prop = VENDOR_STYLES[si];
            if (prop in notif_styles[selector]) {
                var val = notif_styles[selector][prop];
                for (var pi = 0; pi < VENDOR_PREFIXES.length; pi++) {
                    notif_styles[selector]['-' + VENDOR_PREFIXES[pi] + '-' + prop] = val;
                }
            }
        }
    }

    var inject_styles = function(styles, media_queries) {
        var create_style_text = function(style_defs) {
            var st = '';
            for (var selector in style_defs) {
                var mp_selector = selector
                    .replace(/#/g, '#' + MixpanelNotification.MARKUP_PREFIX + '-')
                    .replace(/\./g, '.' + MixpanelNotification.MARKUP_PREFIX + '-');
                st += '\n' + mp_selector + ' {';
                var props = style_defs[selector];
                for (var k in props) {
                    st += k + ':' + props[k] + ';';
                }
                st += '}';
            }
            return st;
        };
        var create_media_query_text = function(mq_defs) {
            var mqt = '';
            for (var mq in mq_defs) {
                mqt += '\n' + mq + ' {' + create_style_text(mq_defs[mq]) + '\n}';
            }
            return mqt;
        };

        var style_text = create_style_text(styles) + create_media_query_text(media_queries),
            head_el = document.head || document.getElementsByTagName('head')[0] || document.documentElement,
            style_el = document.createElement('style');
        head_el.appendChild(style_el);
        style_el.setAttribute('type', 'text/css');
        if (style_el.styleSheet) { // IE
            style_el.styleSheet.cssText = style_text;
        } else {
            style_el.textContent = style_text;
        }
    };
    inject_styles(notif_styles, notif_media_queries);
};

MixpanelNotification.prototype._init_video = _.safewrap(function() {
    if (!this.video_url) {
        return;
    }
    var self = this;

    // Youtube iframe API compatibility
    self.yt_custom = 'postMessage' in window;

    self.dest_url = self.video_url;
    var youtube_match = self.video_url.match(
            // http://stackoverflow.com/questions/2936467/parse-youtube-video-id-using-preg-match
            /(?:youtube(?:-nocookie)?\.com\/(?:[^/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?/ ]{11})/i
        ),
        vimeo_match = self.video_url.match(
            /vimeo\.com\/.*?(\d+)/i
        );
    if (youtube_match) {
        self.show_video = true;
        self.youtube_video = youtube_match[1];

        if (self.yt_custom) {
            window['onYouTubeIframeAPIReady'] = function() {
                if (self._get_el('video-frame')) {
                    self._yt_video_ready();
                }
            };

            // load Youtube iframe API; see https://developers.google.com/youtube/iframe_api_reference
            var tag = document.createElement('script');
            tag.src = self.resource_protocol + 'www.youtube.com/iframe_api';
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }
    } else if (vimeo_match) {
        self.show_video = true;
        self.vimeo_video = vimeo_match[1];
    }

    // IE <= 7, FF <= 3: fall through to video link rather than embedded player
    if (self._browser_lte('ie', 7) || self._browser_lte('firefox', 3)) {
        self.show_video = false;
        self.clickthrough = true;
    }
});

MixpanelNotification.prototype._mark_as_shown = _.safewrap(function() {
    // click on background to dismiss
    var self = this;
    _.register_event(self._get_el('bg'), 'click', function() {
        self.dismiss();
    });

    var get_style = function(el, style_name) {
        var styles = {};
        if (document.defaultView && document.defaultView.getComputedStyle) {
            styles = document.defaultView.getComputedStyle(el, null); // FF3 requires both args
        } else if (el.currentStyle) { // IE
            styles = el.currentStyle;
        }
        return styles[style_name];
    };

    if (this.campaign_id) {
        var notif_el = this._get_el('overlay');
        if (notif_el && get_style(notif_el, 'visibility') !== 'hidden' && get_style(notif_el, 'display') !== 'none') {
            this._mark_delivery();
        }
    }
});

MixpanelNotification.prototype._mark_delivery = _.safewrap(function(extra_props) {
    if (!this.marked_as_shown) {
        this.marked_as_shown = true;

        if (this.campaign_id) {
            // mark notification shown (local cache)
            this._get_shown_campaigns()[this.campaign_id] = 1 * new Date();
            this.persistence.save();
        }

        // track delivery
        this._track_event('$campaign_delivery', extra_props);

        // mark notification shown (mixpanel property)
        this.mixpanel['people']['append']({
            '$campaigns': this.campaign_id,
            '$notifications': {
                'campaign_id': this.campaign_id,
                'message_id':  this.message_id,
                'type':        'web',
                'time':        new Date()
            }
        });
    }
});

MixpanelNotification.prototype._preload_images = function(all_loaded_cb) {
    var self = this;
    if (this.imgs_to_preload.length === 0) {
        all_loaded_cb();
        return;
    }

    var preloaded_imgs = 0;
    var img_objs = [];
    var onload = function() {
        preloaded_imgs++;
        if (preloaded_imgs === self.imgs_to_preload.length && all_loaded_cb) {
            all_loaded_cb();
            all_loaded_cb = null;
        }
    };
    for (var i = 0; i < this.imgs_to_preload.length; i++) {
        var img = new Image();
        img.onload = onload;
        img.src = this.imgs_to_preload[i];
        if (img.complete) {
            onload();
        }
        img_objs.push(img);
    }

    // IE6/7 doesn't fire onload reliably
    if (this._browser_lte('ie', 7)) {
        setTimeout(function() {
            var imgs_loaded = true;
            for (i = 0; i < img_objs.length; i++) {
                if (!img_objs[i].complete) {
                    imgs_loaded = false;
                }
            }
            if (imgs_loaded && all_loaded_cb) {
                all_loaded_cb();
                all_loaded_cb = null;
            }
        }, 500);
    }
};

MixpanelNotification.prototype._remove_notification_el = _.safewrap(function() {
    window.clearInterval(this._video_progress_checker);
    this.notification_el.style.visibility = 'hidden';
    this.body_el.removeChild(this.notification_el);
});

MixpanelNotification.prototype._set_client_config = function() {
    var get_browser_version = function(browser_ex) {
        var match = navigator.userAgent.match(browser_ex);
        return match && match[1];
    };
    this.browser_versions = {};
    this.browser_versions['chrome']  = get_browser_version(/Chrome\/(\d+)/);
    this.browser_versions['firefox'] = get_browser_version(/Firefox\/(\d+)/);
    this.browser_versions['ie']      = get_browser_version(/MSIE (\d+).+/);
    if (!this.browser_versions['ie'] && !(window.ActiveXObject) && 'ActiveXObject' in window) {
        this.browser_versions['ie'] = 11;
    }

    this.body_el = document.body || document.getElementsByTagName('body')[0];
    if (this.body_el) {
        this.doc_width = Math.max(
            this.body_el.scrollWidth, document.documentElement.scrollWidth,
            this.body_el.offsetWidth, document.documentElement.offsetWidth,
            this.body_el.clientWidth, document.documentElement.clientWidth
        );
        this.doc_height = Math.max(
            this.body_el.scrollHeight, document.documentElement.scrollHeight,
            this.body_el.offsetHeight, document.documentElement.offsetHeight,
            this.body_el.clientHeight, document.documentElement.clientHeight
        );
    }

    // detect CSS compatibility
    var ie_ver = this.browser_versions['ie'];
    var sample_styles = document.createElement('div').style,
        is_css_compatible = function(rule) {
            if (rule in sample_styles) {
                return true;
            }
            if (!ie_ver) {
                rule = rule[0].toUpperCase() + rule.slice(1);
                var props = ['O' + rule, 'Webkit' + rule, 'Moz' + rule];
                for (var i = 0; i < props.length; i++) {
                    if (props[i] in sample_styles) {
                        return true;
                    }
                }
            }
            return false;
        };
    this.use_transitions = this.body_el &&
        is_css_compatible('transition') &&
        is_css_compatible('transform');
    this.flip_animate = (this.browser_versions['chrome'] >= 33 || this.browser_versions['firefox'] >= 15) &&
        this.body_el &&
        is_css_compatible('backfaceVisibility') &&
        is_css_compatible('perspective') &&
        is_css_compatible('transform');
};

MixpanelNotification.prototype._switch_to_video = _.safewrap(function() {
    var self = this,
        anims = [
            {
                el:    self._get_notification_display_el(),
                attr:  'opacity',
                start: 1.0,
                goal:  0.0
            },
            {
                el:    self._get_notification_display_el(),
                attr:  'top',
                start: MixpanelNotification.NOTIF_TOP,
                goal:  -500
            },
            {
                el:    self._get_el('video-noflip'),
                attr:  'opacity',
                start: 0.0,
                goal:  1.0
            },
            {
                el:    self._get_el('video-noflip'),
                attr:  'top',
                start: -self.video_height * 2,
                goal:  0
            }
        ];

    if (self.mini) {
        var bg = self._get_el('bg'),
            overlay = self._get_el('overlay');
        bg.style.width = '100%';
        bg.style.height = '100%';
        overlay.style.width = '100%';

        self._add_class(self._get_notification_display_el(), 'exiting');
        self._add_class(bg, 'visible');

        anims.push({
            el:    self._get_el('bg'),
            attr:  'opacity',
            start: 0.0,
            goal:  MixpanelNotification.BG_OPACITY
        });
    }

    var video_el = self._get_el('video-holder');
    video_el.innerHTML = self.video_iframe;

    var video_ready = function() {
        if (window['YT'] && window['YT']['loaded']) {
            self._yt_video_ready();
        }
        self.showing_video = true;
        self._get_notification_display_el().style.visibility = 'hidden';
    };
    if (self.flip_animate) {
        self._add_class('flipper', 'flipped');
        setTimeout(video_ready, MixpanelNotification.ANIM_TIME);
    } else {
        self._animate_els(anims, MixpanelNotification.ANIM_TIME, video_ready);
    }
});

MixpanelNotification.prototype._track_event = function(event_name, properties, cb) {
    if (this.campaign_id) {
        properties = properties || {};
        properties = _.extend(properties, {
            'campaign_id':     this.campaign_id,
            'message_id':      this.message_id,
            'message_type':    'web_inapp',
            'message_subtype': this.notif_type
        });
        this.mixpanel['track'](event_name, properties, cb);
    } else if (cb) {
        cb.call();
    }
};

MixpanelNotification.prototype._yt_video_ready = _.safewrap(function() {
    var self = this;
    if (self.video_inited) {
        return;
    }
    self.video_inited = true;

    var progress_bar  = self._get_el('video-elapsed'),
        progress_time = self._get_el('video-time'),
        progress_el   = self._get_el('video-progress');

    new window['YT']['Player'](MixpanelNotification.MARKUP_PREFIX + '-video-frame', {
        'events': {
            'onReady': function(event) {
                var ytplayer = event['target'],
                    video_duration = ytplayer['getDuration'](),
                    pad = function(i) {
                        return ('00' + i).slice(-2);
                    },
                    update_video_time = function(current_time) {
                        var secs = Math.round(video_duration - current_time),
                            mins = Math.floor(secs / 60),
                            hours = Math.floor(mins / 60);
                        secs -= mins * 60;
                        mins -= hours * 60;
                        progress_time.innerHTML = '-' + (hours ? hours + ':' : '') + pad(mins) + ':' + pad(secs);
                    };
                update_video_time(0);
                self._video_progress_checker = window.setInterval(function() {
                    var current_time = ytplayer['getCurrentTime']();
                    progress_bar.style.width = (current_time / video_duration * 100) + '%';
                    update_video_time(current_time);
                }, 250);
                _.register_event(progress_el, 'click', function(e) {
                    var clickx = Math.max(0, e.pageX - progress_el.getBoundingClientRect().left);
                    ytplayer['seekTo'](video_duration * clickx / progress_el.clientWidth, true);
                });
            }
        }
    });
});

/**
 * Mixpanel People Object
 * @constructor
 */
var MixpanelPeople = function() {};

_.extend(MixpanelPeople.prototype, apiActions);

MixpanelPeople.prototype._init = function(mixpanel_instance) {
    this._mixpanel = mixpanel_instance;
};

/*
* Set properties on a user record.
*
* ### Usage:
*
*     mixpanel.people.set('gender', 'm');
*
*     // or set multiple properties at once
*     mixpanel.people.set({
*         'Company': 'Acme',
*         'Plan': 'Premium',
*         'Upgrade date': new Date()
*     });
*     // properties can be strings, integers, dates, or lists
*
* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
* @param {*} [to] A value to set on the given property name
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {
    var data = this.set_action(prop, to);
    if (_.isObject(prop)) {
        callback = to;
    }
    // make sure that the referrer info has been updated and saved
    if (this._get_config('save_referrer')) {
        this._mixpanel['persistence'].update_referrer_info(document.referrer);
    }

    // update $set object with default people properties
    data[SET_ACTION] = _.extend(
        {},
        _.info.people_properties(),
        this._mixpanel['persistence'].get_referrer_info(),
        data[SET_ACTION]
    );
    return this._send_request(data, callback);
});

/*
* Set properties on a user record, only if they do not yet exist.
* This will not overwrite previous people property values, unlike
* people.set().
*
* ### Usage:
*
*     mixpanel.people.set_once('First Login Date', new Date());
*
*     // or set multiple properties at once
*     mixpanel.people.set_once({
*         'First Login Date': new Date(),
*         'Starting Plan': 'Premium'
*     });
*
*     // properties can be strings, integers or dates
*
* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.
* @param {*} [to] A value to set on the given property name
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {
    var data = this.set_once_action(prop, to);
    if (_.isObject(prop)) {
        callback = to;
    }
    return this._send_request(data, callback);
});

/*
* Unset properties on a user record (permanently removes the properties and their values from a profile).
*
* ### Usage:
*
*     mixpanel.people.unset('gender');
*
*     // or unset multiple properties at once
*     mixpanel.people.unset(['gender', 'Company']);
*
* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {
    var data = this.unset_action(prop);
    return this._send_request(data, callback);
});

/*
* Increment/decrement numeric people analytics properties.
*
* ### Usage:
*
*     mixpanel.people.increment('page_views', 1);
*
*     // or, for convenience, if you're just incrementing a counter by
*     // 1, you can simply do
*     mixpanel.people.increment('page_views');
*
*     // to decrement a counter, pass a negative number
*     mixpanel.people.increment('credits_left', -1);
*
*     // like mixpanel.people.set(), you can increment multiple
*     // properties at once:
*     mixpanel.people.increment({
*         counter1: 1,
*         counter2: 6
*     });
*
* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.
* @param {Number} [by] An amount to increment the given property
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {
    var data = {};
    var $add = {};
    if (_.isObject(prop)) {
        _.each(prop, function(v, k) {
            if (!this._is_reserved_property(k)) {
                if (isNaN(parseFloat(v))) {
                    console.error('Invalid increment value passed to mixpanel.people.increment - must be a number');
                    return;
                } else {
                    $add[k] = v;
                }
            }
        }, this);
        callback = by;
    } else {
        // convenience: mixpanel.people.increment('property'); will
        // increment 'property' by 1
        if (_.isUndefined(by)) {
            by = 1;
        }
        $add[prop] = by;
    }
    data[ADD_ACTION] = $add;

    return this._send_request(data, callback);
});

/*
* Append a value to a list-valued people analytics property.
*
* ### Usage:
*
*     // append a value to a list, creating it if needed
*     mixpanel.people.append('pages_visited', 'homepage');
*
*     // like mixpanel.people.set(), you can append multiple
*     // properties at once:
*     mixpanel.people.append({
*         list1: 'bob',
*         list2: 123
*     });
*
* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.
* @param {*} [value] value An item to append to the list
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {
    if (_.isObject(list_name)) {
        callback = value;
    }
    var data = this.append_action(list_name, value);
    return this._send_request(data, callback);
});

/*
* Remove a value from a list-valued people analytics property.
*
* ### Usage:
*
*     mixpanel.people.remove('School', 'UCB');
*
* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.
* @param {*} [value] value Item to remove from the list
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {
    if (_.isObject(list_name)) {
        callback = value;
    }
    var data = this.remove_action(list_name, value);
    return this._send_request(data, callback);
});

/*
* Merge a given list with a list-valued people analytics property,
* excluding duplicate values.
*
* ### Usage:
*
*     // merge a value to a list, creating it if needed
*     mixpanel.people.union('pages_visited', 'homepage');
*
*     // like mixpanel.people.set(), you can append multiple
*     // properties at once:
*     mixpanel.people.union({
*         list1: 'bob',
*         list2: 123
*     });
*
*     // like mixpanel.people.append(), you can append multiple
*     // values to the same list:
*     mixpanel.people.union({
*         list1: ['bob', 'billy']
*     });
*
* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.
* @param {*} [value] Value / values to merge with the given property
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {
    if (_.isObject(list_name)) {
        callback = values;
    }
    var data = this.union_action(list_name, values);
    return this._send_request(data, callback);
});

/*
* Record that you have charged the current user a certain amount
* of money. Charges recorded with track_charge() will appear in the
* Mixpanel revenue report.
*
* ### Usage:
*
*     // charge a user $50
*     mixpanel.people.track_charge(50);
*
*     // charge a user $30.50 on the 2nd of january
*     mixpanel.people.track_charge(30.50, {
*         '$time': new Date('jan 1 2012')
*     });
*
* @param {Number} amount The amount of money charged to the current user
* @param {Object} [properties] An associative array of properties associated with the charge
* @param {Function} [callback] If provided, the callback will be called when the server responds
*/
MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {
    if (!_.isNumber(amount)) {
        amount = parseFloat(amount);
        if (isNaN(amount)) {
            console.error('Invalid value passed to mixpanel.people.track_charge - must be a number');
            return;
        }
    }

    return this.append('$transactions', _.extend({
        '$amount': amount
    }, properties), callback);
});

/*
* Permanently clear all revenue report transactions from the
* current user's people analytics profile.
*
* ### Usage:
*
*     mixpanel.people.clear_charges();
*
* @param {Function} [callback] If provided, the callback will be called after tracking the event.
*/
MixpanelPeople.prototype.clear_charges = function(callback) {
    return this.set('$transactions', [], callback);
};

/*
* Permanently deletes the current people analytics profile from
* Mixpanel (using the current distinct_id).
*
* ### Usage:
*
*     // remove the all data you have stored about the current user
*     mixpanel.people.delete_user();
*
*/
MixpanelPeople.prototype.delete_user = function() {
    if (!this._identify_called()) {
        console.error('mixpanel.people.delete_user() requires you to call identify() first');
        return;
    }
    var data = {'$delete': this._mixpanel.get_distinct_id()};
    return this._send_request(data);
};

MixpanelPeople.prototype.toString = function() {
    return this._mixpanel.toString() + '.people';
};

MixpanelPeople.prototype._send_request = function(data, callback) {
    data['$token'] = this._get_config('token');
    data['$distinct_id'] = this._mixpanel.get_distinct_id();
    var device_id = this._mixpanel.get_property('$device_id');
    var user_id = this._mixpanel.get_property('$user_id');
    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');
    if (device_id) {
        data['$device_id'] = device_id;
    }
    if (user_id) {
        data['$user_id'] = user_id;
    }
    if (had_persisted_distinct_id) {
        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;
    }

    var date_encoded_data = _.encodeDates(data);

    if (!this._identify_called()) {
        this._enqueue(data);
        if (!_.isUndefined(callback)) {
            if (this._get_config('verbose')) {
                callback({status: -1, error: null});
            } else {
                callback(-1);
            }
        }
        return _.truncate(date_encoded_data, 255);
    }

    return this._mixpanel._track_or_batch({
        type: 'people',
        data: date_encoded_data,
        endpoint: this._get_config('api_host') + '/engage/',
        batcher: this._mixpanel.request_batchers.people
    }, callback);
};

MixpanelPeople.prototype._get_config = function(conf_var) {
    return this._mixpanel.get_config(conf_var);
};

MixpanelPeople.prototype._identify_called = function() {
    return this._mixpanel._flags.identify_called === true;
};

// Queue up engage operations if identify hasn't been called yet.
MixpanelPeople.prototype._enqueue = function(data) {
    if (SET_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);
    } else if (SET_ONCE_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);
    } else if (UNSET_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);
    } else if (ADD_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);
    } else if (APPEND_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);
    } else if (REMOVE_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);
    } else if (UNION_ACTION in data) {
        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);
    } else {
        console.error('Invalid call to _enqueue():', data);
    }
};

MixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {
    var _this = this;
    var queued_data = _.extend({}, this._mixpanel['persistence']._get_queue(action));
    var action_params = queued_data;

    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {
        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);
        if (queue_to_params_fn) {
            action_params = queue_to_params_fn(queued_data);
        }
        action_method.call(_this, action_params, function(response, data) {
            // on bad response, we want to add it back to the queue
            if (response === 0) {
                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);
            }
            if (!_.isUndefined(callback)) {
                callback(response, data);
            }
        });
    }
};

// Flush queued engage operations - order does not matter,
// and there are network level race conditions anyway
MixpanelPeople.prototype._flush = function(
    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback
) {
    var _this = this;
    var $append_queue = this._mixpanel['persistence']._get_queue(APPEND_ACTION);
    var $remove_queue = this._mixpanel['persistence']._get_queue(REMOVE_ACTION);

    this._flush_one_queue(SET_ACTION, this.set, _set_callback);
    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);
    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });
    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);
    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);

    // we have to fire off each $append individually since there is
    // no concat method server side
    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {
        var $append_item;
        var append_callback = function(response, data) {
            if (response === 0) {
                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);
            }
            if (!_.isUndefined(_append_callback)) {
                _append_callback(response, data);
            }
        };
        for (var i = $append_queue.length - 1; i >= 0; i--) {
            $append_item = $append_queue.pop();
            if (!_.isEmptyObject($append_item)) {
                _this.append($append_item, append_callback);
            }
        }
        // Save the shortened append queue
        _this._mixpanel['persistence'].save();
    }

    // same for $remove
    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {
        var $remove_item;
        var remove_callback = function(response, data) {
            if (response === 0) {
                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);
            }
            if (!_.isUndefined(_remove_callback)) {
                _remove_callback(response, data);
            }
        };
        for (var j = $remove_queue.length - 1; j >= 0; j--) {
            $remove_item = $remove_queue.pop();
            if (!_.isEmptyObject($remove_item)) {
                _this.remove($remove_item, remove_callback);
            }
        }
        _this._mixpanel['persistence'].save();
    }
};

MixpanelPeople.prototype._is_reserved_property = function(prop) {
    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';
};

// MixpanelPeople Exports
MixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;
MixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;
MixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;
MixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;
MixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;
MixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;
MixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;
MixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;
MixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;
MixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;
MixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;

/*
 * Mixpanel JS Library
 *
 * Copyright 2012, Mixpanel, Inc. All Rights Reserved
 * http://mixpanel.com/
 *
 * Includes portions of Underscore.js
 * http://documentcloud.github.com/underscore/
 * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.
 * Released under the MIT License.
 */

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @output_file_name mixpanel-2.8.min.js
// ==/ClosureCompiler==

/*
SIMPLE STYLE GUIDE:

this.x === public function
this._x === internal - only use within this file
this.__x === private - only use within the class

Globals should be all caps
*/

var init_type;       // MODULE or SNIPPET loader
var mixpanel_master; // main mixpanel instance / object
var INIT_MODULE  = 0;
var INIT_SNIPPET = 1;

var IDENTITY_FUNC = function(x) {return x;};
var NOOP_FUNC = function() {};

/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';


/*
 * Dynamic... constants? Is that an oxymoron?
 */
// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials
var USE_XHR = (window$1.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());

// IE<10 does not support cross-origin XHR's but script tags
// with defer won't block window.onload; ENQUEUE_REQUESTS
// should only be true for Opera<12
var ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);

// save reference to navigator.sendBeacon so it can be minified
var sendBeacon = null;
if (navigator$1['sendBeacon']) {
    sendBeacon = function() {
        // late reference to navigator.sendBeacon to allow patching/spying
        return navigator$1['sendBeacon'].apply(navigator$1, arguments);
    };
}

/*
 * Module-level globals
 */
var DEFAULT_CONFIG = {
    'api_host':                          'https://api-js.mixpanel.com',
    'api_method':                        'POST',
    'api_transport':                     'XHR',
    'app_host':                          'https://mixpanel.com',
    'cdn':                               'https://cdn.mxpnl.com',
    'cross_site_cookie':                 false,
    'cross_subdomain_cookie':            true,
    'persistence':                       'cookie',
    'persistence_name':                  '',
    'cookie_domain':                     '',
    'cookie_name':                       '',
    'loaded':                            NOOP_FUNC,
    'store_google':                      true,
    'save_referrer':                     true,
    'test':                              false,
    'verbose':                           false,
    'img':                               false,
    'debug':                             false,
    'track_links_timeout':               300,
    'cookie_expiration':                 365,
    'upgrade':                           false,
    'disable_persistence':               false,
    'disable_cookie':                    false,
    'secure_cookie':                     false,
    'ip':                                true,
    'opt_out_tracking_by_default':       false,
    'opt_out_persistence_by_default':    false,
    'opt_out_tracking_persistence_type': 'localStorage',
    'opt_out_tracking_cookie_prefix':    null,
    'property_blacklist':                [],
    'xhr_headers':                       {}, // { header: value, header2: value }
    'inapp_protocol':                    '//',
    'inapp_link_new_window':             false,
    'ignore_dnt':                        false,
    'batch_requests':                    false, // for now
    'batch_size':                        50,
    'batch_flush_interval_ms':           5000,
    'batch_request_timeout_ms':          90000,
    'batch_autostart':                   true,
    'hooks':                             {}
};

var DOM_LOADED = false;

/**
 * Mixpanel Library Object
 * @constructor
 */
var MixpanelLib = function() {};


/**
 * create_mplib(token:string, config:object, name:string)
 *
 * This function is used by the init method of MixpanelLib objects
 * as well as the main initializer at the end of the JSLib (that
 * initializes document.mixpanel as well as any additional instances
 * declared before this file has loaded).
 */
var create_mplib = function(token, config, name) {
    var instance,
        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];

    if (target && init_type === INIT_MODULE) {
        instance = target;
    } else {
        if (target && !_.isArray(target)) {
            console.error('You have already initialized ' + name);
            return;
        }
        instance = new MixpanelLib();
    }

    instance._cached_groups = {}; // cache groups in a pool
    instance._user_decide_check_complete = false;
    instance._events_tracked_before_user_decide_check_complete = [];

    instance._init(token, config, name);

    instance['people'] = new MixpanelPeople();
    instance['people']._init(instance);

    // if any instance on the page has debug = true, we set the
    // global debug to be true
    Config.DEBUG = Config.DEBUG || instance.get_config('debug');

    // if target is not defined, we called init after the lib already
    // loaded, so there won't be an array of things to execute
    if (!_.isUndefined(target) && _.isArray(target)) {
        // Crunch through the people queue first - we queue this data up &
        // flush on identify, so it's better to do all these operations first
        instance._execute_array.call(instance['people'], target['people']);
        instance._execute_array(target);
    }

    return instance;
};

var encode_data_for_request = function(data) {
    var json_data = _.JSONEncode(data);
    var encoded_data = _.base64Encode(json_data);
    return {'data': encoded_data};
};

// Initialization methods

/**
 * This function initializes a new instance of the Mixpanel tracking object.
 * All new instances are added to the main mixpanel object as sub properties (such as
 * mixpanel.library_name) and also returned by this function. To define a
 * second instance on the page, you would call:
 *
 *     mixpanel.init('new token', { your: 'config' }, 'library_name');
 *
 * and use it like so:
 *
 *     mixpanel.library_name.track(...);
 *
 * @param {String} token   Your Mixpanel API token
 * @param {Object} [config]  A dictionary of config options to override. <a href="https://github.com/mixpanel/mixpanel-js/blob/8b2e1f7b/src/mixpanel-core.js#L87-L110">See a list of default config options</a>.
 * @param {String} [name]    The name for the new mixpanel instance that you want created
 */
MixpanelLib.prototype.init = function (token, config, name) {
    if (_.isUndefined(name)) {
        console.error('You must name your new library: init(token, config, name)');
        return;
    }
    if (name === PRIMARY_INSTANCE_NAME) {
        console.error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');
        return;
    }

    var instance = create_mplib(token, config, name);
    mixpanel_master[name] = instance;
    instance._loaded();

    return instance;
};

// mixpanel._init(token:string, config:object, name:string)
//
// This function sets up the current instance of the mixpanel
// library.  The difference between this method and the init(...)
// method is this one initializes the actual instance, whereas the
// init(...) method sets up a new library and calls _init on it.
//
MixpanelLib.prototype._init = function(token, config, name) {
    config = config || {};

    this['__loaded'] = true;
    this['config'] = {};
    this['_triggered_notifs'] = [];

    // rollout: enable batch_requests by default for 60% of projects
    // (only if they have not specified a value in their init config
    // and they aren't using a custom API host)
    var variable_features = {};
    var api_host = config['api_host'];
    var is_custom_api = !!api_host && !api_host.match(/\.mixpanel\.com$/);
    if (!('batch_requests' in config) && !is_custom_api && determine_eligibility(token, 'batch', 60)) {
        variable_features['batch_requests'] = true;
    }

    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {
        'name': name,
        'token': token,
        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'
    }));

    this['_jsc'] = NOOP_FUNC;

    this.__dom_loaded_queue = [];
    this.__request_queue = [];
    this.__disabled_events = [];
    this._flags = {
        'disable_all_events': false,
        'identify_called': false
    };

    // set up request queueing/batching
    this.request_batchers = {};
    this._batch_requests = this.get_config('batch_requests');
    if (this._batch_requests) {
        if (!_.localStorage.is_supported(true) || !USE_XHR) {
            this._batch_requests = false;
            console.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');
        } else {
            this.init_batchers();
            if (sendBeacon && window$1.addEventListener) {
                window$1.addEventListener('unload', _.bind(function() {
                    // Before page closes, attempt to flush any events queued up via navigator.sendBeacon.
                    // Since sendBeacon doesn't report success/failure, events will not be removed from
                    // the persistent store; if the site is loaded again, the events will be flushed again
                    // on startup and deduplicated on the Mixpanel server side.
                    if (!this.request_batchers.events.stopped) {
                        this.request_batchers.events.flush({unloading: true});
                    }
                }, this));
            }
        }
    }

    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);
    this.unpersisted_superprops = {};
    this._gdpr_init();

    var uuid = _.UUID();
    if (!this.get_distinct_id()) {
        // There is no need to set the distinct id
        // or the device id if something was already stored
        // in the persitence
        this.register_once({
            'distinct_id': uuid,
            '$device_id': uuid
        }, '');
    }
};

// Private methods

MixpanelLib.prototype._loaded = function() {
    this.get_config('loaded')(this);
    this._set_default_superprops();
};

// update persistence with info on referrer, UTM params, etc
MixpanelLib.prototype._set_default_superprops = function() {
    this['persistence'].update_search_keyword(document$1.referrer);
    if (this.get_config('store_google')) {
        this['persistence'].update_campaign_params();
    }
    if (this.get_config('save_referrer')) {
        this['persistence'].update_referrer_info(document$1.referrer);
    }
};

MixpanelLib.prototype._dom_loaded = function() {
    _.each(this.__dom_loaded_queue, function(item) {
        this._track_dom.apply(this, item);
    }, this);

    if (!this.has_opted_out_tracking()) {
        _.each(this.__request_queue, function(item) {
            this._send_request.apply(this, item);
        }, this);
    }

    delete this.__dom_loaded_queue;
    delete this.__request_queue;
};

MixpanelLib.prototype._track_dom = function(DomClass, args) {
    if (this.get_config('img')) {
        console.error('You can\'t use DOM tracking functions with img = true.');
        return false;
    }

    if (!DOM_LOADED) {
        this.__dom_loaded_queue.push([DomClass, args]);
        return false;
    }

    var dt = new DomClass().init(this);
    return dt.track.apply(dt, args);
};

/**
 * _prepare_callback() should be called by callers of _send_request for use
 * as the callback argument.
 *
 * If there is no callback, this returns null.
 * If we are going to make XHR/XDR requests, this returns a function.
 * If we are going to use script tags, this returns a string to use as the
 * callback GET param.
 */
MixpanelLib.prototype._prepare_callback = function(callback, data) {
    if (_.isUndefined(callback)) {
        return null;
    }

    if (USE_XHR) {
        var callback_function = function(response) {
            callback(response, data);
        };
        return callback_function;
    } else {
        // if the user gives us a callback, we store as a random
        // property on this instances jsc function and update our
        // callback string to reflect that.
        var jsc = this['_jsc'];
        var randomized_cb = '' + Math.floor(Math.random() * 100000000);
        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';
        jsc[randomized_cb] = function(response) {
            delete jsc[randomized_cb];
            callback(response, data);
        };
        return callback_string;
    }
};

MixpanelLib.prototype._send_request = function(url, data, options, callback) {
    var succeeded = true;

    if (ENQUEUE_REQUESTS) {
        this.__request_queue.push(arguments);
        return succeeded;
    }

    var DEFAULT_OPTIONS = {
        method: this.get_config('api_method'),
        transport: this.get_config('api_transport'),
        verbose: this.get_config('verbose')
    };
    var body_data = null;

    if (!callback && (_.isFunction(options) || typeof options === 'string')) {
        callback = options;
        options = null;
    }
    options = _.extend(DEFAULT_OPTIONS, options || {});
    if (!USE_XHR) {
        options.method = 'GET';
    }
    var use_post = options.method === 'POST';
    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';

    // needed to correctly format responses
    var verbose_mode = options.verbose;
    if (data['verbose']) { verbose_mode = true; }

    if (this.get_config('test')) { data['test'] = 1; }
    if (verbose_mode) { data['verbose'] = 1; }
    if (this.get_config('img')) { data['img'] = 1; }
    if (!USE_XHR) {
        if (callback) {
            data['callback'] = callback;
        } else if (verbose_mode || this.get_config('test')) {
            // Verbose output (from verbose mode, or an error in test mode) is a json blob,
            // which by itself is not valid javascript. Without a callback, this verbose output will
            // cause an error when returned via jsonp, so we force a no-op callback param.
            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4
            data['callback'] = '(function(){})';
        }
    }

    data['ip'] = this.get_config('ip')?1:0;
    data['_'] = new Date().getTime().toString();

    if (use_post) {
        body_data = 'data=' + encodeURIComponent(data['data']);
        delete data['data'];
    }

    url += '?' + _.HTTPBuildQuery(data);

    if ('img' in data) {
        var img = document$1.createElement('img');
        img.src = url;
        document$1.body.appendChild(img);
    } else if (use_sendBeacon) {
        try {
            succeeded = sendBeacon(url, body_data);
        } catch (e) {
            console.error(e);
            succeeded = false;
        }
        try {
            if (callback) {
                callback(succeeded ? 1 : 0);
            }
        } catch (e) {
            console.error(e);
        }
    } else if (USE_XHR) {
        try {
            var req = new XMLHttpRequest();
            req.open(options.method, url, true);

            var headers = this.get_config('xhr_headers');
            if (use_post) {
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
            _.each(headers, function(headerValue, headerName) {
                req.setRequestHeader(headerName, headerValue);
            });

            if (options.timeout_ms && typeof req.timeout !== 'undefined') {
                req.timeout = options.timeout_ms;
                var start_time = new Date().getTime();
            }

            // send the mp_optout cookie
            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari
            req.withCredentials = true;
            req.onreadystatechange = function () {
                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4
                    if (req.status === 200) {
                        if (callback) {
                            if (verbose_mode) {
                                var response;
                                try {
                                    response = _.JSONDecode(req.responseText);
                                } catch (e) {
                                    console.error(e);
                                    if (options.ignore_json_errors) {
                                        response = req.responseText;
                                    } else {
                                        return;
                                    }
                                }
                                callback(response);
                            } else {
                                callback(Number(req.responseText));
                            }
                        }
                    } else {
                        var error;
                        if (
                            req.timeout &&
                            !req.status &&
                            new Date().getTime() - start_time >= req.timeout
                        ) {
                            error = 'timeout';
                        } else {
                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;
                        }
                        console.error(error);
                        if (callback) {
                            if (verbose_mode) {
                                callback({status: 0, error: error, xhr_req: req});
                            } else {
                                callback(0);
                            }
                        }
                    }
                }
            };
            req.send(body_data);
        } catch (e) {
            console.error(e);
            succeeded = false;
        }
    } else {
        var script = document$1.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.src = url;
        var s = document$1.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(script, s);
    }

    return succeeded;
};

/**
 * _execute_array() deals with processing any mixpanel function
 * calls that were called before the Mixpanel library were loaded
 * (and are thus stored in an array so they can be called later)
 *
 * Note: we fire off all the mixpanel function calls && user defined
 * functions BEFORE we fire off mixpanel tracking calls. This is so
 * identify/register/set_config calls can properly modify early
 * tracking calls.
 *
 * @param {Array} array
 */
MixpanelLib.prototype._execute_array = function(array) {
    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];
    _.each(array, function(item) {
        if (item) {
            fn_name = item[0];
            if (_.isArray(fn_name)) {
                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()
            } else if (typeof(item) === 'function') {
                item.call(this);
            } else if (_.isArray(item) && fn_name === 'alias') {
                alias_calls.push(item);
            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {
                tracking_calls.push(item);
            } else {
                other_calls.push(item);
            }
        }
    }, this);

    var execute = function(calls, context) {
        _.each(calls, function(item) {
            if (_.isArray(item[0])) {
                // chained call
                var caller = context;
                _.each(item, function(call) {
                    caller = caller[call[0]].apply(caller, call.slice(1));
                });
            } else {
                this[item[0]].apply(this, item.slice(1));
            }
        }, context);
    };

    execute(alias_calls, this);
    execute(other_calls, this);
    execute(tracking_calls, this);
};

// request queueing utils

MixpanelLib.prototype.are_batchers_initialized = function() {
    return !!this.request_batchers.events;
};

MixpanelLib.prototype.init_batchers = function() {
    var token = this.get_config('token');
    if (!this.are_batchers_initialized()) {
        var batcher_for = _.bind(function(attrs) {
            return new RequestBatcher(
                '__mpq_' + token + attrs.queue_suffix,
                {
                    libConfig: this['config'],
                    sendRequestFunc: _.bind(function(data, options, cb) {
                        this._send_request(
                            this.get_config('api_host') + attrs.endpoint,
                            encode_data_for_request(data),
                            options,
                            this._prepare_callback(cb, data)
                        );
                    }, this),
                    beforeSendHook: _.bind(function(item) {
                        return this._run_hook('before_send_' + attrs.type, item);
                    }, this)
                }
            );
        }, this);
        this.request_batchers = {
            events: batcher_for({type: 'events', endpoint: '/track/', queue_suffix: '_ev'}),
            people: batcher_for({type: 'people', endpoint: '/engage/', queue_suffix: '_pp'}),
            groups: batcher_for({type: 'groups', endpoint: '/groups/', queue_suffix: '_gr'})
        };
    }
    if (this.get_config('batch_autostart')) {
        this.start_batch_senders();
    }
};

MixpanelLib.prototype.start_batch_senders = function() {
    if (this.are_batchers_initialized()) {
        this._batch_requests = true;
        _.each(this.request_batchers, function(batcher) {
            batcher.start();
        });
    }
};

MixpanelLib.prototype.stop_batch_senders = function() {
    this._batch_requests = false;
    _.each(this.request_batchers, function(batcher) {
        batcher.stop();
        batcher.clear();
    });
};

/**
 * push() keeps the standard async-array-push
 * behavior around after the lib is loaded.
 * This is only useful for external integrations that
 * do not wish to rely on our convenience methods
 * (created in the snippet).
 *
 * ### Usage:
 *     mixpanel.push(['register', { a: 'b' }]);
 *
 * @param {Array} item A [function_name, args...] array to be executed
 */
MixpanelLib.prototype.push = function(item) {
    this._execute_array([item]);
};

/**
 * Disable events on the Mixpanel object. If passed no arguments,
 * this function disables tracking of any event. If passed an
 * array of event names, those events will be disabled, but other
 * events will continue to be tracked.
 *
 * Note: this function does not stop other mixpanel functions from
 * firing, such as register() or people.set().
 *
 * @param {Array} [events] An array of event names to disable
 */
MixpanelLib.prototype.disable = function(events) {
    if (typeof(events) === 'undefined') {
        this._flags.disable_all_events = true;
    } else {
        this.__disabled_events = this.__disabled_events.concat(events);
    }
};

// internal method for handling track vs batch-enqueue logic
MixpanelLib.prototype._track_or_batch = function(options, callback) {
    var truncated_data = _.truncate(options.data, 255);
    var endpoint = options.endpoint;
    var batcher = options.batcher;
    var should_send_immediately = options.should_send_immediately;
    var send_request_options = options.send_request_options || {};
    callback = callback || NOOP_FUNC;

    var request_enqueued_or_initiated = true;
    var send_request_immediately = _.bind(function() {
        if (!send_request_options.skip_hooks) {
            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);
        }
        if (truncated_data) {
            console.log('MIXPANEL REQUEST:');
            console.log(truncated_data);
            return this._send_request(
                endpoint,
                encode_data_for_request(truncated_data),
                send_request_options,
                this._prepare_callback(callback, truncated_data)
            );
        } else {
            return null;
        }
    }, this);

    if (this._batch_requests && !should_send_immediately) {
        batcher.enqueue(truncated_data, function(succeeded) {
            if (succeeded) {
                callback(1, truncated_data);
            } else {
                send_request_immediately();
            }
        });
    } else {
        request_enqueued_or_initiated = send_request_immediately();
    }

    return request_enqueued_or_initiated && truncated_data;
};

/**
 * Track an event. This is the most important and
 * frequently used Mixpanel function.
 *
 * ### Usage:
 *
 *     // track an event named 'Registered'
 *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
 *
 *     // track an event using navigator.sendBeacon
 *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});
 *
 * To track link clicks or form submissions, see track_links() or track_forms().
 *
 * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.
 * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.
 * @param {Object} [options] Optional configuration for this track request.
 * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').
 * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.
 * @param {Function} [callback] If provided, the callback function will be called after tracking the event.
 * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object
 * with the tracking payload sent to the API server is returned; otherwise false.
 */
MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {
    if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
    }
    options = options || {};
    var transport = options['transport']; // external API, don't minify 'transport' prop
    if (transport) {
        options.transport = transport; // 'transport' prop name can be minified internally
    }
    var should_send_immediately = options['send_immediately'];
    if (typeof callback !== 'function') {
        callback = NOOP_FUNC;
    }

    if (_.isUndefined(event_name)) {
        console.error('No event name provided to mixpanel.track');
        return;
    }

    if (this._event_is_disabled(event_name)) {
        callback(0);
        return;
    }

    // set defaults
    properties = properties || {};
    properties['token'] = this.get_config('token');

    // set $duration if time_event was previously called for this event
    var start_timestamp = this['persistence'].remove_event_timer(event_name);
    if (!_.isUndefined(start_timestamp)) {
        var duration_in_ms = new Date().getTime() - start_timestamp;
        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));
    }

    this._set_default_superprops();

    // note: extend writes to the first object, so lets make sure we
    // don't write to the persistence properties object and info
    // properties object by passing in a new object

    // update properties with pageview info and super-properties
    properties = _.extend(
        {},
        _.info.properties(),
        this['persistence'].properties(),
        this.unpersisted_superprops,
        properties
    );

    var property_blacklist = this.get_config('property_blacklist');
    if (_.isArray(property_blacklist)) {
        _.each(property_blacklist, function(blacklisted_prop) {
            delete properties[blacklisted_prop];
        });
    } else {
        console.error('Invalid value for property_blacklist config: ' + property_blacklist);
    }

    var data = {
        'event': event_name,
        'properties': properties
    };
    var ret = this._track_or_batch({
        type: 'events',
        data: data,
        endpoint: this.get_config('api_host') + '/track/',
        batcher: this.request_batchers.events,
        should_send_immediately: should_send_immediately,
        send_request_options: options
    }, callback);

    this._check_and_handle_triggered_notifications(data);

    return ret;
});

/**
 * Register the current user into one/many groups.
 *
 * ### Usage:
 *
 *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs
 *      mixpanel.set_group('company', 'mixpanel')
 *      mixpanel.set_group('company', 128746312)
 *
 * @param {String} group_key Group key
 * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID
 * @param {Function} [callback] If provided, the callback will be called after tracking the event.
 *
 */
MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {
    if (!_.isArray(group_ids)) {
        group_ids = [group_ids];
    }
    var prop = {};
    prop[group_key] = group_ids;
    this.register(prop);
    return this['people'].set(group_key, group_ids, callback);
});

/**
 * Add a new group for this user.
 *
 * ### Usage:
 *
 *      mixpanel.add_group('company', 'mixpanel')
 *
 * @param {String} group_key Group key
 * @param {*} group_id A valid Mixpanel property type
 * @param {Function} [callback] If provided, the callback will be called after tracking the event.
 */
MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {
    var old_values = this.get_property(group_key);
    if (old_values === undefined) {
        var prop = {};
        prop[group_key] = [group_id];
        this.register(prop);
    } else {
        if (old_values.indexOf(group_id) === -1) {
            old_values.push(group_id);
            this.register(prop);
        }
    }
    return this['people'].union(group_key, group_id, callback);
});

/**
 * Remove a group from this user.
 *
 * ### Usage:
 *
 *      mixpanel.remove_group('company', 'mixpanel')
 *
 * @param {String} group_key Group key
 * @param {*} group_id A valid Mixpanel property type
 * @param {Function} [callback] If provided, the callback will be called after tracking the event.
 */
MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {
    var old_value = this.get_property(group_key);
    // if the value doesn't exist, the persistent store is unchanged
    if (old_value !== undefined) {
        var idx = old_value.indexOf(group_id);
        if (idx > -1) {
            old_value.splice(idx, 1);
            this.register({group_key: old_value});
        }
        if (old_value.length === 0) {
            this.unregister(group_key);
        }
    }
    return this['people'].remove(group_key, group_id, callback);
});

/**
 * Track an event with specific groups.
 *
 * ### Usage:
 *
 *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})
 *
 * @param {String} event_name The name of the event (see `mixpanel.track()`)
 * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)
 * @param {Object=} groups An object mapping group name keys to one or more values
 * @param {Function} [callback] If provided, the callback will be called after tracking the event.
 */
MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {
    var tracking_props = _.extend({}, properties || {});
    _.each(groups, function(v, k) {
        if (v !== null && v !== undefined) {
            tracking_props[k] = v;
        }
    });
    return this.track(event_name, tracking_props, callback);
});

MixpanelLib.prototype._create_map_key = function (group_key, group_id) {
    return group_key + '_' + JSON.stringify(group_id);
};

MixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {
    delete this._cached_groups[this._create_map_key(group_key, group_id)];
};

/**
 * Look up reference to a Mixpanel group
 *
 * ### Usage:
 *
 *       mixpanel.get_group(group_key, group_id)
 *
 * @param {String} group_key Group key
 * @param {Object} group_id A valid Mixpanel property type
 * @returns {Object} A MixpanelGroup identifier
 */
MixpanelLib.prototype.get_group = function (group_key, group_id) {
    var map_key = this._create_map_key(group_key, group_id);
    var group = this._cached_groups[map_key];
    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {
        group = new MixpanelGroup();
        group._init(this, group_key, group_id);
        this._cached_groups[map_key] = group;
    }
    return group;
};

/**
 * Track mp_page_view event. This is now ignored by the server.
 *
 * @param {String} [page] The url of the page to record. If you don't include this, it defaults to the current url.
 * @deprecated
 */
MixpanelLib.prototype.track_pageview = function(page) {
    if (_.isUndefined(page)) {
        page = document$1.location.href;
    }
    this.track('mp_page_view', _.info.pageviewInfo(page));
};

/**
 * Track clicks on a set of document elements. Selector must be a
 * valid query. Elements must exist on the page at the time track_links is called.
 *
 * ### Usage:
 *
 *     // track click for link id #nav
 *     mixpanel.track_links('#nav', 'Clicked Nav Link');
 *
 * ### Notes:
 *
 * This function will wait up to 300 ms for the Mixpanel
 * servers to respond. If they have not responded by that time
 * it will head to the link without ensuring that your event
 * has been tracked.  To configure this timeout please see the
 * set_config() documentation below.
 *
 * If you pass a function in as the properties argument, the
 * function will receive the DOMElement that triggered the
 * event as an argument.  You are expected to return an object
 * from the function; any properties defined on this object
 * will be sent to mixpanel as event properties.
 *
 * @type {Function}
 * @param {Object|String} query A valid DOM query, element or jQuery-esque list
 * @param {String} event_name The name of the event to track
 * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement
 */
MixpanelLib.prototype.track_links = function() {
    return this._track_dom.call(this, LinkTracker, arguments);
};

/**
 * Track form submissions. Selector must be a valid query.
 *
 * ### Usage:
 *
 *     // track submission for form id 'register'
 *     mixpanel.track_forms('#register', 'Created Account');
 *
 * ### Notes:
 *
 * This function will wait up to 300 ms for the mixpanel
 * servers to respond, if they have not responded by that time
 * it will head to the link without ensuring that your event
 * has been tracked.  To configure this timeout please see the
 * set_config() documentation below.
 *
 * If you pass a function in as the properties argument, the
 * function will receive the DOMElement that triggered the
 * event as an argument.  You are expected to return an object
 * from the function; any properties defined on this object
 * will be sent to mixpanel as event properties.
 *
 * @type {Function}
 * @param {Object|String} query A valid DOM query, element or jQuery-esque list
 * @param {String} event_name The name of the event to track
 * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement
 */
MixpanelLib.prototype.track_forms = function() {
    return this._track_dom.call(this, FormTracker, arguments);
};

/**
 * Time an event by including the time between this call and a
 * later 'track' call for the same event in the properties sent
 * with the event.
 *
 * ### Usage:
 *
 *     // time an event named 'Registered'
 *     mixpanel.time_event('Registered');
 *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
 *
 * When called for a particular event name, the next track call for that event
 * name will include the elapsed time between the 'time_event' and 'track'
 * calls. This value is stored as seconds in the '$duration' property.
 *
 * @param {String} event_name The name of the event.
 */
MixpanelLib.prototype.time_event = function(event_name) {
    if (_.isUndefined(event_name)) {
        console.error('No event name provided to mixpanel.time_event');
        return;
    }

    if (this._event_is_disabled(event_name)) {
        return;
    }

    this['persistence'].set_event_timer(event_name,  new Date().getTime());
};

var REGISTER_DEFAULTS = {
    'persistent': true
};
/**
 * Helper to parse options param for register methods, maintaining
 * legacy support for plain "days" param instead of options object
 * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods
 * @returns {Object} options object
 */
var options_for_register = function(days_or_options) {
    var options;
    if (_.isObject(days_or_options)) {
        options = days_or_options;
    } else if (!_.isUndefined(days_or_options)) {
        options = {'days': days_or_options};
    } else {
        options = {};
    }
    return _.extend({}, REGISTER_DEFAULTS, options);
};

/**
 * Register a set of super properties, which are included with all
 * events. This will overwrite previous super property values.
 *
 * ### Usage:
 *
 *     // register 'Gender' as a super property
 *     mixpanel.register({'Gender': 'Female'});
 *
 *     // register several super properties when a user signs up
 *     mixpanel.register({
 *         'Email': 'jdoe@example.com',
 *         'Account Type': 'Free'
 *     });
 *
 *     // register only for the current pageload
 *     mixpanel.register({'Name': 'Pat'}, {persistent: false});
 *
 * @param {Object} properties An associative array of properties to store about the user
 * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)
 * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)
 * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)
 */
MixpanelLib.prototype.register = function(props, days_or_options) {
    var options = options_for_register(days_or_options);
    if (options['persistent']) {
        this['persistence'].register(props, options['days']);
    } else {
        _.extend(this.unpersisted_superprops, props);
    }
};

/**
 * Register a set of super properties only once. This will not
 * overwrite previous super property values, unlike register().
 *
 * ### Usage:
 *
 *     // register a super property for the first time only
 *     mixpanel.register_once({
 *         'First Login Date': new Date().toISOString()
 *     });
 *
 *     // register once, only for the current pageload
 *     mixpanel.register_once({
 *         'First interaction time': new Date().toISOString()
 *     }, 'None', {persistent: false});
 *
 * ### Notes:
 *
 * If default_value is specified, current super properties
 * with that value will be overwritten.
 *
 * @param {Object} properties An associative array of properties to store about the user
 * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'
 * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)
 * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)
 * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)
 */
MixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {
    var options = options_for_register(days_or_options);
    if (options['persistent']) {
        this['persistence'].register_once(props, default_value, options['days']);
    } else {
        if (typeof(default_value) === 'undefined') {
            default_value = 'None';
        }
        _.each(props, function(val, prop) {
            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {
                this.unpersisted_superprops[prop] = val;
            }
        }, this);
    }
};

/**
 * Delete a super property stored with the current user.
 *
 * @param {String} property The name of the super property to remove
 * @param {Object} [options]
 * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)
 */
MixpanelLib.prototype.unregister = function(property, options) {
    options = options_for_register(options);
    if (options['persistent']) {
        this['persistence'].unregister(property);
    } else {
        delete this.unpersisted_superprops[property];
    }
};

MixpanelLib.prototype._register_single = function(prop, value) {
    var props = {};
    props[prop] = value;
    this.register(props);
};

/**
 * Identify a user with a unique ID to track user activity across
 * devices, tie a user to their events, and create a user profile.
 * If you never call this method, unique visitors are tracked using
 * a UUID generated the first time they visit the site.
 *
 * Call identify when you know the identity of the current user,
 * typically after login or signup. We recommend against using
 * identify for anonymous visitors to your site.
 *
 * ### Notes:
 * If your project has
 * <a href="https://help.mixpanel.com/hc/en-us/articles/360039133851">ID Merge</a>
 * enabled, the identify method will connect pre- and
 * post-authentication events when appropriate.
 *
 * If your project does not have ID Merge enabled, identify will
 * change the user's local distinct_id to the unique ID you pass.
 * Events tracked prior to authentication will not be connected
 * to the same user identity. If ID Merge is disabled, alias can
 * be used to connect pre- and post-registration events.
 *
 * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.
 */
MixpanelLib.prototype.identify = function(
    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback
) {
    // Optional Parameters
    //  _set_callback:function  A callback to be run if and when the People set queue is flushed
    //  _add_callback:function  A callback to be run if and when the People add queue is flushed
    //  _append_callback:function  A callback to be run if and when the People append queue is flushed
    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed
    //  _union_callback:function  A callback to be run if and when the People union queue is flushed
    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed

    var previous_distinct_id = this.get_distinct_id();
    this.register({'$user_id': new_distinct_id});

    if (!this.get_property('$device_id')) {
        // The persisted distinct id might not actually be a device id at all
        // it might be a distinct id of the user from before
        var device_id = previous_distinct_id;
        this.register_once({
            '$had_persisted_distinct_id': true,
            '$device_id': device_id
        }, '');
    }

    // identify only changes the distinct id if it doesn't match either the existing or the alias;
    // if it's new, blow away the alias as well.
    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {
        this.unregister(ALIAS_ID_KEY);
        this.register({'distinct_id': new_distinct_id});
    }
    this._check_and_handle_notifications(this.get_distinct_id());
    this._flags.identify_called = true;
    // Flush any queued up people requests
    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);

    // send an $identify event any time the distinct_id is changing - logic on the server
    // will determine whether or not to do anything with it.
    if (new_distinct_id !== previous_distinct_id) {
        this.track('$identify', {
            'distinct_id': new_distinct_id,
            '$anon_distinct_id': previous_distinct_id
        }, {skip_hooks: true});
    }
};

/**
 * Clears super properties and generates a new random distinct_id for this instance.
 * Useful for clearing data when a user logs out.
 */
MixpanelLib.prototype.reset = function() {
    this['persistence'].clear();
    this._flags.identify_called = false;
    var uuid = _.UUID();
    this.register_once({
        'distinct_id': uuid,
        '$device_id': uuid
    }, '');
};

/**
 * Returns the current distinct id of the user. This is either the id automatically
 * generated by the library or the id that has been passed by a call to identify().
 *
 * ### Notes:
 *
 * get_distinct_id() can only be called after the Mixpanel library has finished loading.
 * init() has a loaded function available to handle this automatically. For example:
 *
 *     // set distinct_id after the mixpanel library has loaded
 *     mixpanel.init('YOUR PROJECT TOKEN', {
 *         loaded: function(mixpanel) {
 *             distinct_id = mixpanel.get_distinct_id();
 *         }
 *     });
 */
MixpanelLib.prototype.get_distinct_id = function() {
    return this.get_property('distinct_id');
};

/**
 * The alias method creates an alias which Mixpanel will use to
 * remap one id to another. Multiple aliases can point to the
 * same identifier.
 *
 * The following is a valid use of alias:
 *
 *     mixpanel.alias('new_id', 'existing_id');
 *     // You can add multiple id aliases to the existing ID
 *     mixpanel.alias('newer_id', 'existing_id');
 *
 * Aliases can also be chained - the following is a valid example:
 *
 *     mixpanel.alias('new_id', 'existing_id');
 *     // chain newer_id - new_id - existing_id
 *     mixpanel.alias('newer_id', 'new_id');
 *
 * Aliases cannot point to multiple identifiers - the following
 * example will not work:
 *
 *     mixpanel.alias('new_id', 'existing_id');
 *     // this is invalid as 'new_id' already points to 'existing_id'
 *     mixpanel.alias('new_id', 'newer_id');
 *
 * ### Notes:
 *
 * If your project does not have
 * <a href="https://help.mixpanel.com/hc/en-us/articles/360039133851">ID Merge</a>
 * enabled, the best practice is to call alias once when a unique
 * ID is first created for a user (e.g., when a user first registers
 * for an account). Do not use alias multiple times for a single
 * user without ID Merge enabled.
 *
 * @param {String} alias A unique identifier that you want to use for this user in the future.
 * @param {String} [original] The current identifier being used for this user.
 */
MixpanelLib.prototype.alias = function(alias, original) {
    // If the $people_distinct_id key exists in persistence, there has been a previous
    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with
    // this ID, as it will duplicate users.
    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {
        console.critical('Attempting to create alias for existing People user - aborting.');
        return -2;
    }

    var _this = this;
    if (_.isUndefined(original)) {
        original = this.get_distinct_id();
    }
    if (alias !== original) {
        this._register_single(ALIAS_ID_KEY, alias);
        return this.track('$create_alias', {
            'alias': alias,
            'distinct_id': original
        }, {
            skip_hooks: true
        }, function() {
            // Flush the people queue
            _this.identify(alias);
        });
    } else {
        console.error('alias matches current distinct_id - skipping api call.');
        this.identify(alias);
        return -1;
    }
};

/**
 * Provide a string to recognize the user by. The string passed to
 * this method will appear in the Mixpanel Streams product rather
 * than an automatically generated name. Name tags do not have to
 * be unique.
 *
 * This value will only be included in Streams data.
 *
 * @param {String} name_tag A human readable name for the user
 * @deprecated
 */
MixpanelLib.prototype.name_tag = function(name_tag) {
    this._register_single('mp_name_tag', name_tag);
};

/**
 * Update the configuration of a mixpanel library instance.
 *
 * The default config is:
 *
 *     {
 *       // HTTP method for tracking requests
 *       api_method: 'POST'
 *
 *       // transport for sending requests ('XHR' or 'sendBeacon')
 *       // NB: sendBeacon should only be used for scenarios such as
 *       // page unload where a "best-effort" attempt to send is
 *       // acceptable; the sendBeacon API does not support callbacks
 *       // or any way to know the result of the request. Mixpanel
 *       // tracking via sendBeacon will not support any event-
 *       // batching or retry mechanisms.
 *       api_transport: 'XHR'
 *
 *       // turn on request-batching/queueing/retry
 *       batch_requests: false,
 *
 *       // maximum number of events/updates to send in a single
 *       // network request
 *       batch_size: 50,
 *
 *       // milliseconds to wait between sending batch requests
 *       batch_flush_interval_ms: 5000,
 *
 *       // milliseconds to wait for network responses to batch requests
 *       // before they are considered timed-out and retried
 *       batch_request_timeout_ms: 90000,
 *
 *       // override value for cookie domain, only useful for ensuring
 *       // correct cross-subdomain cookies on unusual domains like
 *       // subdomain.mainsite.avocat.fr; NB this cannot be used to
 *       // set cookies on a different domain than the current origin
 *       cookie_domain: ''
 *
 *       // super properties cookie expiration (in days)
 *       cookie_expiration: 365
 *
 *       // if true, cookie will be set with SameSite=None; Secure
 *       // this is only useful in special situations, like embedded
 *       // 3rd-party iframes that set up a Mixpanel instance
 *       cross_site_cookie: false
 *
 *       // super properties span subdomains
 *       cross_subdomain_cookie: true
 *
 *       // debug mode
 *       debug: false
 *
 *       // if this is true, the mixpanel cookie or localStorage entry
 *       // will be deleted, and no user persistence will take place
 *       disable_persistence: false
 *
 *       // if this is true, Mixpanel will automatically determine
 *       // City, Region and Country data using the IP address of
 *       //the client
 *       ip: true
 *
 *       // opt users out of tracking by this Mixpanel instance by default
 *       opt_out_tracking_by_default: false
 *
 *       // opt users out of browser data storage by this Mixpanel instance by default
 *       opt_out_persistence_by_default: false
 *
 *       // persistence mechanism used by opt-in/opt-out methods - cookie
 *       // or localStorage - falls back to cookie if localStorage is unavailable
 *       opt_out_tracking_persistence_type: 'localStorage'
 *
 *       // customize the name of cookie/localStorage set by opt-in/opt-out methods
 *       opt_out_tracking_cookie_prefix: null
 *
 *       // type of persistent store for super properties (cookie/
 *       // localStorage) if set to 'localStorage', any existing
 *       // mixpanel cookie value with the same persistence_name
 *       // will be transferred to localStorage and deleted
 *       persistence: 'cookie'
 *
 *       // name for super properties persistent store
 *       persistence_name: ''
 *
 *       // names of properties/superproperties which should never
 *       // be sent with track() calls
 *       property_blacklist: []
 *
 *       // if this is true, mixpanel cookies will be marked as
 *       // secure, meaning they will only be transmitted over https
 *       secure_cookie: false
 *
 *       // the amount of time track_links will
 *       // wait for Mixpanel's servers to respond
 *       track_links_timeout: 300
 *
 *       // if you set upgrade to be true, the library will check for
 *       // a cookie from our old js library and import super
 *       // properties from it, then the old cookie is deleted
 *       // The upgrade config option only works in the initialization,
 *       // so make sure you set it when you create the library.
 *       upgrade: false
 *
 *       // extra HTTP request headers to set for each API request, in
 *       // the format {'Header-Name': value}
 *       xhr_headers: {}
 *
 *       // protocol for fetching in-app message resources, e.g.
 *       // 'https://' or 'http://'; defaults to '//' (which defers to the
 *       // current page's protocol)
 *       inapp_protocol: '//'
 *
 *       // whether to open in-app message link in new tab/window
 *       inapp_link_new_window: false
 *
 *       // whether to ignore or respect the web browser's Do Not Track setting
 *       ignore_dnt: false
 *     }
 *
 *
 * @param {Object} config A dictionary of new configuration values to update
 */
MixpanelLib.prototype.set_config = function(config) {
    if (_.isObject(config)) {
        _.extend(this['config'], config);

        var new_batch_size = config['batch_size'];
        if (new_batch_size) {
            _.each(this.request_batchers, function(batcher) {
                batcher.resetBatchSize();
            });
        }

        if (!this.get_config('persistence_name')) {
            this['config']['persistence_name'] = this['config']['cookie_name'];
        }
        if (!this.get_config('disable_persistence')) {
            this['config']['disable_persistence'] = this['config']['disable_cookie'];
        }

        if (this['persistence']) {
            this['persistence'].update_config(this['config']);
        }
        Config.DEBUG = Config.DEBUG || this.get_config('debug');
    }
};

/**
 * returns the current config object for the library.
 */
MixpanelLib.prototype.get_config = function(prop_name) {
    return this['config'][prop_name];
};

/**
 * Fetch a hook function from config, with safe default, and run it
 * against the given arguments
 * @param {string} hook_name which hook to retrieve
 * @returns {any|null} return value of user-provided hook, or null if nothing was returned
 */
MixpanelLib.prototype._run_hook = function(hook_name) {
    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));
    if (typeof ret === 'undefined') {
        console.error(hook_name + ' hook did not return a value');
        ret = null;
    }
    return ret;
};

/**
 * Returns the value of the super property named property_name. If no such
 * property is set, get_property() will return the undefined value.
 *
 * ### Notes:
 *
 * get_property() can only be called after the Mixpanel library has finished loading.
 * init() has a loaded function available to handle this automatically. For example:
 *
 *     // grab value for 'user_id' after the mixpanel library has loaded
 *     mixpanel.init('YOUR PROJECT TOKEN', {
 *         loaded: function(mixpanel) {
 *             user_id = mixpanel.get_property('user_id');
 *         }
 *     });
 *
 * @param {String} property_name The name of the super property you want to retrieve
 */
MixpanelLib.prototype.get_property = function(property_name) {
    return this['persistence']['props'][property_name];
};

MixpanelLib.prototype.toString = function() {
    var name = this.get_config('name');
    if (name !== PRIMARY_INSTANCE_NAME) {
        name = PRIMARY_INSTANCE_NAME + '.' + name;
    }
    return name;
};

MixpanelLib.prototype._event_is_disabled = function(event_name) {
    return _.isBlockedUA(userAgent) ||
        this._flags.disable_all_events ||
        _.include(this.__disabled_events, event_name);
};

MixpanelLib.prototype._check_and_handle_triggered_notifications = addOptOutCheckMixpanelLib(function(event_data) {
    if (!this._user_decide_check_complete) {
        this._events_tracked_before_user_decide_check_complete.push(event_data);
    } else {
        var arr = this['_triggered_notifs'];
        for (var i = 0; i < arr.length; i++) {
            var notif = new MixpanelNotification(arr[i], this);
            if (notif._matches_event_data(event_data)) {
                this._show_notification(arr[i]);
                return;
            }
        }
    }
});

MixpanelLib.prototype._check_and_handle_notifications = addOptOutCheckMixpanelLib(function(distinct_id) {
    if (
        !distinct_id ||
        this._flags.identify_called ||
        this.get_config('disable_notifications')
    ) {
        return;
    }

    console.log('MIXPANEL NOTIFICATION CHECK');

    var data = {
        'verbose':     true,
        'version':     '3',
        'lib':         'web',
        'token':       this.get_config('token'),
        'distinct_id': distinct_id
    };
    this._send_request(
        this.get_config('api_host') + '/decide/',
        data,
        {method: 'GET', transport: 'XHR'},
        this._prepare_callback(_.bind(function(result) {
            if (result['notifications'] && result['notifications'].length > 0) {
                this['_triggered_notifs'] = [];
                var notifications = [];
                _.each(result['notifications'], function(notif) {
                    (notif['display_triggers'] && notif['display_triggers'].length > 0 ? this['_triggered_notifs'] : notifications).push(notif);
                }, this);
                if (notifications.length > 0) {
                    this._show_notification.call(this, notifications[0]);
                }
            }
            this._handle_user_decide_check_complete();
        }, this))
    );
});

MixpanelLib.prototype._handle_user_decide_check_complete = function() {
    this._user_decide_check_complete = true;

    // check notifications against events that were tracked before decide call completed
    var events = this._events_tracked_before_user_decide_check_complete;
    while (events.length > 0) {
        var data = events.shift(); // replay in the same order they came in
        this._check_and_handle_triggered_notifications(data);
    }
};

MixpanelLib.prototype._show_notification = function(notif_data) {
    var notification = new MixpanelNotification(notif_data, this);
    notification.show();
};

// perform some housekeeping around GDPR opt-in/out state
MixpanelLib.prototype._gdpr_init = function() {
    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';

    // try to convert opt-in/out cookies to localStorage if possible
    if (is_localStorage_requested && _.localStorage.is_supported()) {
        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {
            this.opt_in_tracking({'enable_persistence': false});
        }
        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {
            this.opt_out_tracking({'clear_persistence': false});
        }
        this.clear_opt_in_out_tracking({
            'persistence_type': 'cookie',
            'enable_persistence': false
        });
    }

    // check whether the user has already opted out - if so, clear & disable persistence
    if (this.has_opted_out_tracking()) {
        this._gdpr_update_persistence({'clear_persistence': true});

    // check whether we should opt out by default
    // note: we don't clear persistence here by default since opt-out default state is often
    //       used as an initial state while GDPR information is being collected
    } else if (!this.has_opted_in_tracking() && (
        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')
    )) {
        _.cookie.remove('mp_optout');
        this.opt_out_tracking({
            'clear_persistence': this.get_config('opt_out_persistence_by_default')
        });
    }
};

/**
 * Enable or disable persistence based on options
 * only enable/disable if persistence is not already in this state
 * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it
 * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence
 */
MixpanelLib.prototype._gdpr_update_persistence = function(options) {
    var disabled;
    if (options && options['clear_persistence']) {
        disabled = true;
    } else if (options && options['enable_persistence']) {
        disabled = false;
    } else {
        return;
    }

    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {
        this['persistence'].set_disabled(disabled);
    }

    if (disabled) {
        _.each(this.request_batchers, function(batcher) {
            batcher.clear();
        });
    }
};

// call a base gdpr function after constructing the appropriate token and options args
MixpanelLib.prototype._gdpr_call_func = function(func, options) {
    options = _.extend({
        'track': _.bind(this.track, this),
        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),
        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),
        'cookie_expiration': this.get_config('cookie_expiration'),
        'cross_site_cookie': this.get_config('cross_site_cookie'),
        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),
        'cookie_domain': this.get_config('cookie_domain'),
        'secure_cookie': this.get_config('secure_cookie'),
        'ignore_dnt': this.get_config('ignore_dnt')
    }, options);

    // check if localStorage can be used for recording opt out status, fall back to cookie if not
    if (!_.localStorage.is_supported()) {
        options['persistence_type'] = 'cookie';
    }

    return func(this.get_config('token'), {
        track: options['track'],
        trackEventName: options['track_event_name'],
        trackProperties: options['track_properties'],
        persistenceType: options['persistence_type'],
        persistencePrefix: options['cookie_prefix'],
        cookieDomain: options['cookie_domain'],
        cookieExpiration: options['cookie_expiration'],
        crossSiteCookie: options['cross_site_cookie'],
        crossSubdomainCookie: options['cross_subdomain_cookie'],
        secureCookie: options['secure_cookie'],
        ignoreDnt: options['ignore_dnt']
    });
};

/**
 * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance
 *
 * ### Usage
 *
 *     // opt user in
 *     mixpanel.opt_in_tracking();
 *
 *     // opt user in with specific event name, properties, cookie configuration
 *     mixpanel.opt_in_tracking({
 *         track_event_name: 'User opted in',
 *         track_event_properties: {
 *             'Email': 'jdoe@example.com'
 *         },
 *         cookie_expiration: 30,
 *         secure_cookie: true
 *     });
 *
 * @param {Object} [options] A dictionary of config options to override
 * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)
 * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action
 * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action
 * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence
 * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable
 * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)
 * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)
 */
MixpanelLib.prototype.opt_in_tracking = function(options) {
    options = _.extend({
        'enable_persistence': true
    }, options);

    this._gdpr_call_func(optIn, options);
    this._gdpr_update_persistence(options);
};

/**
 * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance
 *
 * ### Usage
 *
 *     // opt user out
 *     mixpanel.opt_out_tracking();
 *
 *     // opt user out with different cookie configuration from Mixpanel instance
 *     mixpanel.opt_out_tracking({
 *         cookie_expiration: 30,
 *         secure_cookie: true
 *     });
 *
 * @param {Object} [options] A dictionary of config options to override
 * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out
 * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence
 * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable
 * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)
 * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)
 */
MixpanelLib.prototype.opt_out_tracking = function(options) {
    options = _.extend({
        'clear_persistence': true,
        'delete_user': true
    }, options);

    // delete user and clear charges since these methods may be disabled by opt-out
    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {
        this['people'].delete_user();
        this['people'].clear_charges();
    }

    this._gdpr_call_func(optOut, options);
    this._gdpr_update_persistence(options);
};

/**
 * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance
 *
 * ### Usage
 *
 *     var has_opted_in = mixpanel.has_opted_in_tracking();
 *     // use has_opted_in value
 *
 * @param {Object} [options] A dictionary of config options to override
 * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable
 * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name
 * @returns {boolean} current opt-in status
 */
MixpanelLib.prototype.has_opted_in_tracking = function(options) {
    return this._gdpr_call_func(hasOptedIn, options);
};

/**
 * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance
 *
 * ### Usage
 *
 *     var has_opted_out = mixpanel.has_opted_out_tracking();
 *     // use has_opted_out value
 *
 * @param {Object} [options] A dictionary of config options to override
 * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable
 * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name
 * @returns {boolean} current opt-out status
 */
MixpanelLib.prototype.has_opted_out_tracking = function(options) {
    return this._gdpr_call_func(hasOptedOut, options);
};

/**
 * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance
 *
 * ### Usage
 *
 *     // clear user's opt-in/out status
 *     mixpanel.clear_opt_in_out_tracking();
 *
 *     // clear user's opt-in/out status with specific cookie configuration - should match
 *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.
 *     mixpanel.clear_opt_in_out_tracking({
 *         cookie_expiration: 30,
 *         secure_cookie: true
 *     });
 *
 * @param {Object} [options] A dictionary of config options to override
 * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence
 * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable
 * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name
 * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)
 * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)
 * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)
 */
MixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {
    options = _.extend({
        'enable_persistence': true
    }, options);

    this._gdpr_call_func(clearOptInOut, options);
    this._gdpr_update_persistence(options);
};

// EXPORTS (for closure compiler)

// MixpanelLib Exports
MixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;
MixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;
MixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;
MixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;
MixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;
MixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;
MixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;
MixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;
MixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;
MixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;
MixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;
MixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;
MixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;
MixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;
MixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;
MixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;
MixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;
MixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;
MixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;
MixpanelLib.prototype['_check_and_handle_notifications']    = MixpanelLib.prototype._check_and_handle_notifications;
MixpanelLib.prototype['_handle_user_decide_check_complete'] = MixpanelLib.prototype._handle_user_decide_check_complete;
MixpanelLib.prototype['_show_notification']                 = MixpanelLib.prototype._show_notification;
MixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;
MixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;
MixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;
MixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;
MixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;
MixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;
MixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;
MixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;
MixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;
MixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;
MixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;
MixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;

// MixpanelPersistence Exports
MixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;
MixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;
MixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;
MixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;
MixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;

_.safewrap_class(MixpanelLib, ['identify', '_check_and_handle_notifications', '_show_notification']);


var instances = {};
var extend_mp = function() {
    // add all the sub mixpanel instances
    _.each(instances, function(instance, name) {
        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }
    });

    // add private functions as _
    mixpanel_master['_'] = _;
};

var override_mp_init_func = function() {
    // we override the snippets init function to handle the case where a
    // user initializes the mixpanel library after the script loads & runs
    mixpanel_master['init'] = function(token, config, name) {
        if (name) {
            // initialize a sub library
            if (!mixpanel_master[name]) {
                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);
                mixpanel_master[name]._loaded();
            }
            return mixpanel_master[name];
        } else {
            var instance = mixpanel_master;

            if (instances[PRIMARY_INSTANCE_NAME]) {
                // main mixpanel lib already initialized
                instance = instances[PRIMARY_INSTANCE_NAME];
            } else if (token) {
                // intialize the main mixpanel lib
                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);
                instance._loaded();
                instances[PRIMARY_INSTANCE_NAME] = instance;
            }

            mixpanel_master = instance;
            if (init_type === INIT_SNIPPET) {
                window$1[PRIMARY_INSTANCE_NAME] = mixpanel_master;
            }
            extend_mp();
        }
    };
};

var add_dom_loaded_handler = function() {
    // Cross browser DOM Loaded support
    function dom_loaded_handler() {
        // function flag since we only want to execute this once
        if (dom_loaded_handler.done) { return; }
        dom_loaded_handler.done = true;

        DOM_LOADED = true;
        ENQUEUE_REQUESTS = false;

        _.each(instances, function(inst) {
            inst._dom_loaded();
        });
    }

    function do_scroll_check() {
        try {
            document$1.documentElement.doScroll('left');
        } catch(e) {
            setTimeout(do_scroll_check, 1);
            return;
        }

        dom_loaded_handler();
    }

    if (document$1.addEventListener) {
        if (document$1.readyState === 'complete') {
            // safari 4 can fire the DOMContentLoaded event before loading all
            // external JS (including this file). you will see some copypasta
            // on the internet that checks for 'complete' and 'loaded', but
            // 'loaded' is an IE thing
            dom_loaded_handler();
        } else {
            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);
        }
    } else if (document$1.attachEvent) {
        // IE
        document$1.attachEvent('onreadystatechange', dom_loaded_handler);

        // check to make sure we arn't in a frame
        var toplevel = false;
        try {
            toplevel = window$1.frameElement === null;
        } catch(e) {
            // noop
        }

        if (document$1.documentElement.doScroll && toplevel) {
            do_scroll_check();
        }
    }

    // fallback handler, always will work
    _.register_event(window$1, 'load', dom_loaded_handler, true);
};

function init_as_module() {
    init_type = INIT_MODULE;
    mixpanel_master = new MixpanelLib();

    override_mp_init_func();
    mixpanel_master['init']();
    add_dom_loaded_handler();

    return mixpanel_master;
}

var mixpanel = init_as_module();

module.exports = mixpanel;

/***/ }),

/***/ "./src/js/canvas.ts":
/*!**************************!*\
  !*** ./src/js/canvas.ts ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
/* harmony import */ var _models_player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/player */ "./src/js/models/player.ts");
/* harmony import */ var _models_enemies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/enemies */ "./src/js/models/enemies.ts");
/* harmony import */ var _models_powerups__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/powerups */ "./src/js/models/powerups.ts");
/* harmony import */ var _models_particles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/particles */ "./src/js/models/particles.ts");





var mixpanel = __webpack_require__(/*! mixpanel-browser */ "./node_modules/mixpanel-browser/dist/mixpanel.cjs.js");
mixpanel.init("a2a81abd1412e518b277e0bfbab414bc");
// HTML elements
var canvas = document.querySelector('canvas');
var scoreEl = document.querySelector('#scoreEl');
var levelEl = document.querySelector('#levelEl');
var modalEl = document.querySelector('#modalEl');
var comboEl = document.querySelector('#comboEl');
var bigScoreEl = document.querySelector('#bigScoreEl');
var startGameBtn = document.querySelector('#startGameBtn');
var inforBarEl = document.querySelector('#infoBar');
var longComboEl = document.querySelector('#longestComboEl');
var runtimeEl = document.querySelector('#timeEl');
var victoryEl = document.querySelector('#victoryEl');
// Songs
var albatrossSongURL = './audio/albatross.mp3';
var movingMiamiSongURL = './audio/moving_to_miami.mp3';
var inCloudsSongURL = './audio/in_clouds.mp3';
var currentSong = albatrossSongURL;
var backgroundMusic = new Audio(currentSong);
backgroundMusic.volume = 0.66;
backgroundMusic.currentTime = 0;
var bossMusic = new Audio('./audio/altBoss.mp3');
bossMusic.loop = true;
var victoryMusicURL = './audio/rising_stars.mp3';
var victorySong = new Audio(victoryMusicURL);
var winSound = new Audio('/audio/activation.mp3');
function nextSong() {
    switch (currentSong) {
        case albatrossSongURL:
        default:
            backgroundMusic.src = movingMiamiSongURL;
            backgroundMusic.volume = 0.4;
            break;
        case inCloudsSongURL:
            backgroundMusic.src = albatrossSongURL;
            backgroundMusic.volume = 0.5;
            break;
        case movingMiamiSongURL:
            backgroundMusic.src = inCloudsSongURL;
            backgroundMusic.volume = 0.33;
            break;
    }
    if (!scene.boss) {
        backgroundMusic.src = currentSong;
        backgroundMusic.pause();
        backgroundMusic.load();
        backgroundMusic.play();
    }
}
// Sound FX
var startGameAudio = new Audio('./audio/start.mp3');
var endGameAudio = new Audio('./audio/altEnd.mp3');
var comboBreak = new Audio('./audio/destroy.mp3');
var destroyEnemy = new Audio('./audio/continue.mp3');
var obtainPowerupAudio = new Audio('./audio/powerup.mp3');
var alarmAudio = new Audio('./audio/warning.mp3');
backgroundMusic.addEventListener('ended', nextSong);
victorySong.addEventListener('ended', nextSong);
var scene = {
    active: false,
    boss: false,
    color: undefined,
};
var keys = {
    up: false,
    down: false,
    right: false,
    left: false
};
var mouse = {
    down: false,
    x: undefined,
    y: undefined,
};
var c = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight - inforBarEl.clientHeight;
var topLeft = { x: 0, y: 0 };
var bottomRight = { x: 0, y: 0 };
var animationId;
var player;
var powerUps;
var particles;
var enemies;
var projectiles;
var backgroundParticles;
var frame;
var score;
var level;
var combo;
var litCount;
var particleCount;
var powerupTimeout = setTimeout(function () { }, 0); // let type inference do its thing
var spacing = 30;
var padding = 50;
var enableMixpanel = true;
// stats
var longestCombo;
var startTime;
function init() {
    if (window.location.hostname === 'localhost') {
        enableMixpanel = false;
    }
    console.log(window.location);
    canvas.width = innerWidth;
    canvas.height = innerHeight - inforBarEl.clientHeight;
    topLeft = {
        x: 0 + padding,
        y: 0 + padding
    };
    bottomRight = {
        x: canvas.width - padding,
        y: canvas.height - padding
    };
    score = 0;
    combo = 0;
    frame = 0;
    level = 1;
    longestCombo = 0;
    startTime = Date.now();
    comboEl.innerHTML = combo.toString();
    victoryEl.style.display = 'none';
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(bossMusic, {
        volume: 0.0,
        duration: 4,
        onComplete: function () {
            bossMusic.pause();
            bossMusic.currentTime = 0;
            bossMusic.volume = 1.0;
        }
    });
    backgroundMusic.volume = 0.5;
    backgroundMusic.play();
    scene.boss = false;
    levelEl.innerHTML = level.toString();
    player = new _models_player__WEBPACK_IMPORTED_MODULE_1__["Player"](topLeft, bottomRight, 10, 'ivory');
    projectiles = [];
    particles = [];
    enemies = [];
    powerUps = [];
    backgroundParticles = [];
    for (var i = topLeft.x; i < bottomRight.x; i += spacing) {
        for (var j = topLeft.y; j < bottomRight.y; j += spacing) {
            backgroundParticles.push(new _models_particles__WEBPACK_IMPORTED_MODULE_4__["BackgroundParticle"](i, j, 3, 'ivory'));
        }
    }
    particleCount = backgroundParticles.length;
    litCount = 0;
}
function animate() {
    animationId = requestAnimationFrame(animate);
    frame++;
    c.fillStyle = 'rgba(0, 0, 0, 0.5)'; // create motion blur effect
    c.fillRect(0, 0, canvas.width, canvas.height);
    if (frame % 300 === 0) {
        setLevel(score);
        spawnEnemies(level);
        if (Math.random() < 0.20)
            spawnPowerUp();
    }
    lightUpBackgroundParticles();
    updatePowerups();
    updateEnemies();
    player.update(c, keys);
    if (player.powerUp === 'Automatic' && mouse.down && frame % 4 === 0) {
        projectiles.push(player.shoot(mouse));
    }
    cleanup();
}
function updateEnemies() {
    enemies.forEach(function (enemy, index) {
        var dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist - enemy.radius - player.radius < 1)
            endGame();
        enemy.update(c, player.x, player.y);
        // check if enemy hit any projectiles
        projectiles.forEach(function (projectile, projectileIndex) {
            var dist = Math.hypot(projectile.x - enemy.x, projectile.y - enemy.y);
            if (dist - enemy.radius - projectile.radius < 0.1 && enemy.radius > 0) {
                var splashAmount = Math.max(16, enemy.radius / 6);
                var splashAngle = Math.atan2(projectile.y - enemy.y, projectile.x - enemy.x);
                hitSplash(projectile.x, projectile.y, enemy.color, splashAmount, splashAngle);
                setTimeout(function () { return projectiles.splice(projectileIndex, 1); }, 0);
                if (enemy.hit(projectile.power)) {
                    // i.e. enemy survived hit
                    addScore(100, projectile);
                }
                else {
                    enemy.color === scene.color ? continueCombo() : breakCombo(enemy);
                    if (enemy.isBoss)
                        winGame();
                    // extra splash for kill
                    var splashAmount_1 = Math.random() * 12 + 6;
                    hitSplash(projectile.x, projectile.y, enemy.color, splashAmount_1, splashAngle);
                    addScore(enemy.points, projectile);
                    setTimeout(function () {
                        var enemyIndex = enemies.findIndex(function (e) { return e.id === enemy.id; });
                        if (enemyIndex >= 0)
                            enemies.splice(enemyIndex, 1);
                    }, 250);
                }
            }
        });
        // check for collisions with other enemies. For loop to not double collide.
        for (var i = index + 1; i < enemies.length; i++) {
            var e = enemies[i];
            var dist_1 = Math.hypot(enemy.x - e.x, enemy.y - e.y);
            if (dist_1 - enemy.radius - e.radius < 0.1 && enemy.radius > 0) {
                resolveCollision(e, enemy);
            }
        }
        // bounce off walls
        var collidedWithX = enemy.x - enemy.radius + enemy.velocity.x < topLeft.x || enemy.x + enemy.radius + enemy.velocity.x > bottomRight.x;
        var collidedWithY = enemy.y - enemy.radius + enemy.velocity.y < topLeft.y || enemy.y + enemy.radius + enemy.velocity.y > bottomRight.y;
        if (enemy.inPlay) {
            if (collidedWithX) {
                enemy.velocity.x = -enemy.velocity.x;
                if (enemy.type === 'oscilator') {
                    enemy.drive.x = -enemy.drive.x;
                }
            }
            if (collidedWithY) {
                enemy.velocity.y = -enemy.velocity.y;
                if (enemy.type === 'oscilator') {
                    enemy.drive.y = -enemy.drive.y;
                }
            }
        }
        else {
            enemy.inPlay = !(collidedWithX || collidedWithY);
        }
    });
}
function updatePowerups() {
    powerUps.forEach(function (powerUp, index) {
        var dist = Math.hypot(player.x - powerUp.x, player.y - powerUp.y);
        if (dist - player.radius - powerUp.width / 2 < 1) {
            var obtainSound = obtainPowerupAudio.cloneNode();
            obtainSound.play();
            player.powerUp = 'Automatic';
            player.color = '#FFF500';
            powerUps.splice(index, 1);
            clearTimeout(powerupTimeout);
            powerupTimeout = setTimeout(function () {
                player.powerUp = '';
                player.color = '#FFF';
            }, 5000);
        }
        else {
            powerUp.update(c);
        }
        var collidedWithX = powerUp.x - powerUp.width / 2 <= topLeft.x || powerUp.x + powerUp.width / 2 >= bottomRight.x;
        var collidedWithY = powerUp.y - powerUp.height / 3 <= topLeft.y || powerUp.y + powerUp.height / 2 >= bottomRight.x;
        if (powerUp.inPlay) {
            if (collidedWithX) {
                powerUp.velocity.x = -powerUp.velocity.x;
            }
            if (collidedWithY) {
                powerUp.velocity.y = -powerUp.velocity.y;
            }
        }
        else {
            powerUp.inPlay = !(collidedWithX || collidedWithY);
        }
    });
}
function lightUpBackgroundParticles() {
    backgroundParticles.forEach(function (bp) {
        var dist = Math.hypot(player.x - bp.x, player.y - bp.y);
        var hideRadius = 125;
        if (dist < hideRadius) {
            // hide close particles, illuminate radius
            bp.alpha = dist < 70 ? 0 : 0.35;
            if (!bp.touched) {
                litCount += 1;
                bp.touched = true;
                if (litCount / particleCount > 0.60) {
                    player.unleash(bp.color);
                    backgroundParticles.forEach(function (bp) { return bp.touch(); });
                }
            }
        }
        bp.update(c);
    });
}
/**
 * Rotates coordinate system for velocities
 *
 * Takes velocities and alters them as if the coordinate system they're on was rotated
 *
 * @param  Object | velocity | The velocity of an individual particle
 * @param  Float  | angle    | The angle of collision between two objects in radians
 * @return Object | The altered x and y velocities after the coordinate system has been rotated
 */
function rotate(velocity, angle) {
    var rotatedVelocities = {
        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
    };
    return rotatedVelocities;
}
/**
 * Swaps out two colliding particles' x and y velocities after running through
 * an elastic collision reaction equation
 *
 * @param  Object | particle      | A particle object with x and y coordinates, plus velocity
 * @param  Object | otherParticle | A particle object with x and y coordinates, plus velocity
 * @return Null | Does not return a value
 */
function resolveCollision(particle, otherParticle) {
    var xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;
    var yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;
    var xDist = otherParticle.x - particle.x;
    var yDist = otherParticle.y - particle.y;
    debugger;
    // Prevent accidental overlap of particles
    if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
        // Grab angle between the two colliding particles
        var angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);
        // Store mass in var for better readability in collision equation
        // assumes radius always equal mass
        var m1 = particle.radius;
        var m2 = otherParticle.radius;
        // Velocity before equation
        var u1 = rotate(particle.velocity, angle);
        var u2 = rotate(otherParticle.velocity, angle);
        // Velocity after 1d collision equation
        var v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
        var v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };
        // Final velocity after rotating axis back to original location
        var vFinal1 = rotate(v1, -angle);
        var vFinal2 = rotate(v2, -angle);
        // Swap particle velocities for realistic bounce effect
        particle.velocity.x = vFinal1.x;
        particle.velocity.y = vFinal1.y;
        otherParticle.velocity.x = vFinal2.x;
        otherParticle.velocity.y = vFinal2.y;
    }
}
function addScore(basePoints, projectile) {
    var multiplier = 1 + combo / 10;
    var points = (basePoints * multiplier) | 0; // bitwise or 0 casts to int
    score += points;
    scoreEl.innerHTML = score.toString();
    createScoreLabel(projectile, points);
}
function createScoreLabel(projectile, score) {
    var scoreLabel = document.createElement('label');
    scoreLabel.innerHTML = score.toString();
    scoreLabel.style.position = 'absolute';
    scoreLabel.style.color = 'white';
    scoreLabel.style.userSelect = 'none';
    scoreLabel.style.left = projectile.x + 'px';
    scoreLabel.style.top = projectile.y + 'px';
    document.body.appendChild(scoreLabel);
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(scoreLabel, {
        opacity: 0,
        y: -30,
        duration: 1,
        onComplete: function () {
            scoreLabel.parentNode.removeChild(scoreLabel);
        }
    });
}
function spawnEnemy(level) {
    enemies.push(new _models_enemies__WEBPACK_IMPORTED_MODULE_2__["Enemy"](canvas.width, canvas.height, level));
}
function spawnBoss() {
    scene.boss = true;
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(backgroundMusic, {
        volume: 0.0,
        duration: 6,
        onComplete: function () {
            backgroundMusic.src = albatrossSongURL;
            backgroundMusic.currentTime = 0;
            backgroundMusic.pause();
        }
    });
    setTimeout(function () { return alarmAudio.play(); }, 2000);
    setTimeout(function () {
        gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(alarmAudio.play(), {
            volume: 0.0,
            duration: 4,
            onComplete: function () {
                alarmAudio.pause();
                alarmAudio.currentTime = 2;
                alarmAudio.volume = 1.0;
            }
        });
    }, 6000);
    setTimeout(function () { return bossMusic.play(); }, 10000);
    var pushBoss = function () { return enemies.push(new _models_enemies__WEBPACK_IMPORTED_MODULE_2__["Boss"](canvas.width, canvas.height)); };
    setTimeout(pushBoss, 11000);
}
function spawnEnemies(level) {
    spawnEnemy(1);
    if (level > 1)
        spawnEnemy(1);
    if (level > 2)
        spawnEnemy(2);
    if (level > 3)
        spawnEnemy(3);
    if (level > 4 && !scene.boss)
        spawnBoss();
}
function setLevel(score) {
    if (score > 5000)
        level = 2;
    if (score > 10000)
        level = 3;
    if (score > 25000)
        level = 4;
    if (score > 50000)
        level = 5;
    if (score > 250000)
        level = 6;
    if (score > 1000000)
        level = 7;
    levelEl.innerHTML = level.toString();
}
function spawnPowerUp() {
    powerUps.push(new _models_powerups__WEBPACK_IMPORTED_MODULE_3__["PowerUp"](canvas));
}
function endGame() {
    cancelAnimationFrame(animationId);
    modalEl.style.display = 'flex';
    bigScoreEl.innerHTML = score.toString();
    endGameAudio.play();
    scene.active = false;
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to('#whiteModalEl', {
        opacity: 1,
        scale: 1,
        duration: 0.35,
    });
    postEvent('game lost', endStats());
}
function winGame() {
    cancelAnimationFrame(animationId);
    modalEl.style.display = 'flex';
    bigScoreEl.innerHTML = score.toString();
    backgroundMusic.src = victoryMusicURL;
    backgroundMusic.load();
    backgroundMusic.play();
    winSound.play();
    victorySong.play();
    scene.active = false;
    victoryEl.style.display = 'block';
    bigScoreEl.innerHTML = score.toString();
    longComboEl.innerHTML = longestCombo.toString();
    // messey way to do time + doesn't handle hour+ time
    var playTime = Date.now() - startTime;
    var timeString = "" + new Date(playTime).toISOString().substr(14, 8);
    runtimeEl.innerHTML = timeString;
    // idea to animate when player wins
    // setInterval(() => {
    //     hitSplash(Math.random() * bottomRight.x, Math.random() * bottomRight.y, 'ivory', 24, Math.random() * Math.PI * 2)
    // }, 250)
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(bossMusic, {
        volume: 0.0,
        duration: 2,
        onComplete: function () {
            bossMusic.pause();
            bossMusic.volume = 1;
        }
    });
    scene.active = false;
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to('#whiteModalEl', {
        opacity: 1,
        scale: 1,
        duration: 0.35,
    });
    postEvent('game won', endStats());
}
function cleanup() {
    // remove faded particles
    particles.forEach(function (p, i) { return p.alpha <= 0 ? particles.splice(i, 1) : p.update(c); });
    // remove projectiles out of bounds
    projectiles.forEach(function (projectile, index) {
        projectile.update(c);
        if (projectile.x + projectile.radius < 0 ||
            projectile.x - projectile.radius > canvas.width ||
            projectile.y + projectile.radius < 0 ||
            projectile.y - projectile.radius > canvas.height) {
            setTimeout(function () { return projectiles.splice(index, 1); }, 0);
        }
    });
}
function hitSplash(x, y, color, amount, angle) {
    // particles should be bias to break away from enemy
    var xBias = Math.cos(angle) * 1.1;
    var yBias = Math.sin(angle) * 1.1;
    for (var i = 0; i < amount; i++) {
        particles.push(new _models_particles__WEBPACK_IMPORTED_MODULE_4__["Particle"](x, y, Math.random() * 2, color, {
            x: (Math.random() - 0.5) + xBias,
            y: (Math.random() - 0.5) + yBias
        }));
    }
}
function continueCombo() {
    var destroySound = destroyEnemy.cloneNode();
    destroySound.volume = 0.75;
    destroySound.play();
    combo += 1;
    longestCombo = longestCombo > combo ? longestCombo : combo;
    comboEl.innerHTML = combo.toString();
}
function breakCombo(enemy) {
    var breakSound = comboBreak.cloneNode();
    breakSound.volume = 0.33;
    breakSound.play();
    player.leash();
    backgroundParticles.forEach(function (p) {
        p.color = enemy.color;
        gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(p, {
            alpha: 0.15,
            duration: 0.03,
            onComplete: function () {
                gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(p, {
                    alpha: p.initialAlpha,
                    touched: false,
                    duration: 0.03
                });
            }
        });
    });
    combo = 0;
    comboEl.innerHTML = combo.toString();
    litCount = 0;
    scene.color = enemy.color;
}
// User input
startGameBtn.addEventListener('click', function (event) {
    init();
    event.stopPropagation();
    scoreEl.innerHTML = score.toString();
    bigScoreEl.innerHTML = score.toString();
    scene.active = true;
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to('#whiteModalEl', {
        opacity: 0,
        scale: 0.75,
        ease: 'expo',
        duration: 0.25,
        onComplete: function () { return modalEl.style.display = 'none'; }
    });
    startGameAudio.play();
    backgroundMusic.play();
    animate();
    postEvent('game started', { "width": bottomRight.x, "height": bottomRight.y });
});
addEventListener('mousedown', function (_a) {
    var clientX = _a.clientX, clientY = _a.clientY;
    mouse.down = true;
    mouse.x = clientX;
    mouse.y = clientY;
});
addEventListener('mousemove', function (_a) {
    var clientX = _a.clientX, clientY = _a.clientY;
    mouse.x = clientX;
    mouse.y = clientY;
});
addEventListener('mouseup', function () {
    mouse.down = false;
});
addEventListener('touchstart', function (event) {
    mouse.down = true;
    mouse.x = event.touches[0].clientX;
    mouse.y = event.touches[0].clientY;
});
addEventListener('touchmove', function (event) {
    mouse.x = event.touches[0].clientX;
    mouse.y = event.touches[0].clientY;
});
addEventListener('touchend', function () {
    mouse.down = false;
});
addEventListener('click', function (event) {
    mouse.x = event.clientX;
    mouse.y = event.clientY;
    if (scene.active)
        projectiles.push(player.shoot(mouse));
});
addEventListener('resize', function () {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    init();
});
addEventListener('keydown', function (_a) {
    var code = _a.code;
    switch (code) {
        case 'KeyW':
        case 'ArrowUp':
            keys.up = true;
            break;
        case 'KeyA':
        case 'ArrowLeft':
            keys.left = true;
            break;
        case 'KeyS':
        case 'ArrowDown':
            keys.down = true;
            break;
        case 'KeyD':
        case 'ArrowRight':
            keys.right = true;
            break;
    }
});
addEventListener('keyup', function (_a) {
    var code = _a.code;
    switch (code) {
        case 'KeyW':
        case 'ArrowUp':
            keys.up = false;
            break;
        case 'KeyA':
        case 'ArrowLeft':
            keys.left = false;
            break;
        case 'KeyS':
        case 'ArrowDown':
            keys.down = false;
            break;
        case 'KeyD':
        case 'ArrowRight':
            keys.right = false;
            break;
    }
});
function endStats() {
    var playTime = Date.now() - startTime;
    var timeString = "" + new Date(playTime).toISOString().substr(14, 8);
    return {
        'score': score,
        'playTime': timeString,
        'longestCombo': longestCombo
    };
}
function postEvent(name, payload) {
    if (enableMixpanel) {
        mixpanel.track(name, payload);
    }
    else {
        console.log('dev tracking: ', name, payload);
    }
}


/***/ }),

/***/ "./src/js/models/enemies.ts":
/*!**********************************!*\
  !*** ./src/js/models/enemies.ts ***!
  \**********************************/
/*! exports provided: Enemy, Boss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Enemy", function() { return Enemy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Boss", function() { return Boss; });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");


var minEnemySize = 15;
var enemyHitAudio = new Audio('./audio/hit.mp3');
var enemyColors = [
    "hsl(0, 70%, 30%)",
    "hsl(90, 70%, 30%)",
    "hsl(220, 70%, 30%)",
    "hsl(36, 90%, 30%)"
];
var randomColor = function () {
    return enemyColors[Math.floor((Math.random() * enemyColors.length))];
};
var oscilatorPadding = 75; // dont spawn oscilators on edges
var id = 1;
var Enemy = /** @class */ (function () {
    function Enemy(width, height, level) {
        var radius = Math.random() * (60 - 10) + 10;
        this.id = id++;
        this.points = 200 + level * 50;
        this.radius = radius + level * 10;
        this.drawRadius = this.radius;
        this.spinRadius = Math.max(30, Math.random() * 100);
        this.spinRate = 0.05;
        this.color = randomColor();
        this.type = 'homing';
        this.center = { x: this.x, y: this.y };
        this.radians = 0;
        this.baseSpeed = 0.75 + (level * 0.15) + (Math.random() * 0.15);
        this.alpha = 1;
        this.friction = 0.95;
        this.inPlay = false;
        this.isBoss = false;
        this.drive = { x: 0, y: 0 };
        if (Math.random() < 0.40) {
            this.type = 'simple';
            if (Math.random() < 0.60 && level > 2) {
                this.type = 'oscilator';
            }
        }
        if (Math.random() < 0.5) {
            this.x = Math.random() < 0.5 ? 0 - radius : width + radius;
            this.y = Math.random() * height;
            if (this.type === 'oscilator') {
                this.drive.x = this.x < 0 ? this.baseSpeed : -this.baseSpeed;
                this.drive.x *= 0.25;
                this.velocity = {
                    x: 0,
                    y: 0
                };
                if (this.y - oscilatorPadding < 0) {
                    this.y += oscilatorPadding + this.radius;
                }
                else if (this.y + oscilatorPadding > height) {
                    this.y -= oscilatorPadding + this.radius;
                }
            }
        }
        else {
            this.x = Math.random() * height;
            this.y = Math.random() < 0.5 ? 0 - radius : height + radius;
            if (this.type === 'oscilator') {
                this.drive.y = this.y < 0 ? this.baseSpeed : -this.baseSpeed;
                this.drive.y *= 0.25;
                this.velocity = {
                    x: 0,
                    y: 0
                };
                if (this.x - oscilatorPadding < 0) {
                    this.x += oscilatorPadding + this.radius;
                }
                else if (this.x + oscilatorPadding > width) {
                    this.x -= oscilatorPadding + this.radius;
                }
            }
        }
        var angle = Math.atan2(height / 2 - this.y, width / 2 - this.x);
        var velocity = {
            x: Math.cos(angle) * this.baseSpeed * 3,
            y: Math.sin(angle) * this.baseSpeed * 3
        };
        if (this.type !== 'oscilator')
            this.velocity = velocity;
    }
    Enemy.prototype.draw = function (c) {
        c.beginPath();
        c.arc(this.x, this.y, this.drawRadius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        if (this.alpha === 1) {
            c.fill();
        }
        else {
            c.save();
            c.globalAlpha = this.alpha;
            c.fill();
            c.restore();
        }
    };
    Enemy.prototype.update = function (c, targetX, targetY) {
        this.draw(c);
        if (this.type === 'simple') {
            this.x += this.velocity.x;
            this.y += this.velocity.y;
        }
        else if (this.type === 'oscilator') {
            this.velocity = {
                x: (this.velocity.x * this.friction) + this.drive.x,
                y: (this.velocity.y * this.friction) + this.drive.y,
            };
            this.x += this.velocity.x;
            this.y += this.velocity.y;
        }
        else if (this.type === 'homing') {
            var angle = Math.atan2(targetY - this.y, targetX - this.x);
            this.velocity = {
                x: (this.velocity.x * this.friction) + (Math.cos(angle) * this.baseSpeed) * 0.2,
                y: (this.velocity.y * this.friction) + (Math.sin(angle) * this.baseSpeed) * 0.2
            };
            this.x += this.velocity.x;
            this.y += this.velocity.y;
        }
        else if (this.type === 'spinning') {
            this.radians += this.spinRate;
            var angle = Math.atan2(targetY - this.y, targetX - this.x);
            this.velocity = {
                x: (this.velocity.x * this.friction) + (Math.cos(angle) * this.baseSpeed) * 0.1,
                y: (this.velocity.y * this.friction) + (Math.sin(angle) * this.baseSpeed) * 0.1
            };
            this.center.x += this.velocity.x;
            this.center.y += this.velocity.y;
            this.x = this.center.x + Math.cos(this.radians) * this.spinRadius;
            this.y = this.center.y + Math.sin(this.radians) * this.spinRadius;
        }
    };
    Enemy.prototype.hit = function (amount) {
        var hitSound = enemyHitAudio.cloneNode();
        hitSound.volume = 0.33;
        hitSound.play();
        this.radius -= amount;
        if (this.radius > minEnemySize) {
            gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(this, {
                drawRadius: this.radius,
                duration: 0.3
            });
            return true;
        }
        else {
            gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(this, {
                alpha: 0.0,
                duration: 0.20
            });
            return false;
        }
    };
    return Enemy;
}());
var Boss = /** @class */ (function () {
    function Boss(width, height) {
        this.radius = 250;
        this.drawRadius = 250;
        this.baseSpeed = 1.2;
        this.points = 10000;
        this.frame = 0;
        this.isBoss = true;
        if (Math.random() < 0.5) {
            this.x = Math.random() < 0.5 ? 0 - this.radius : width + this.radius;
            this.y = Math.random() * height;
        }
        else {
            this.x = Math.random() * height;
            this.y = Math.random() < 0.5 ? 0 - this.radius : height + this.radius;
        }
    }
    Boss.prototype.draw = function (c) {
        c.beginPath();
        c.arc(this.x, this.y, this.drawRadius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        c.fill();
        c.stroke();
    };
    Boss.prototype.update = function (c, targetX, targetY) {
        this.draw(c);
        this.frame++;
        var h = this.frame % 360;
        var s = (this.frame % 20) + 40;
        this.color = "hsl(" + h + "deg," + s + "%,50%)";
        var angle = Math.atan2(targetY - this.y, targetX - this.x);
        this.velocity = {
            x: Math.cos(angle) * this.baseSpeed,
            y: Math.sin(angle) * this.baseSpeed
        };
        this.x += this.velocity.x;
        this.y += this.velocity.y;
    };
    Boss.prototype.hit = function (amount) {
        // boss only take one damage
        var hitSound = enemyHitAudio.cloneNode();
        hitSound.volume = 0.50;
        hitSound.play();
        this.radius -= 1;
        if (this.radius > minEnemySize) {
            gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(this, {
                drawRadius: this.radius
            });
            return true;
        }
        else {
            gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(this, {
                alpha: 0.0,
                duration: 0.20
            });
            return false;
        }
    };
    return Boss;
}());


/***/ }),

/***/ "./src/js/models/particles.ts":
/*!************************************!*\
  !*** ./src/js/models/particles.ts ***!
  \************************************/
/*! exports provided: Projectile, Particle, BackgroundParticle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projectile", function() { return Projectile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackgroundParticle", function() { return BackgroundParticle; });

var Projectile = /** @class */ (function () {
    function Projectile(x, y, radius, color, velocity, power) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.velocity = velocity;
        this.power = power;
    }
    Projectile.prototype.draw = function (c) {
        c.beginPath();
        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        c.fill();
        c.restore();
    };
    Projectile.prototype.update = function (c) {
        this.draw(c);
        this.x += this.velocity.x;
        this.y += this.velocity.y;
    };
    return Projectile;
}());
var Particle = /** @class */ (function () {
    function Particle(x, y, radius, color, velocity) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.velocity = velocity;
        this.alpha = 1;
        this.friction = 0.99;
    }
    Particle.prototype.draw = function (c) {
        c.save();
        c.globalAlpha = this.alpha;
        c.beginPath();
        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        c.fill();
        c.restore();
    };
    Particle.prototype.update = function (c) {
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.alpha -= 0.01;
        this.draw(c);
    };
    return Particle;
}());
var BackgroundParticle = /** @class */ (function () {
    function BackgroundParticle(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.alpha = 0.075;
        this.initialAlpha = this.alpha;
        this.shimmerAlpha = this.alpha + 0.2;
        this.touched = false;
    }
    BackgroundParticle.prototype.draw = function (c) {
        c.save();
        c.globalAlpha = this.alpha;
        c.beginPath();
        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        c.fill();
        c.restore();
    };
    BackgroundParticle.prototype.update = function (c) {
        this.draw(c);
        // shimmer effect
        if (this.touched) {
            if (this.alpha > this.initialAlpha) {
                this.alpha -= Math.random() * 0.05;
            }
            else if (this.alpha < this.initialAlpha) {
                this.alpha += Math.random() * 0.10;
            }
        }
    };
    BackgroundParticle.prototype.touch = function () {
        this.touched = true;
        this.alpha = this.shimmerAlpha;
    };
    return BackgroundParticle;
}());


/***/ }),

/***/ "./src/js/models/player.ts":
/*!*********************************!*\
  !*** ./src/js/models/player.ts ***!
  \*********************************/
/*! exports provided: Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return Player; });
/* harmony import */ var _particles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./particles */ "./src/js/models/particles.ts");

var shootAudio = new Audio('./audio/altShoot.mp3');
var unleashedAudio = new Audio('./audio/unlock.mp3');

var Player = /** @class */ (function () {
    function Player(topLeft, bottomRight, radius, color) {
        this.topLeft = topLeft;
        this.bottomRight = bottomRight;
        this.radius = radius;
        this.color = color;
        this.x = (this.topLeft.x + this.bottomRight.x) / 2;
        this.y = (this.topLeft.y + this.bottomRight.y) / 2;
        this.powerUp = '';
        this.friction = 0.92;
        this.velocity = {
            x: 0,
            y: 0
        };
        this.speed = 0.70;
        this.shotSpeed = 16;
        this.power = 12;
        this.unleashedColor = null;
    }
    Player.prototype.isUnleashed = function () {
        return !!this.unleashedColor;
    };
    Player.prototype.draw = function (c) {
        c.beginPath();
        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        c.fillStyle = this.color;
        c.fill();
    };
    Player.prototype.shoot = function (_a) {
        var x = _a.x, y = _a.y;
        var angle = Math.atan2(y - this.y, x - this.x);
        var velocity = {
            x: Math.cos(angle) * this.shotSpeed,
            y: Math.sin(angle) * this.shotSpeed
        };
        var s = shootAudio.cloneNode();
        s.volume = 0.5;
        s.play();
        return new _particles__WEBPACK_IMPORTED_MODULE_0__["Projectile"](this.x, this.y, 5, this.color, velocity, this.power);
    };
    Player.prototype.update = function (c, keys) {
        this.draw(c);
        if (keys.up)
            this.velocity.y -= this.speed;
        if (keys.down)
            this.velocity.y += this.speed;
        if (keys.right)
            this.velocity.x += this.speed;
        if (keys.left)
            this.velocity.x -= this.speed;
        this.velocity.x *= this.friction;
        this.velocity.y *= this.friction;
        if (this.x - this.radius + this.velocity.x > this.topLeft.x &&
            this.x + this.radius + this.velocity.x < this.bottomRight.x) {
            this.x += this.velocity.x;
        }
        else {
            this.velocity.x = 0;
        }
        if (this.y - this.radius + this.velocity.y > this.topLeft.y &&
            this.y + this.radius + this.velocity.y < this.bottomRight.y) {
            this.y += this.velocity.y;
        }
        else {
            this.velocity.y = 0;
        }
    };
    Player.prototype.unleash = function (unleashedColor) {
        if (!this.unleashedColor) {
            this.speed += 0.33;
            this.shotSpeed += 6;
            unleashedAudio.play();
            this.unleashedColor = unleashedColor;
        }
    };
    Player.prototype.leash = function () {
        if (this.unleashedColor) {
            this.speed -= 0.33;
            this.shotSpeed -= 6;
            this.unleashedColor = null;
        }
    };
    return Player;
}());


/***/ }),

/***/ "./src/js/models/powerups.ts":
/*!***********************************!*\
  !*** ./src/js/models/powerups.ts ***!
  \***********************************/
/*! exports provided: PowerUp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PowerUp", function() { return PowerUp; });

var powerUpImg = new Image();
powerUpImg.src = './img/lightning.png';
var PowerUp = /** @class */ (function () {
    function PowerUp(_a) {
        var width = _a.width, height = _a.height;
        if (Math.random() < 0.5) {
            this.x = Math.random() < 0.5 ? 0 - 7 : width - 7;
            this.y = Math.random() * height;
        }
        else {
            this.x = Math.random() * height;
            this.y = Math.random() < 0.5 ? 0 - 9 : height - 9;
        }
        var angle = Math.atan2(height / 2 - this.y, width / 2 - this.x);
        var velocity = {
            x: Math.cos(angle) + Math.random(),
            y: Math.sin(angle) + Math.random()
        };
        this.velocity = velocity;
        this.width = 14;
        this.height = 19;
        this.inPlay = false;
    }
    PowerUp.prototype.draw = function (c) {
        c.drawImage(powerUpImg, this.x, this.y, 14, 18);
    };
    PowerUp.prototype.update = function (c) {
        this.draw(c);
        this.x += this.velocity.x;
        this.y += this.velocity.y;
    };
    return PowerUp;
}());


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nc2FwL2dzYXAtY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2FudmFzLnRzIiwid2VicGFjazovLy8uL3NyYy9qcy9tb2RlbHMvZW5lbWllcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxzL3BhcnRpY2xlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxzL3BsYXllci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbW9kZWxzL3Bvd2VydXBzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlKQUF5Sjs7QUFFekosZ0RBQWdEO0FBQ2hELENBQUM7QUFDRDtBQUNBO0FBQ0EsdU9BQXVPO0FBQ3ZPLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsa0JBQWtCLFdBQVc7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLEdBQUc7QUFDSDtBQUNBOztBQUVBLDZIQUE2SDs7QUFFN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGVBQWUsdURBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDREQUFNO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdFQUF3RSxxREFBTztBQUMvRSxXQUFXLDREQUFNO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLCtEQUFTO0FBQ3ZCLG1CQUFtQixxREFBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw0REFBTTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxzSUFBc0ksa0VBQVksdURBQXVEO0FBQ3pNO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQSxlQUFlLHVEQUFTLHFDQUFxQyxrRUFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFLHdFQUFrQixJQUFJOzs7QUFHeEI7QUFDQTtBQUNBLDRCQUE0Qiw2REFBZTtBQUMzQyx3QkFBd0IsNkRBQWU7O0FBRXZDO0FBQ0Esb0JBQW9CLDZEQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFlOztBQUUvQjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFPOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEUsR0FBRztBQUNIO0FBQ0E7O0FBRUEsRUFBRSxxREFBTyx5QkFBeUI7O0FBRWxDLGdCQUFnQjs7QUFFaEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7OztBQUduQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1REFBUztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsWUFBWSx5UUFBeVE7QUFDclIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUM1QjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLDJGQUEyRixxREFBTyxNQUFNLG9EQUFNO0FBQzlHLENBQUM7QUFDRDtBQUNBLDhCQUE4QiwrREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtDQUFrQyxxREFBTzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCLGtCQUFrQjs7QUFFbEIsa0JBQWtCOztBQUVsQixrQkFBa0I7O0FBRWxCO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDREQUFNO0FBQ3JCLGVBQWUsNERBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQU07QUFDdkIsaUJBQWlCLDREQUFNO0FBQ3ZCLG1CQUFtQiw0REFBTTtBQUN6QixvQkFBb0IsNERBQU07QUFDMUIsb0JBQW9CLDREQUFNO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGFBQWEsNkRBQU87QUFDcEIsU0FBUyw0REFBTTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTs7O0FBRzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsNERBQU07QUFDaEIsVUFBVSw0REFBTTtBQUNoQixVQUFVLDREQUFNO0FBQ2hCLFVBQVUsNERBQU07QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyw0REFBTTtBQUNmLFNBQVMsNERBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFNO0FBQ2YsU0FBUyw0REFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVEQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCLGNBQWMsRUFBRTs7QUFFekY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQU87QUFDekIsZ0JBQWdCLDZEQUFPO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Ysa0VBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLHNEQUFRLE9BQU8sa0VBQVk7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0VBQWM7QUFDakM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQU87QUFDM0Isa0JBQWtCLDZEQUFPO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBTyxXQUFXLDZEQUFPLCtCQUErQixxREFBTyxXQUFXLDREQUE0RCxRQUFROztBQUU3SixnRkFBZ0Y7QUFDaEYsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLG1DQUFtQyw2QkFBNkI7O0FBRTFLO0FBQ0EsZ0RBQWdELHVEQUFTLDZFQUE2RTs7QUFFdEksdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsMkJBQTJCLHVEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdFQUFnRTs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQyxvQkFBb0IsNkRBQU8sb0JBQW9CLHFEQUFPLFNBQVMscURBQU87QUFDdEU7QUFDQSx5QkFBeUIsdURBQVM7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWSxvRUFBYzs7QUFFMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsK0VBQXlCO0FBQzVDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4UEFBOFAscUdBQXFHLGtFQUFZLHVGQUF1RixnRUFBVTtBQUNoZCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFJOztBQUVKO0FBQ0EsWUFBWSxrRUFBWTtBQUN4QjtBQUNBLEdBQUc7O0FBRUgsRUFBRSxrRUFBWTtBQUNkLElBQUkscURBQU87QUFDWDtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsRUFBRSxrRUFBWTtBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCxrRUFBWTtBQUNaLEVBQUUscURBQU87QUFDVCxDQUFDOztBQUVELGtEQUFJOzs7Ozs7Ozs7Ozs7O0FDLzJDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHVDQUF1Qyx1QkFBdUIsdUZBQXVGLEVBQUUsYUFBYTs7QUFFcEssK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOEpBQThKO0FBQzlKO0FBQ0E7O0FBRUEsUUFBUSw0Q0FBNEM7O0FBRXBEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwySUFBMkk7QUFDM0k7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFOztBQUVoRSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gs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QWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDBCQUEwQjtBQUMxQjs7QUFFQSx3REFBd0Q7QUFDeEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNMQUFzTDtBQUN0TDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5R0FBeUc7QUFDekc7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUUsaUNBQWlDO0FBQ2pDLE9BQU87QUFDUDs7QUFFQSw2QkFBNkI7O0FBRTdCLDhNQUE4TTtBQUM5TTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJGQUEyRjs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBcUQsOE5BQThOLE9BQU8sV0FBVyxLQUFLO0FBQy9UOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0hBQXdIOztBQUV4SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQiw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhIQUE4SDs7QUFFOUg7QUFDQSw0SEFBNEgsWUFBWTtBQUN4STs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJJQUEySTs7QUFFM0ksZ0lBQWdJOztBQUVoSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEdBQTRHOztBQUU1RztBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdURBQXVEOztBQUV2RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLEdBQUc7QUFDSDtBQUNBLDBDQUEwQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxFQUFFOzs7QUFHYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHSztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0lBQXNJOztBQUV2STtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUo7QUFDMkc7Ozs7Ozs7Ozs7Ozs7O0FDcnZIOVA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVB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O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLGlGQUFpRjtBQUNqRixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUEsa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsNkJBQTZCOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsUUFBUTs7QUFFbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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QVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUTs7QUFFaEM7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLE9BQU87QUFDakIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXLEVBQUUsU0FBUyxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLHNCQUFzQixFQUFFO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtDQUFrQztBQUMvRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEI7Ozs7Ozs7Ozs7OztBQ3RxUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVCO0FBQ2lCO0FBQ007QUFDSDtBQUNrQztBQUM3RSxJQUFJLFFBQVEsR0FBRyxtQkFBTyxDQUFDLDhFQUFrQixDQUFDLENBQUM7QUFDM0MsUUFBUSxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0FBRWxELGdCQUFnQjtBQUNoQixJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztBQUMvQyxJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztBQUNsRCxJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztBQUNsRCxJQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBZ0I7QUFDakUsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7QUFDbEQsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUM7QUFDeEQsSUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUM7QUFDNUQsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7QUFDckQsSUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQztBQUM3RCxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQztBQUNuRCxJQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBZ0I7QUFFckUsUUFBUTtBQUNSLElBQU0sZ0JBQWdCLEdBQUcsdUJBQXVCO0FBQ2hELElBQU0sa0JBQWtCLEdBQUcsNkJBQTZCO0FBQ3hELElBQU0sZUFBZSxHQUFHLHVCQUF1QjtBQUMvQyxJQUFJLFdBQVcsR0FBRyxnQkFBZ0I7QUFDbEMsSUFBTSxlQUFlLEdBQUcsSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDO0FBQzlDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsSUFBSTtBQUM3QixlQUFlLENBQUMsV0FBVyxHQUFHLENBQUM7QUFDL0IsSUFBTSxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUM7QUFDbEQsU0FBUyxDQUFDLElBQUksR0FBRyxJQUFJO0FBQ3JCLElBQU0sZUFBZSxHQUFHLDBCQUEwQjtBQUNsRCxJQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUM7QUFDOUMsSUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUM7QUFFbkQsU0FBUyxRQUFRO0lBQ2IsUUFBUSxXQUFXLEVBQUU7UUFDakIsS0FBSyxnQkFBZ0IsQ0FBQztRQUFDO1lBQ25CLGVBQWUsQ0FBQyxHQUFHLEdBQUcsa0JBQWtCO1lBQ3hDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFLO1FBQ1QsS0FBSyxlQUFlO1lBQ2hCLGVBQWUsQ0FBQyxHQUFHLEdBQUcsZ0JBQWdCO1lBQ3RDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFLO1FBQ1QsS0FBSyxrQkFBa0I7WUFDbkIsZUFBZSxDQUFDLEdBQUcsR0FBRyxlQUFlO1lBQ3JDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsSUFBSTtZQUM3QixNQUFLO0tBQ1o7SUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRTtRQUNiLGVBQWUsQ0FBQyxHQUFHLEdBQUcsV0FBVztRQUNqQyxlQUFlLENBQUMsS0FBSyxFQUFFO1FBQ3ZCLGVBQWUsQ0FBQyxJQUFJLEVBQUU7UUFDdEIsZUFBZSxDQUFDLElBQUksRUFBRTtLQUV6QjtBQUNMLENBQUM7QUFFRCxXQUFXO0FBQ1gsSUFBTSxjQUFjLEdBQUcsSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUM7QUFDckQsSUFBTSxZQUFZLEdBQUcsSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUM7QUFDcEQsSUFBTSxVQUFVLEdBQUcsSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUM7QUFDbkQsSUFBTSxZQUFZLEdBQUcsSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUM7QUFDdEQsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQztBQUMzRCxJQUFNLFVBQVUsR0FBRyxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQztBQUVuRCxlQUFlLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQztBQUNuRCxXQUFXLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQztBQUUvQyxJQUFNLEtBQUssR0FBRztJQUNWLE1BQU0sRUFBRSxLQUFLO0lBQ2IsSUFBSSxFQUFFLEtBQUs7SUFDWCxLQUFLLEVBQUUsU0FBUztDQUNuQjtBQUNELElBQU0sSUFBSSxHQUFHO0lBQ1QsRUFBRSxFQUFFLEtBQUs7SUFDVCxJQUFJLEVBQUUsS0FBSztJQUNYLEtBQUssRUFBRSxLQUFLO0lBQ1osSUFBSSxFQUFFLEtBQUs7Q0FDZDtBQUNELElBQU0sS0FBSyxHQUFHO0lBQ1YsSUFBSSxFQUFFLEtBQUs7SUFDWCxDQUFDLEVBQUUsU0FBUztJQUNaLENBQUMsRUFBRSxTQUFTO0NBQ2Y7QUFDRCxJQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztBQUNqQyxNQUFNLENBQUMsS0FBSyxHQUFHLFVBQVU7QUFDekIsTUFBTSxDQUFDLE1BQU0sR0FBRyxXQUFXLEdBQUcsVUFBVSxDQUFDLFlBQVk7QUFDckQsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDNUIsSUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDaEMsSUFBSSxXQUFtQjtBQUN2QixJQUFJLE1BQWM7QUFDbEIsSUFBSSxRQUFtQjtBQUN2QixJQUFJLFNBQXFCO0FBQ3pCLElBQUksT0FBYztBQUNsQixJQUFJLFdBQXlCO0FBQzdCLElBQUksbUJBQXlDO0FBQzdDLElBQUksS0FBYTtBQUNqQixJQUFJLEtBQWE7QUFDakIsSUFBSSxLQUFhO0FBQ2pCLElBQUksS0FBYTtBQUNqQixJQUFJLFFBQWdCO0FBQ3BCLElBQUksYUFBcUI7QUFDekIsSUFBSSxjQUFjLEdBQUcsVUFBVSxDQUFDLGNBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLGtDQUFrQztBQUNoRixJQUFNLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLElBQU0sT0FBTyxHQUFHLEVBQUU7QUFDbEIsSUFBSSxjQUFjLEdBQUcsSUFBSTtBQUV6QixRQUFRO0FBQ1IsSUFBSSxZQUFvQjtBQUN4QixJQUFJLFNBQWM7QUFFbEIsU0FBUyxJQUFJO0lBQ1QsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxXQUFXLEVBQUU7UUFDMUMsY0FBYyxHQUFHLEtBQUs7S0FDekI7SUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDNUIsTUFBTSxDQUFDLEtBQUssR0FBRyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsV0FBVyxHQUFHLFVBQVUsQ0FBQyxZQUFZO0lBQ3JELE9BQU8sR0FBRztRQUNOLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTztRQUNkLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTztLQUNqQjtJQUNELFdBQVcsR0FBRztRQUNWLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxHQUFHLE9BQU87UUFDekIsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLEdBQUcsT0FBTztLQUM3QjtJQUNELEtBQUssR0FBRyxDQUFDO0lBQ1QsS0FBSyxHQUFHLENBQUM7SUFDVCxLQUFLLEdBQUcsQ0FBQztJQUNULEtBQUssR0FBRyxDQUFDO0lBQ1QsWUFBWSxHQUFHLENBQUM7SUFDaEIsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDdEIsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ3BDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU07SUFDaEMsNENBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFO1FBQ2YsTUFBTSxFQUFFLEdBQUc7UUFDWCxRQUFRLEVBQUUsQ0FBQztRQUNYLFVBQVUsRUFBRTtZQUNSLFNBQVMsQ0FBQyxLQUFLLEVBQUU7WUFDakIsU0FBUyxDQUFDLFdBQVcsR0FBRyxDQUFDO1lBQ3pCLFNBQVMsQ0FBQyxNQUFNLEdBQUcsR0FBRztRQUMxQixDQUFDO0tBQ0osQ0FBQztJQUNGLGVBQWUsQ0FBQyxNQUFNLEdBQUcsR0FBRztJQUM1QixlQUFlLENBQUMsSUFBSSxFQUFFO0lBQ3RCLEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSztJQUNsQixPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUU7SUFDcEMsTUFBTSxHQUFHLElBQUkscURBQU0sQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxPQUFPLENBQUM7SUFDdEQsV0FBVyxHQUFHLEVBQUU7SUFDaEIsU0FBUyxHQUFHLEVBQUU7SUFDZCxPQUFPLEdBQUcsRUFBRTtJQUNaLFFBQVEsR0FBRyxFQUFFO0lBQ2IsbUJBQW1CLEdBQUcsRUFBRTtJQUN4QixLQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBRTtRQUNyRCxLQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBRTtZQUNyRCxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxvRUFBa0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNyRTtLQUNKO0lBQ0QsYUFBYSxHQUFHLG1CQUFtQixDQUFDLE1BQU07SUFDMUMsUUFBUSxHQUFHLENBQUM7QUFDaEIsQ0FBQztBQUVELFNBQVMsT0FBTztJQUNaLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQyxPQUFPLENBQUM7SUFDNUMsS0FBSyxFQUFFO0lBQ1AsQ0FBQyxDQUFDLFNBQVMsR0FBRyxvQkFBb0IsRUFBQyw0QkFBNEI7SUFDL0QsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUM3QyxJQUFJLEtBQUssR0FBRyxHQUFHLEtBQUssQ0FBQyxFQUFFO1FBQ25CLFFBQVEsQ0FBQyxLQUFLLENBQUM7UUFDZixZQUFZLENBQUMsS0FBSyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUk7WUFBRSxZQUFZLEVBQUU7S0FDM0M7SUFDRCwwQkFBMEIsRUFBRTtJQUM1QixjQUFjLEVBQUU7SUFDaEIsYUFBYSxFQUFFO0lBQ2YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDO0lBQ3RCLElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxXQUFXLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNqRSxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDeEM7SUFDRCxPQUFPLEVBQUU7QUFDYixDQUFDO0FBRUQsU0FBUyxhQUFhO0lBQ2xCLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUUsS0FBSztRQUN6QixJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUM7WUFBRSxPQUFPLEVBQUU7UUFFdEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBRW5DLHFDQUFxQztRQUNyQyxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUMsVUFBVSxFQUFFLGVBQWU7WUFDNUMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ25FLElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUNuRCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQzlFLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsV0FBVyxDQUFDO2dCQUM3RSxVQUFVLENBQUMsY0FBTSxrQkFBVyxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLEVBQXRDLENBQXNDLEVBQUUsQ0FBQyxDQUFDO2dCQUMzRCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUM3QiwwQkFBMEI7b0JBQzFCLFFBQVEsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDO2lCQUM1QjtxQkFBTTtvQkFDSCxLQUFLLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO29CQUNqRSxJQUFJLEtBQUssQ0FBQyxNQUFNO3dCQUFFLE9BQU8sRUFBRTtvQkFDM0Isd0JBQXdCO29CQUN4QixJQUFNLGNBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUM7b0JBQzNDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxjQUFZLEVBQUUsV0FBVyxDQUFDO29CQUM3RSxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUM7b0JBQ2xDLFVBQVUsQ0FBQzt3QkFDUCxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLFdBQUMsSUFBSSxRQUFDLENBQUMsRUFBRSxLQUFLLEtBQUssQ0FBQyxFQUFFLEVBQWpCLENBQWlCLENBQUM7d0JBQzVELElBQUksVUFBVSxJQUFJLENBQUM7NEJBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO29CQUN0RCxDQUFDLEVBQUUsR0FBRyxDQUFDO2lCQUNWO2FBQ0o7UUFDTCxDQUFDLENBQUM7UUFDRiwyRUFBMkU7UUFDM0UsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDbEIsSUFBTSxNQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JELElBQUksTUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQzFELGdCQUFnQixDQUFDLENBQUMsRUFBRSxLQUFLLENBQUM7YUFDN0I7U0FDSjtRQUNELG1CQUFtQjtRQUNuQixJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUM7UUFDeEksSUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1FBQ3hJLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNkLElBQUksYUFBYSxFQUFFO2dCQUNmLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO29CQUM1QixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDakM7YUFDSjtZQUNELElBQUksYUFBYSxFQUFFO2dCQUNmLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNwQyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO29CQUM1QixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDakM7YUFDSjtTQUNKO2FBQU07WUFDSCxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxhQUFhLElBQUksYUFBYSxDQUFDO1NBQ25EO0lBQ0wsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELFNBQVMsY0FBYztJQUNuQixRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLEtBQUs7UUFDNUIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ25FLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlDLElBQUksV0FBVyxHQUFHLGtCQUFrQixDQUFDLFNBQVMsRUFBc0I7WUFDcEUsV0FBVyxDQUFDLElBQUksRUFBRTtZQUNsQixNQUFNLENBQUMsT0FBTyxHQUFHLFdBQVc7WUFDNUIsTUFBTSxDQUFDLEtBQUssR0FBRyxTQUFTO1lBQ3hCLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUN6QixZQUFZLENBQUMsY0FBYyxDQUFDO1lBQzVCLGNBQWMsR0FBRyxVQUFVLENBQUM7Z0JBQ3hCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsRUFBRTtnQkFDbkIsTUFBTSxDQUFDLEtBQUssR0FBRyxNQUFNO1lBQ3pCLENBQUMsRUFBRSxJQUFJLENBQUM7U0FDWDthQUFNO1lBQ0gsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDcEI7UUFDRCxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQztRQUNsSCxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQztRQUNwSCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2YsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDM0M7WUFDRCxJQUFJLGFBQWEsRUFBRTtnQkFDZixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUMzQztTQUNKO2FBQU07WUFDSCxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxhQUFhLElBQUksYUFBYSxDQUFDO1NBQ3JEO0lBQ0wsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELFNBQVMsMEJBQTBCO0lBQy9CLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxZQUFFO1FBQzFCLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6RCxJQUFNLFVBQVUsR0FBRyxHQUFHO1FBQ3RCLElBQUksSUFBSSxHQUFHLFVBQVUsRUFBRTtZQUNuQiwwQ0FBMEM7WUFDMUMsRUFBRSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7WUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUU7Z0JBQ2IsUUFBUSxJQUFJLENBQUM7Z0JBQ2IsRUFBRSxDQUFDLE9BQU8sR0FBRyxJQUFJO2dCQUNqQixJQUFJLFFBQVEsR0FBRyxhQUFhLEdBQUcsSUFBSSxFQUFFO29CQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUM7b0JBQ3hCLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxZQUFFLElBQUksU0FBRSxDQUFDLEtBQUssRUFBRSxFQUFWLENBQVUsQ0FBQztpQkFDaEQ7YUFDSjtTQUNKO1FBQ0QsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBRUgsU0FBUyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUs7SUFDM0IsSUFBTSxpQkFBaUIsR0FBRztRQUN0QixDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7UUFDOUQsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0tBQ2pFLENBQUM7SUFFRixPQUFPLGlCQUFpQixDQUFDO0FBQzdCLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBRUgsU0FBUyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsYUFBYTtJQUM3QyxJQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNyRSxJQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUVyRSxJQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0MsSUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNDLFFBQVE7SUFDUiwwQ0FBMEM7SUFDMUMsSUFBSSxhQUFhLEdBQUcsS0FBSyxHQUFHLGFBQWEsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFO1FBRXBELGlEQUFpRDtRQUNqRCxJQUFNLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRGLGlFQUFpRTtRQUNqRSxtQ0FBbUM7UUFDbkMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUMzQixJQUFNLEVBQUUsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDO1FBRWhDLDJCQUEyQjtRQUMzQixJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM1QyxJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVqRCx1Q0FBdUM7UUFDdkMsSUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNwRixJQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBRXBGLCtEQUErRDtRQUMvRCxJQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkMsSUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRW5DLHVEQUF1RDtRQUN2RCxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFaEMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNyQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ3hDO0FBQ0wsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFDLFVBQWtCLEVBQUUsVUFBc0I7SUFDeEQsSUFBSSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEtBQUssR0FBRyxFQUFFO0lBQy9CLElBQU0sTUFBTSxHQUFHLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBQyw0QkFBNEI7SUFDekUsS0FBSyxJQUFJLE1BQU07SUFDZixPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUU7SUFDcEMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQztBQUN4QyxDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxVQUFzQixFQUFFLEtBQWE7SUFDM0QsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7SUFDbEQsVUFBVSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ3ZDLFVBQVUsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLFVBQVU7SUFDdEMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsT0FBTztJQUNoQyxVQUFVLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxNQUFNO0lBQ3BDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSTtJQUMzQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLElBQUk7SUFDMUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDO0lBQ3JDLDRDQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRTtRQUNoQixPQUFPLEVBQUUsQ0FBQztRQUNWLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDTixRQUFRLEVBQUUsQ0FBQztRQUNYLFVBQVUsRUFBRTtZQUNSLFVBQVUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQztRQUNqRCxDQUFDO0tBQ0osQ0FBQztBQUNOLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxLQUFhO0lBQzdCLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxxREFBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztBQUMvRCxDQUFDO0FBRUQsU0FBUyxTQUFTO0lBQ2QsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJO0lBQ2pCLDRDQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsRUFBRTtRQUNyQixNQUFNLEVBQUUsR0FBRztRQUNYLFFBQVEsRUFBRSxDQUFDO1FBQ1gsVUFBVSxFQUFFO1lBQ1IsZUFBZSxDQUFDLEdBQUcsR0FBRyxnQkFBZ0I7WUFDdEMsZUFBZSxDQUFDLFdBQVcsR0FBRyxDQUFDO1lBQy9CLGVBQWUsQ0FBQyxLQUFLLEVBQUU7UUFDM0IsQ0FBQztLQUNKLENBQUM7SUFDRixVQUFVLENBQUMsY0FBTSxpQkFBVSxDQUFDLElBQUksRUFBRSxFQUFqQixDQUFpQixFQUFFLElBQUksQ0FBQztJQUN6QyxVQUFVLENBQUM7UUFDUCw0Q0FBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDdkIsTUFBTSxFQUFFLEdBQUc7WUFDWCxRQUFRLEVBQUUsQ0FBQztZQUNYLFVBQVUsRUFBRTtnQkFDUixVQUFVLENBQUMsS0FBSyxFQUFFO2dCQUNsQixVQUFVLENBQUMsV0FBVyxHQUFHLENBQUM7Z0JBQzFCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsR0FBRztZQUMzQixDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDUixVQUFVLENBQUMsY0FBTSxnQkFBUyxDQUFDLElBQUksRUFBRSxFQUFoQixDQUFnQixFQUFFLEtBQUssQ0FBQztJQUN6QyxJQUFJLFFBQVEsR0FBRyxjQUFNLGNBQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxvREFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQW5ELENBQW1EO0lBQ3hFLFVBQVUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDO0FBQy9CLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxLQUFhO0lBQy9CLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDYixJQUFJLEtBQUssR0FBRyxDQUFDO1FBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM1QixJQUFJLEtBQUssR0FBRyxDQUFDO1FBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM1QixJQUFJLEtBQUssR0FBRyxDQUFDO1FBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM1QixJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTtRQUFFLFNBQVMsRUFBRTtBQUM3QyxDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsS0FBYTtJQUMzQixJQUFJLEtBQUssR0FBRyxJQUFJO1FBQUUsS0FBSyxHQUFHLENBQUM7SUFDM0IsSUFBSSxLQUFLLEdBQUcsS0FBSztRQUFFLEtBQUssR0FBRyxDQUFDO0lBQzVCLElBQUksS0FBSyxHQUFHLEtBQUs7UUFBRSxLQUFLLEdBQUcsQ0FBQztJQUM1QixJQUFJLEtBQUssR0FBRyxLQUFLO1FBQUUsS0FBSyxHQUFHLENBQUM7SUFDNUIsSUFBSSxLQUFLLEdBQUcsTUFBTTtRQUFFLEtBQUssR0FBRyxDQUFDO0lBQzdCLElBQUksS0FBSyxHQUFHLE9BQU87UUFBRSxLQUFLLEdBQUcsQ0FBQztJQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDeEMsQ0FBQztBQUVELFNBQVMsWUFBWTtJQUNqQixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksd0RBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QyxDQUFDO0FBRUQsU0FBUyxPQUFPO0lBQ1osb0JBQW9CLENBQUMsV0FBVyxDQUFDO0lBQ2pDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU07SUFDOUIsVUFBVSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ3ZDLFlBQVksQ0FBQyxJQUFJLEVBQUU7SUFDbkIsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLO0lBQ3BCLDRDQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsRUFBRTtRQUNyQixPQUFPLEVBQUUsQ0FBQztRQUNWLEtBQUssRUFBRSxDQUFDO1FBQ1IsUUFBUSxFQUFFLElBQUk7S0FDakIsQ0FBQztJQUNGLFNBQVMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLENBQUM7QUFDdEMsQ0FBQztBQUVELFNBQVMsT0FBTztJQUNaLG9CQUFvQixDQUFDLFdBQVcsQ0FBQztJQUNqQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNO0lBQzlCLFVBQVUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRTtJQUN2QyxlQUFlLENBQUMsR0FBRyxHQUFHLGVBQWU7SUFDckMsZUFBZSxDQUFDLElBQUksRUFBRTtJQUN0QixlQUFlLENBQUMsSUFBSSxFQUFFO0lBQ3RCLFFBQVEsQ0FBQyxJQUFJLEVBQUU7SUFDZixXQUFXLENBQUMsSUFBSSxFQUFFO0lBQ2xCLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSztJQUNwQixTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ2pDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRTtJQUN2QyxXQUFXLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUU7SUFDL0Msb0RBQW9EO0lBQ3BELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTO0lBQ3JDLElBQU0sVUFBVSxHQUFHLEtBQUcsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUc7SUFDdEUsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVO0lBRWhDLG1DQUFtQztJQUNuQyxzQkFBc0I7SUFDdEIsd0hBQXdIO0lBQ3hILFVBQVU7SUFFViw0Q0FBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUU7UUFDZixNQUFNLEVBQUUsR0FBRztRQUNYLFFBQVEsRUFBRSxDQUFDO1FBQ1gsVUFBVSxFQUFFO1lBQ1IsU0FBUyxDQUFDLEtBQUssRUFBRTtZQUNqQixTQUFTLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDeEIsQ0FBQztLQUNKLENBQUM7SUFDRixLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUs7SUFDcEIsNENBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFO1FBQ3JCLE9BQU8sRUFBRSxDQUFDO1FBQ1YsS0FBSyxFQUFFLENBQUM7UUFDUixRQUFRLEVBQUUsSUFBSTtLQUNqQixDQUFDO0lBQ0YsU0FBUyxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsQ0FBQztBQUNyQyxDQUFDO0FBR0QsU0FBUyxPQUFPO0lBQ1oseUJBQXlCO0lBQ3pCLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLFFBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBbkQsQ0FBbUQsQ0FBQztJQUNoRixtQ0FBbUM7SUFDbkMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFDLFVBQVUsRUFBRSxLQUFLO1FBQ2xDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQ0ksVUFBVSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUM7WUFDcEMsVUFBVSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLO1lBQy9DLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDO1lBQ3BDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxFQUNsRDtZQUNFLFVBQVUsQ0FBQyxjQUFNLGtCQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBNUIsQ0FBNEIsRUFBRSxDQUFDLENBQUM7U0FDcEQ7SUFDTCxDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUFFLEtBQWE7SUFDakYsb0RBQW9EO0lBQ3BELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRztJQUNuQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUc7SUFDbkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUM3QixTQUFTLENBQUMsSUFBSSxDQUNWLElBQUksMERBQVEsQ0FDUixDQUFDLEVBQ0QsQ0FBQyxFQUNELElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQ2pCLEtBQUssRUFDTDtZQUNJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLO1lBQ2hDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLO1NBQ25DLENBQ0osQ0FDSjtLQUNKO0FBQ0wsQ0FBQztBQUVELFNBQVMsYUFBYTtJQUNsQixJQUFJLFlBQVksR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFzQjtJQUMvRCxZQUFZLENBQUMsTUFBTSxHQUFHLElBQUk7SUFDMUIsWUFBWSxDQUFDLElBQUksRUFBRTtJQUNuQixLQUFLLElBQUksQ0FBQztJQUNWLFlBQVksR0FBRyxZQUFZLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUs7SUFDMUQsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ3hDLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxLQUFZO0lBQzVCLElBQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxTQUFTLEVBQXNCO0lBQzdELFVBQVUsQ0FBQyxNQUFNLEdBQUcsSUFBSTtJQUN4QixVQUFVLENBQUMsSUFBSSxFQUFFO0lBQ2pCLE1BQU0sQ0FBQyxLQUFLLEVBQUU7SUFDZCxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsV0FBQztRQUN6QixDQUFDLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLO1FBQ3JCLDRDQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtZQUNQLEtBQUssRUFBRSxJQUFJO1lBQ1gsUUFBUSxFQUFFLElBQUk7WUFDZCxVQUFVLEVBQUU7Z0JBQ1IsNENBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO29CQUNQLEtBQUssRUFBRSxDQUFDLENBQUMsWUFBWTtvQkFDckIsT0FBTyxFQUFFLEtBQUs7b0JBQ2QsUUFBUSxFQUFFLElBQUk7aUJBQ2pCLENBQUM7WUFDTixDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUMsQ0FBQztJQUNGLEtBQUssR0FBRyxDQUFDO0lBQ1QsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ3BDLFFBQVEsR0FBRyxDQUFDO0lBQ1osS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSztBQUM3QixDQUFDO0FBRUQsYUFBYTtBQUNiLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxLQUFLO0lBQ3pDLElBQUksRUFBRTtJQUNOLEtBQUssQ0FBQyxlQUFlLEVBQUU7SUFDdkIsT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFO0lBQ3BDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRTtJQUN2QyxLQUFLLENBQUMsTUFBTSxHQUFHLElBQUk7SUFDbkIsNENBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFO1FBQ3JCLE9BQU8sRUFBRSxDQUFDO1FBQ1YsS0FBSyxFQUFFLElBQUk7UUFDWCxJQUFJLEVBQUUsTUFBTTtRQUNaLFFBQVEsRUFBRSxJQUFJO1FBQ2QsVUFBVSxFQUFFLGNBQU0sY0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxFQUE5QixDQUE4QjtLQUNuRCxDQUFDO0lBQ0YsY0FBYyxDQUFDLElBQUksRUFBRTtJQUNyQixlQUFlLENBQUMsSUFBSSxFQUFFO0lBQ3RCLE9BQU8sRUFBRTtJQUNULFNBQVMsQ0FBQyxjQUFjLEVBQUUsRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ2xGLENBQUMsQ0FBQztBQUVGLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxVQUFDLEVBQW9CO1FBQWxCLE9BQU8sZUFBRSxPQUFPO0lBQzdDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSTtJQUNqQixLQUFLLENBQUMsQ0FBQyxHQUFHLE9BQU87SUFDakIsS0FBSyxDQUFDLENBQUMsR0FBRyxPQUFPO0FBQ3JCLENBQUMsQ0FBQztBQUVGLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxVQUFDLEVBQW9CO1FBQWxCLE9BQU8sZUFBRSxPQUFPO0lBQzdDLEtBQUssQ0FBQyxDQUFDLEdBQUcsT0FBTztJQUNqQixLQUFLLENBQUMsQ0FBQyxHQUFHLE9BQU87QUFDckIsQ0FBQyxDQUFDO0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxFQUFFO0lBQ3hCLEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSztBQUN0QixDQUFDLENBQUM7QUFFRixnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsVUFBQyxLQUFLO0lBQ2pDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSTtJQUNqQixLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztJQUNsQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztBQUN0QyxDQUFDLENBQUM7QUFFRixnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsVUFBQyxLQUFLO0lBQ2hDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPO0lBQ2xDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPO0FBQ3RDLENBQUMsQ0FBQztBQUVGLGdCQUFnQixDQUFDLFVBQVUsRUFBRTtJQUN6QixLQUFLLENBQUMsSUFBSSxHQUFHLEtBQUs7QUFDdEIsQ0FBQyxDQUFDO0FBRUYsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFVBQUMsS0FBSztJQUM1QixLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPO0lBQ3ZCLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU87SUFDdkIsSUFBSSxLQUFLLENBQUMsTUFBTTtRQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzRCxDQUFDLENBQUM7QUFFRixnQkFBZ0IsQ0FBQyxRQUFRLEVBQUU7SUFDdkIsTUFBTSxDQUFDLEtBQUssR0FBRyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsV0FBVztJQUMzQixJQUFJLEVBQUU7QUFDVixDQUFDLENBQUM7QUFFRixnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBQyxFQUFRO1FBQU4sSUFBSTtJQUMvQixRQUFRLElBQUksRUFBRTtRQUNWLEtBQUssTUFBTSxDQUFDO1FBQUMsS0FBSyxTQUFTO1lBQ3ZCLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSTtZQUNkLE1BQUs7UUFDVCxLQUFLLE1BQU0sQ0FBQztRQUFDLEtBQUssV0FBVztZQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7WUFDaEIsTUFBSztRQUNULEtBQUssTUFBTSxDQUFDO1FBQUMsS0FBSyxXQUFXO1lBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSTtZQUNoQixNQUFLO1FBQ1QsS0FBSyxNQUFNLENBQUM7UUFBQyxLQUFLLFlBQVk7WUFDMUIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJO1lBQ2pCLE1BQUs7S0FDWjtBQUNMLENBQUMsQ0FBQztBQUVGLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxVQUFDLEVBQVE7UUFBTixJQUFJO0lBQzdCLFFBQVEsSUFBSSxFQUFFO1FBQ1YsS0FBSyxNQUFNLENBQUM7UUFBQyxLQUFLLFNBQVM7WUFDdkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLO1lBQ2YsTUFBSztRQUNULEtBQUssTUFBTSxDQUFDO1FBQUMsS0FBSyxXQUFXO1lBQ3pCLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSztZQUNqQixNQUFLO1FBQ1QsS0FBSyxNQUFNLENBQUM7UUFBQyxLQUFLLFdBQVc7WUFDekIsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLO1lBQ2pCLE1BQUs7UUFDVCxLQUFLLE1BQU0sQ0FBQztRQUFDLEtBQUssWUFBWTtZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUs7WUFDbEIsTUFBSztLQUNaO0FBQ0wsQ0FBQyxDQUFDO0FBRUYsU0FBUyxRQUFRO0lBQ2IsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVM7SUFDckMsSUFBTSxVQUFVLEdBQUcsS0FBRyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBRztJQUN0RSxPQUFPO1FBQ0gsT0FBTyxFQUFFLEtBQUs7UUFDZCxVQUFVLEVBQUUsVUFBVTtRQUN0QixjQUFjLEVBQUUsWUFBWTtLQUMvQjtBQUNMLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxJQUFZLEVBQUUsT0FBZTtJQUM1QyxJQUFJLGNBQWMsRUFBRTtRQUNoQixRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUM7S0FDaEM7U0FBTTtRQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQztLQUMvQztBQUNMLENBQUM7Ozs7Ozs7Ozs7Ozs7QUM1cUJEO0FBQUE7QUFBQTtBQUFBO0FBQXVCO0FBSXRCO0FBRUQsSUFBTSxZQUFZLEdBQUcsRUFBRTtBQUN2QixJQUFNLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztBQUNsRCxJQUFNLFdBQVcsR0FBRztJQUNoQixrQkFBa0I7SUFDbEIsbUJBQW1CO0lBQ25CLG9CQUFvQjtJQUNwQixtQkFBbUI7Q0FDdEI7QUFFRCxJQUFNLFdBQVcsR0FBRztJQUNoQixPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3hFLENBQUM7QUFDRCxJQUFNLGdCQUFnQixHQUFHLEVBQUUsRUFBQyxpQ0FBaUM7QUFDN0QsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUNWO0lBb0JJLGVBQVksS0FBYSxFQUFFLE1BQWMsRUFBRSxLQUFhO1FBQ3BELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFO1FBRTdDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ2QsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEVBQUU7UUFDOUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSyxHQUFHLEVBQUU7UUFDakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTTtRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDbkQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxFQUFFO1FBQzFCLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUTtRQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFDdEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQztRQUMvRCxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUk7UUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLO1FBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQzNCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLFFBQVE7WUFDcEIsSUFBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVzthQUMxQjtTQUNKO1FBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLE1BQU07WUFDMUQsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTTtZQUMvQixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO2dCQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUztnQkFDNUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSTtnQkFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRztvQkFDWixDQUFDLEVBQUUsQ0FBQztvQkFDSixDQUFDLEVBQUUsQ0FBQztpQkFDUDtnQkFDRCxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFO29CQUMvQixJQUFJLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNO2lCQUMzQztxQkFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsTUFBTSxFQUFFO29CQUMzQyxJQUFJLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNO2lCQUMzQzthQUNKO1NBQ0o7YUFBTTtZQUNILElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU07WUFDL0IsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsTUFBTTtZQUMzRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO2dCQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUztnQkFDNUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSTtnQkFDcEIsSUFBSSxDQUFDLFFBQVEsR0FBRztvQkFDWixDQUFDLEVBQUUsQ0FBQztvQkFDSixDQUFDLEVBQUUsQ0FBQztpQkFDUDtnQkFDRCxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFO29CQUMvQixJQUFJLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNO2lCQUMzQztxQkFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsS0FBSyxFQUFFO29CQUMxQyxJQUFJLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNO2lCQUMzQzthQUNKO1NBQ0o7UUFDRCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDakUsSUFBTSxRQUFRLEdBQUc7WUFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFDLENBQUM7WUFDckMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBQyxDQUFDO1NBQ3hDO1FBQ0QsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFdBQVc7WUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVE7SUFDM0QsQ0FBQztJQUVELG9CQUFJLEdBQUosVUFBSyxDQUEyQjtRQUM1QixDQUFDLENBQUMsU0FBUyxFQUFFO1FBQ2IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDO1FBQzdELENBQUMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUs7UUFDeEIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtZQUNsQixDQUFDLENBQUMsSUFBSSxFQUFFO1NBQ1g7YUFBTTtZQUNILENBQUMsQ0FBQyxJQUFJLEVBQUU7WUFDUixDQUFDLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLO1lBQzFCLENBQUMsQ0FBQyxJQUFJLEVBQUU7WUFDUixDQUFDLENBQUMsT0FBTyxFQUFFO1NBQ2Q7SUFDTCxDQUFDO0lBRUQsc0JBQU0sR0FBTixVQUFPLENBQTJCLEVBQUUsT0FBZSxFQUFFLE9BQWU7UUFDaEUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDWixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzVCO2FBQ0ksSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRTtZQUNoQyxJQUFJLENBQUMsUUFBUSxHQUFHO2dCQUNaLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25ELENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDdEQ7WUFDRCxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6QixJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QjthQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDL0IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM1RCxJQUFJLENBQUMsUUFBUSxHQUFHO2dCQUNaLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUc7Z0JBQy9FLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUc7YUFDbEY7WUFDRCxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6QixJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QjthQUFNLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLEVBQUU7WUFDakMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUTtZQUM3QixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzVELElBQUksQ0FBQyxRQUFRLEdBQUc7Z0JBQ1osQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRztnQkFDL0UsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRzthQUNsRjtZQUNELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFaEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVTtZQUNqRSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVO1NBQ3BFO0lBQ0wsQ0FBQztJQUVELG1CQUFHLEdBQUgsVUFBSSxNQUFjO1FBQ2QsSUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLFNBQVMsRUFBc0I7UUFDOUQsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJO1FBQ3RCLFFBQVEsQ0FBQyxJQUFJLEVBQUU7UUFDZixJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU07UUFDckIsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksRUFBRTtZQUM1Qiw0Q0FBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUU7Z0JBQ1YsVUFBVSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUN2QixRQUFRLEVBQUUsR0FBRzthQUNoQixDQUFDO1lBQ0YsT0FBTyxJQUFJO1NBQ2Q7YUFBTTtZQUNILDRDQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRTtnQkFDVixLQUFLLEVBQUUsR0FBRztnQkFDVixRQUFRLEVBQUUsSUFBSTthQUNqQixDQUFDO1lBQ0YsT0FBTyxLQUFLO1NBQ2Y7SUFDTCxDQUFDO0lBQ0wsWUFBQztBQUFELENBQUM7QUFFRDtJQVdJLGNBQVksS0FBYSxFQUFFLE1BQWM7UUFDckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHO1FBQ2pCLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLEdBQUc7UUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSTtRQUNsQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUU7WUFDckIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNO1lBQ3BFLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU07U0FDbEM7YUFBTTtZQUNILElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU07WUFDL0IsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNO1NBQ3hFO0lBQ0wsQ0FBQztJQUVELG1CQUFJLEdBQUosVUFBSyxDQUEyQjtRQUM1QixDQUFDLENBQUMsU0FBUyxFQUFFO1FBQ2IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDO1FBQzdELENBQUMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUs7UUFDeEIsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUNSLENBQUMsQ0FBQyxNQUFNLEVBQUU7SUFDZCxDQUFDO0lBRUQscUJBQU0sR0FBTixVQUFPLENBQTJCLEVBQUUsT0FBZSxFQUFFLE9BQWU7UUFDaEUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFO1FBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBTyxDQUFDLFlBQU8sQ0FBQyxXQUFRO1FBQ3JDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLFFBQVEsR0FBRztZQUNaLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTO1lBQ25DLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTO1NBQ3RDO1FBQ0QsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELGtCQUFHLEdBQUgsVUFBSSxNQUFjO1FBQ2QsNEJBQTRCO1FBQzVCLElBQU0sUUFBUSxHQUFHLGFBQWEsQ0FBQyxTQUFTLEVBQXNCO1FBQzlELFFBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSTtRQUN0QixRQUFRLENBQUMsSUFBSSxFQUFFO1FBQ2YsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDO1FBQ2hCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxZQUFZLEVBQUU7WUFDNUIsNENBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFO2dCQUNWLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTTthQUMxQixDQUFDO1lBQ0YsT0FBTyxJQUFJO1NBQ2Q7YUFBTTtZQUNILDRDQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRTtnQkFDVixLQUFLLEVBQUUsR0FBRztnQkFDVixRQUFRLEVBQUUsSUFBSTthQUNqQixDQUFDO1lBQ0YsT0FBTyxLQUFLO1NBQ2Y7SUFDTCxDQUFDO0lBQ0wsV0FBQztBQUFELENBQUM7Ozs7Ozs7Ozs7Ozs7QUN0UEQ7QUFBQTtBQUFBO0FBQUE7QUFBbUQ7QUFFbkQ7SUFPSSxvQkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLE1BQWMsRUFBRSxLQUFhLEVBQUUsUUFBa0IsRUFBRSxLQUFhO1FBQzlGLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNWLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNWLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTTtRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUs7UUFDbEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRO1FBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSztJQUN0QixDQUFDO0lBRUQseUJBQUksR0FBSixVQUFLLENBQTJCO1FBQzVCLENBQUMsQ0FBQyxTQUFTLEVBQUU7UUFDYixDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUM7UUFDekQsQ0FBQyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSztRQUN4QixDQUFDLENBQUMsSUFBSSxFQUFFO1FBQ1IsQ0FBQyxDQUFDLE9BQU8sRUFBRTtJQUNmLENBQUM7SUFFRCwyQkFBTSxHQUFOLFVBQU8sQ0FBMkI7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0wsaUJBQUM7QUFBRCxDQUFDO0FBRUQ7SUFRSSxrQkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLE1BQWMsRUFBRSxLQUFhLEVBQUUsUUFBa0I7UUFDL0UsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ1YsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ1YsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVE7UUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJO0lBQ3hCLENBQUM7SUFFRCx1QkFBSSxHQUFKLFVBQUssQ0FBMkI7UUFDNUIsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUNSLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUs7UUFDMUIsQ0FBQyxDQUFDLFNBQVMsRUFBRTtRQUNiLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQztRQUN6RCxDQUFDLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLO1FBQ3hCLENBQUMsQ0FBQyxJQUFJLEVBQUU7UUFDUixDQUFDLENBQUMsT0FBTyxFQUFFO0lBQ2YsQ0FBQztJQUVELHlCQUFNLEdBQU4sVUFBTyxDQUEyQjtRQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUTtRQUNoQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUTtRQUNoQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsS0FBSyxJQUFJLElBQUk7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUNMLGVBQUM7QUFBRCxDQUFDO0FBRUQ7SUFTSSw0QkFBWSxDQUFTLEVBQUUsQ0FBUyxFQUFFLE1BQWMsRUFBRSxLQUFhO1FBQzNELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNWLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNWLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTTtRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUs7UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUs7UUFDOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUc7UUFDcEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLO0lBQ3hCLENBQUM7SUFFRCxpQ0FBSSxHQUFKLFVBQUssQ0FBMkI7UUFDNUIsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUNSLENBQUMsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUs7UUFDMUIsQ0FBQyxDQUFDLFNBQVMsRUFBRTtRQUNiLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQztRQUN6RCxDQUFDLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLO1FBQ3hCLENBQUMsQ0FBQyxJQUFJLEVBQUU7UUFDUixDQUFDLENBQUMsT0FBTyxFQUFFO0lBQ2YsQ0FBQztJQUVELG1DQUFNLEdBQU4sVUFBTyxDQUEyQjtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNaLGlCQUFpQjtRQUNqQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDZCxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDaEMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUMsSUFBSTthQUNuQztpQkFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDdkMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUMsSUFBSTthQUNuQztTQUNKO0lBQ0wsQ0FBQztJQUVELGtDQUFLLEdBQUw7UUFDSSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUk7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWTtJQUNsQyxDQUFDO0lBQ0wseUJBQUM7QUFBRCxDQUFDOzs7Ozs7Ozs7Ozs7O0FDckhEO0FBQUE7QUFBQTtBQUF3QztBQUN4QyxJQUFNLFVBQVUsR0FBRyxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQztBQUNwRCxJQUFNLGNBQWMsR0FBRyxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQztBQUNyQztBQUVqQjtJQVdJLGdCQUFvQixPQUFZLEVBQVUsV0FBZ0IsRUFBUyxNQUFjLEVBQVMsS0FBYTtRQUFuRixZQUFPLEdBQVAsT0FBTyxDQUFLO1FBQVUsZ0JBQVcsR0FBWCxXQUFXLENBQUs7UUFBUyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQVMsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUNuRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2xELElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDbEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSTtRQUNwQixJQUFJLENBQUMsUUFBUSxHQUFHO1lBQ1osQ0FBQyxFQUFFLENBQUM7WUFDSixDQUFDLEVBQUUsQ0FBQztTQUNQO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUk7SUFDOUIsQ0FBQztJQUVELDRCQUFXLEdBQVg7UUFDSSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYztJQUNoQyxDQUFDO0lBRUQscUJBQUksR0FBSixVQUFLLENBQTJCO1FBQzVCLENBQUMsQ0FBQyxTQUFTLEVBQUU7UUFDYixDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUM7UUFDekQsQ0FBQyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSztRQUN4QixDQUFDLENBQUMsSUFBSSxFQUFFO0lBQ1osQ0FBQztJQUVELHNCQUFLLEdBQUwsVUFBTSxFQUFRO1lBQU4sQ0FBQyxTQUFFLENBQUM7UUFDUixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2hELElBQU0sUUFBUSxHQUFHO1lBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVM7WUFDbkMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVM7U0FDdEM7UUFDRCxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsU0FBUyxFQUFzQjtRQUNsRCxDQUFDLENBQUMsTUFBTSxHQUFHLEdBQUc7UUFDZCxDQUFDLENBQUMsSUFBSSxFQUFFO1FBQ1IsT0FBTyxJQUFJLHFEQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQzlFLENBQUM7SUFFRCx1QkFBTSxHQUFOLFVBQU8sQ0FBMkIsRUFBRSxJQUFVO1FBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ1osSUFBSSxJQUFJLENBQUMsRUFBRTtZQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLO1FBQzFDLElBQUksSUFBSSxDQUFDLElBQUk7WUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSztRQUM1QyxJQUFJLElBQUksQ0FBQyxLQUFLO1lBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUs7UUFDN0MsSUFBSSxJQUFJLENBQUMsSUFBSTtZQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLO1FBQzVDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRO1FBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRO1FBQ2hDLElBQ0ksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2RCxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQzdEO1lBQ0UsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDNUI7YUFBTTtZQUNILElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUM7U0FDdEI7UUFFRCxJQUNJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUM3RDtZQUNFLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzVCO2FBQU07WUFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDO1NBQ3RCO0lBQ0wsQ0FBQztJQUVELHdCQUFPLEdBQVAsVUFBUSxjQUFzQjtRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN0QixJQUFJLENBQUMsS0FBSyxJQUFJLElBQUk7WUFDbEIsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDO1lBQ25CLGNBQWMsQ0FBQyxJQUFJLEVBQUU7WUFDckIsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjO1NBQ3ZDO0lBQ0wsQ0FBQztJQUVELHNCQUFLLEdBQUw7UUFDSSxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJO1lBQ2xCLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQztZQUNuQixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUk7U0FDN0I7SUFDTCxDQUFDO0lBQ0wsYUFBQztBQUFELENBQUM7Ozs7Ozs7Ozs7Ozs7QUNqR0Q7QUFBQTtBQUFrQjtBQUVsQixJQUFNLFVBQVUsR0FBRyxJQUFJLEtBQUssRUFBRTtBQUM5QixVQUFVLENBQUMsR0FBRyxHQUFHLHFCQUFxQjtBQUV0QztJQU9JLGlCQUFZLEVBQWlCO1lBQWYsS0FBSyxhQUFFLE1BQU07UUFDdkIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUM7WUFDaEQsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTTtTQUNsQzthQUFNO1lBQ0gsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTTtZQUMvQixJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDO1NBQ3BEO1FBQ0QsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLElBQU0sUUFBUSxHQUFHO1lBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNsQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFO1NBQ3JDO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRO1FBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUs7SUFDdkIsQ0FBQztJQUVELHNCQUFJLEdBQUosVUFBSyxDQUEyQjtRQUM1QixDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRUQsd0JBQU0sR0FBTixVQUFPLENBQTJCO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUNMLGNBQUM7QUFBRCxDQUFDIiwiZmlsZSI6Ii4vanMvY2FudmFzLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2pzL2NhbnZhcy50c1wiKTtcbiIsIi8qIVxuICogQ1NTUGx1Z2luIDMuNi4wXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ3NhcCwgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIGdldFVuaXQsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9jaGVja1BsdWdpbiwgX3JlcGxhY2VSYW5kb20sIF9wbHVnaW5zLCBHU0NhY2hlLCBQcm9wVHdlZW4sIF9jb25maWcsIF90aWNrZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXG59IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuXG52YXIgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9wbHVnaW5Jbml0dGVkLFxuICAgIF90ZW1wRGl2LFxuICAgIF90ZW1wRGl2U3R5bGVyLFxuICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKD86bGVmdHxyaWdodHx3aWR0aHxtYXJnaW58cGFkZGluZ3x4KS9pLFxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgYXV0b0FscGhhOiBcIm9wYWNpdHksdmlzaWJpbGl0eVwiLFxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gIGFscGhhOiBcIm9wYWNpdHlcIlxufSxcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcbl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xufSxcbiAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xuICAgICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHIoMCwgMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgb25seVNldEF0RW5kID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSk7XG4gIHBsdWdpbi5fcHQgPSBwdDtcbiAgcHQuYiA9IGJlZ2lubmluZztcbiAgcHQuZSA9IGVuZDtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxLFxuICB0dXJuOiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBlbmRWYWx1ZXM7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIHJlbGF0aXZlID0gZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcblxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG5cbiAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgYzogcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gIWNhY2hlLnVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICB9XG5cbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuICAgIGEgPSBtYXRyaXhbMF07IC8vYTExXG5cbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxuXG4gICAgYyA9IG1hdHJpeFsyXTsgLy9hMzFcblxuICAgIGQgPSBtYXRyaXhbM107IC8vYTQxXG5cbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07IC8vMkQgbWF0cml4XG5cbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cbiAgICAgIHNrZXdYID0gYyB8fCBkID8gX2F0YW4yKGMsIGQpICogX1JBRDJERUcgKyByb3RhdGlvbiA6IDA7XG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueiA9IHogKyBweDtcbiAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcbiAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXG4gIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAwKSB7XG4gICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gX2ZpcnN0VHdvT25seShvcmlnaW4pO1xuICB9XG5cbiAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICBjYWNoZS5mb3JjZTNEID0gX2NvbmZpZy5mb3JjZTNEO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gPSBjYWNoZS5zdmcgPyBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA6IF9zdXBwb3J0czNEID8gX3JlbmRlckNTU1RyYW5zZm9ybXMgOiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zO1xuICBjYWNoZS51bmNhY2hlID0gMDtcbiAgcmV0dXJuIGNhY2hlO1xufSxcbiAgICBfZmlyc3RUd29Pbmx5ID0gZnVuY3Rpb24gX2ZpcnN0VHdvT25seSh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlID0gdmFsdWUuc3BsaXQoXCIgXCIpKVswXSArIFwiIFwiICsgdmFsdWVbMV07XG59LFxuICAgIC8vZm9yIGhhbmRsaW5nIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMsIHN0cmlwcGluZyBvdXQgdGhlIDNyZCBkaW1lbnNpb25cbl9hZGRQeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgdW5pdCA9IGdldFVuaXQoc3RhcnQpO1xuICByZXR1cm4gX3JvdW5kKHBhcnNlRmxvYXQoc3RhcnQpICsgcGFyc2VGbG9hdChfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB2YWx1ZSArIFwicHhcIiwgdW5pdCkpKSArIHVuaXQ7XG59LFxuICAgIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICBjYWNoZS56ID0gXCIwcHhcIjtcbiAgY2FjaGUucm90YXRpb25ZID0gY2FjaGUucm90YXRpb25YID0gXCIwZGVnXCI7XG4gIGNhY2hlLmZvcmNlM0QgPSAwO1xuXG4gIF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF96ZXJvRGVnID0gXCIwZGVnXCIsXG4gICAgX3plcm9QeCA9IFwiMHB4XCIsXG4gICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuICAgIF9yZW5kZXJDU1NUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcbiAgICAgIHlQZXJjZW50ID0gX3JlZi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeiA9IF9yZWYueixcbiAgICAgIHJvdGF0aW9uID0gX3JlZi5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxuICAgICAgcm90YXRpb25YID0gX3JlZi5yb3RhdGlvblgsXG4gICAgICBza2V3WCA9IF9yZWYuc2tld1gsXG4gICAgICBza2V3WSA9IF9yZWYuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxuICAgICAgZm9yY2UzRCA9IF9yZWYuZm9yY2UzRCxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcbiAgICAgIHRyYW5zZm9ybXMgPSBcIlwiLFxuICAgICAgdXNlM0QgPSBmb3JjZTNEID09PSBcImF1dG9cIiAmJiByYXRpbyAmJiByYXRpbyAhPT0gMSB8fCBmb3JjZTNEID09PSB0cnVlOyAvLyBTYWZhcmkgaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGl0IG5vdCB0byByZW5kZXIgM0QgdHJhbnNmb3JtLW9yaWdpbiB2YWx1ZXMgcHJvcGVybHksIHNvIHdlIGZvcmNlIHRoZSB6IG9yaWdpbiB0byAwLCByZWNvcmQgaXQgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiBkbyB0aGUgbWF0aCBoZXJlIHRvIG9mZnNldCB0aGUgdHJhbnNsYXRlIHZhbHVlcyBhY2NvcmRpbmdseSAoYmFzaWNhbGx5IGRvIHRoZSAzRCB0cmFuc2Zvcm0tb3JpZ2luIHBhcnQgbWFudWFsbHkpXG5cblxuICBpZiAoek9yaWdpbiAmJiAocm90YXRpb25YICE9PSBfemVyb0RlZyB8fCByb3RhdGlvblkgIT09IF96ZXJvRGVnKSkge1xuICAgIHZhciBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25ZKSAqIF9ERUcyUkFELFxuICAgICAgICBhMTMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGEzMyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgY29zO1xuXG4gICAgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcbiAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgeCA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHgsIGExMyAqIGNvcyAqIC16T3JpZ2luKTtcbiAgICB5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcbiAgICB6ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeiwgYTMzICogY29zICogLXpPcmlnaW4gKyB6T3JpZ2luKTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJwZXJzcGVjdGl2ZShcIiArIHRyYW5zZm9ybVBlcnNwZWN0aXZlICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInRyYW5zbGF0ZShcIiArIHhQZXJjZW50ICsgXCIlLCBcIiArIHlQZXJjZW50ICsgXCIlKSBcIjtcbiAgfVxuXG4gIGlmICh1c2UzRCB8fCB4ICE9PSBfemVyb1B4IHx8IHkgIT09IF96ZXJvUHggfHwgeiAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0geiAhPT0gX3plcm9QeCB8fCB1c2UzRCA/IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiLCBcIiArIHogKyBcIikgXCIgOiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVkoXCIgKyByb3RhdGlvblkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRpb25YICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwic2tldyhcIiArIHNrZXdYICsgXCIsIFwiICsgc2tld1kgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJzY2FsZShcIiArIHNjYWxlWCArIFwiLCBcIiArIHNjYWxlWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG59LFxuICAgIF9yZW5kZXJTVkdUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlclNWR1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmMiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICB4UGVyY2VudCA9IF9yZWYyLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmMi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmMi54LFxuICAgICAgeSA9IF9yZWYyLnksXG4gICAgICByb3RhdGlvbiA9IF9yZWYyLnJvdGF0aW9uLFxuICAgICAgc2tld1ggPSBfcmVmMi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZjIuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB4T3JpZ2luID0gX3JlZjIueE9yaWdpbixcbiAgICAgIHlPcmlnaW4gPSBfcmVmMi55T3JpZ2luLFxuICAgICAgeE9mZnNldCA9IF9yZWYyLnhPZmZzZXQsXG4gICAgICB5T2Zmc2V0ID0gX3JlZjIueU9mZnNldCxcbiAgICAgIGZvcmNlQ1NTID0gX3JlZjIuZm9yY2VDU1MsXG4gICAgICB0eCA9IHBhcnNlRmxvYXQoeCksXG4gICAgICB0eSA9IHBhcnNlRmxvYXQoeSksXG4gICAgICBhMTEsXG4gICAgICBhMjEsXG4gICAgICBhMTIsXG4gICAgICBhMjIsXG4gICAgICB0ZW1wO1xuXG4gIHJvdGF0aW9uID0gcGFyc2VGbG9hdChyb3RhdGlvbik7XG4gIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XG4gIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG5cbiAgaWYgKHNrZXdZKSB7XG4gICAgLy9mb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgY29tYmluZSBhbGwgc2tld2luZyBpbnRvIHRoZSBza2V3WCBhbmQgcm90YXRpb24gdmFsdWVzLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBkZWdyZWVzIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgZGVncmVlcyBwbHVzIGEgc2tld1ggb2YgMTAgZGVncmVlcy5cbiAgICBza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuICAgIHNrZXdYICs9IHNrZXdZO1xuICAgIHJvdGF0aW9uICs9IHNrZXdZO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG4gICAgcm90YXRpb24gKj0gX0RFRzJSQUQ7XG4gICAgc2tld1ggKj0gX0RFRzJSQUQ7XG4gICAgYTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuICAgIGEyMSA9IE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWDtcbiAgICBhMTIgPSBNYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIC1zY2FsZVk7XG4gICAgYTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cbiAgICBpZiAoc2tld1gpIHtcbiAgICAgIHNrZXdZICo9IF9ERUcyUkFEO1xuICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdYIC0gc2tld1kpO1xuICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgYTEyICo9IHRlbXA7XG4gICAgICBhMjIgKj0gdGVtcDtcblxuICAgICAgaWYgKHNrZXdZKSB7XG4gICAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WSk7XG4gICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgICAgYTExICo9IHRlbXA7XG4gICAgICAgIGEyMSAqPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGExMSA9IF9yb3VuZChhMTEpO1xuICAgIGEyMSA9IF9yb3VuZChhMjEpO1xuICAgIGExMiA9IF9yb3VuZChhMTIpO1xuICAgIGEyMiA9IF9yb3VuZChhMjIpO1xuICB9IGVsc2Uge1xuICAgIGExMSA9IHNjYWxlWDtcbiAgICBhMjIgPSBzY2FsZVk7XG4gICAgYTIxID0gYTEyID0gMDtcbiAgfVxuXG4gIGlmICh0eCAmJiAhfih4ICsgXCJcIikuaW5kZXhPZihcInB4XCIpIHx8IHR5ICYmICF+KHkgKyBcIlwiKS5pbmRleE9mKFwicHhcIikpIHtcbiAgICB0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG4gICAgdHkgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieVwiLCB5LCBcInB4XCIpO1xuICB9XG5cbiAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhPcmlnaW4gLSAoeE9yaWdpbiAqIGExMSArIHlPcmlnaW4gKiBhMTIpICsgeE9mZnNldCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5T3JpZ2luIC0gKHhPcmlnaW4gKiBhMjEgKyB5T3JpZ2luICogYTIyKSArIHlPZmZzZXQpO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgLy9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSB0cmFuc2xhdGlvbiB0byBzaW11bGF0ZSBpdC5cbiAgICB0ZW1wID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhQZXJjZW50IC8gMTAwICogdGVtcC53aWR0aCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcbiAgfVxuXG4gIHRlbXAgPSBcIm1hdHJpeChcIiArIGExMSArIFwiLFwiICsgYTIxICsgXCIsXCIgKyBhMTIgKyBcIixcIiArIGEyMiArIFwiLFwiICsgdHggKyBcIixcIiArIHR5ICsgXCIpXCI7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG4gIGZvcmNlQ1NTICYmICh0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdGVtcCk7IC8vc29tZSBicm93c2VycyBwcmlvcml0aXplIENTUyB0cmFuc2Zvcm1zIG92ZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuIFdoZW4gd2Ugc2Vuc2UgdGhhdCB0aGUgdXNlciBoYXMgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCwgd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB0aGlzIHdheSAob3RoZXJ3aXNlIHNvbWUgYnJvd3NlciBzaW1wbHkgd29uJ3QgcmVuZGVyIHRoZSAgdHJhbnNmb3JtIGF0dHJpYnV0ZSBjaGFuZ2VzISlcbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpIHtcbiAgdmFyIGNhcCA9IDM2MCxcbiAgICAgIGlzU3RyaW5nID0gX2lzU3RyaW5nKGVuZFZhbHVlKSxcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgIGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwdDtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcbiAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgIGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuICAgICAgICBjaGFuZ2UgKz0gY2hhbmdlIDwgMCA/IGNhcCA6IC1jYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG4gIHB0LmUgPSBmaW5hbFZhbHVlO1xuICBwdC51ID0gXCJkZWdcIjtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3R5bGUgPSBfdGVtcERpdlN0eWxlci5zdHlsZSxcbiAgICAgIHN0YXJ0Q2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcbiAgc3R5bGUuY3NzVGV4dCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5jc3NUZXh0ICsgXCI7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztcIjsgLy8lLWJhc2VkIHRyYW5zbGF0aW9ucyB3aWxsIGZhaWwgdW5sZXNzIHdlIHNldCB0aGUgd2lkdGgvaGVpZ2h0IHRvIG1hdGNoIHRoZSBvcmlnaW5hbCB0YXJnZXQgKGFuZCBwYWRkaW5nL2JvcmRlcnMgY2FuIGFmZmVjdCBpdClcblxuICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuXG4gIF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdlN0eWxlcik7XG5cbiAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0oX3RlbXBEaXZTdHlsZXIsIDEpO1xuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBzdGFydENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgIHBsdWdpbi5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuXG4gIF9kb2MuYm9keS5yZW1vdmVDaGlsZChfdGVtcERpdlN0eWxlcik7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eTtcbiAgICBfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvLyBwbHVnaW5zXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgc3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpYWxQcm9wKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH0gZWxzZSBpZiAocC5zdWJzdHIoMCwgMikgPT09IFwiLS1cIikge1xuICAgICAgICAvL0NTUyB2YXJpYWJsZVxuICAgICAgICBzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xuICAgICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgcCBpbiBfY29uZmlnLnVuaXRzICYmICFnZXRVbml0KHN0YXJ0VmFsdWUpICYmIChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0pOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblxuICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7IC8vIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcbiAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCA9IHAgaW4gX3RyYW5zZm9ybVByb3BzOyAvLy0tLSBUUkFOU0ZPUk0tUkVMQVRFRCAtLS1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIHJlbGF0aXZlID8gcmVsYXRpdmUgKiBlbmROdW0gOiBlbmROdW0gLSBjYWNoZS5zY2FsZVkpO1xuICAgICAgICAgICAgcHJvcHMucHVzaChcInNjYWxlWVwiLCBwKTtcbiAgICAgICAgICAgIHAgKz0gXCJYXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKGVuZFZhbHVlKTsgLy9pbiBjYXNlIHNvbWV0aGluZyBsaWtlIFwibGVmdCB0b3BcIiBvciBcImJvdHRvbSByaWdodFwiIGlzIHBhc3NlZCBpbi4gQ29udmVydCB0byBwZXJjZW50YWdlcy5cblxuICAgICAgICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZFVuaXQgPSBwYXJzZUZsb2F0KGVuZFZhbHVlLnNwbGl0KFwiIFwiKVsyXSkgfHwgMDsgLy9oYW5kbGUgdGhlIHpPcmlnaW4gc2VwYXJhdGVseSFcblxuICAgICAgICAgICAgICBlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmVsYXRpdmUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwic21vb3RoT3JpZ2luXCIpIHtcbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImZvcmNlM0RcIikge1xuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kTnVtIHx8IChlbmROdW0gPSAwKTsgLy8gcHJvdGVjdCBhZ2FpbnN0IE5hTlxuXG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpIHx8IChwIGluIF9jb25maWcudW5pdHMgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcbiAgICAgICAgICBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSk7XG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLCAhaXNUcmFuc2Zvcm1SZWxhdGVkICYmIChlbmRVbml0ID09PSBcInB4XCIgfHwgcCA9PT0gXCJ6SW5kZXhcIikgJiYgdmFycy5hdXRvUm91bmQgIT09IGZhbHNlID8gX3JlbmRlclJvdW5kZWRDU1NQcm9wIDogX3JlbmRlckNTU1Byb3ApO1xuICAgICAgICAgIHRoaXMuX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgICAvL3doZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJldmVydCBpdCB0byB0aGUgT0xEL09SSUdJTkFMIHZhbHVlICh3aXRoIHRob3NlIHVuaXRzKS4gV2UgcmVjb3JkIHRoYXQgYXMgYSBcImJcIiAoYmVnaW5uaW5nKSBwcm9wZXJ0eSBhbmQgcG9pbnQgdG8gYSByZW5kZXIgbWV0aG9kIHRoYXQgaGFuZGxlcyB0aGF0LiAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgICAgICAgICAgdGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgaWYgKHAgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvL21heWJlIGl0J3Mgbm90IGEgc3R5bGUgLSBpdCBjb3VsZCBiZSBhIHByb3BlcnR5IGFkZGVkIGRpcmVjdGx5IHRvIGFuIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSdsbCB0cnkgdG8gYW5pbWF0ZSB0aGF0LlxuICAgICAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCB0YXJnZXRbcF0sIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcbiAgfSxcbiAgZ2V0OiBfZ2V0LFxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAvL3JldHVybnMgYSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRhcmdldCwgcHJvcGVydHksIHZhbHVlIGFuZCBhcHBsaWVzIGl0IGFjY29yZGluZ2x5LiBSZW1lbWJlciwgcHJvcGVydGllcyBsaWtlIFwieFwiIGFyZW4ndCBhcyBzaW1wbGUgYXMgdGFyZ2V0LnN0eWxlLnByb3BlcnR5ID0gdmFsdWUgYmVjYXVzZSB0aGV5J3ZlIGdvdCB0byBiZSBhcHBsaWVkIHRvIGEgcHJveHkgb2JqZWN0IGFuZCB0aGVuIG1lcmdlZCBpbnRvIGEgdHJhbnNmb3JtIHN0cmluZyBpbiBhIHJlbmRlcmVyLlxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgcCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCAmJiAocHJvcGVydHkgPSBwKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH0sXG4gIGNvcmU6IHtcbiAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gIH1cbn07XG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcblxuKGZ1bmN0aW9uIChwb3NpdGlvbkFuZFNjYWxlLCByb3RhdGlvbiwgb3RoZXJzLCBhbGlhc2VzKSB7XG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gIF9mb3JFYWNoTmFtZShhbGlhc2VzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgfSk7XG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcbn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5leHBvcnQgeyBDU1NQbHVnaW4gYXMgZGVmYXVsdCwgX2dldEJCb3gsIF9jcmVhdGVFbGVtZW50LCBfY2hlY2tQcm9wUHJlZml4IGFzIGNoZWNrUHJlZml4IH07IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIEdTQVAgMy42LjBcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2NvbmZpZyA9IHtcbiAgYXV0b1NsZWVwOiAxMjAsXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxuICBudWxsVGFyZ2V0V2FybjogMSxcbiAgdW5pdHM6IHtcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXG4gIH1cbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICBkdXJhdGlvbjogLjUsXG4gIG92ZXJ3cml0ZTogZmFsc2UsXG4gIGRlbGF5OiAwXG59LFxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgIF8yUEkgPSBNYXRoLlBJICogMixcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxuICAgIF9nc0lEID0gMCxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzTm90RmFsc2UgPSBmdW5jdGlvbiBfaXNOb3RGYWxzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc0Z1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9pc0Z1bmNPclN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XG59LFxuICAgIF9pc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24gKCkge30sXG4gICAgLy8gbm90ZTogSUUxMCBoYXMgQXJyYXlCdWZmZXIsIGJ1dCBOT1QgQXJyYXlCdWZmZXIuaXNWaWV3KCkuXG5faXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX3N0cmljdE51bUV4cCA9IC8oPzotP1xcLj9cXGR8XFwuKSsvZ2ksXG4gICAgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cbl9udW1FeHAgPSAvWy0rPS5dKlxcZCtbLmVcXC0rXSpcXGQqW2VcXC0rXSpcXGQqL2csXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgX2NvbXBsZXhTdHJpbmdOdW1FeHAgPSAvWy0rPS5dKlxcZCtcXC4/XFxkKig/OmUtfGVcXCspP1xcZCovZ2ksXG4gICAgLy9kdXBsaWNhdGUgc28gdGhhdCB3aGlsZSB3ZSdyZSBsb29waW5nIHRocm91Z2ggbWF0Y2hlcyBmcm9tIGV4ZWMoKSwgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgbGFzdEluZGV4IG9mIF9udW1FeHAgd2hpY2ggd2UgdXNlIHRvIHNlYXJjaCBmb3IgY29sb3JzIHRvby5cbl9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgIF9kZWxpbWl0ZWRWYWx1ZUV4cCA9IC9bI1xcLSsuXSpcXGJbYS16XFxkLT0rJS5dKy9naSxcbiAgICBfdW5pdEV4cCA9IC9bXFxkLitcXC09XSsoPzplWy0rXVxcZCopKi9pLFxuICAgIF9nbG9iYWxUaW1lbGluZSxcbiAgICBfd2luLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZG9jLFxuICAgIF9nbG9iYWxzID0ge30sXG4gICAgX2luc3RhbGxTY29wZSA9IHt9LFxuICAgIF9jb3JlUmVhZHksXG4gICAgX2luc3RhbGwgPSBmdW5jdGlvbiBfaW5zdGFsbChzY29wZSkge1xuICByZXR1cm4gKF9pbnN0YWxsU2NvcGUgPSBfbWVyZ2Uoc2NvcGUsIF9nbG9iYWxzKSkgJiYgZ3NhcDtcbn0sXG4gICAgX21pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiBfbWlzc2luZ1BsdWdpbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvcGVydHlcIiwgcHJvcGVydHksIFwic2V0IHRvXCIsIHZhbHVlLCBcIk1pc3NpbmcgcGx1Z2luPyBnc2FwLnJlZ2lzdGVyUGx1Z2luKClcIik7XG59LFxuICAgIF93YXJuID0gZnVuY3Rpb24gX3dhcm4obWVzc2FnZSwgc3VwcHJlc3MpIHtcbiAgcmV0dXJuICFzdXBwcmVzcyAmJiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9hZGRHbG9iYWwgPSBmdW5jdGlvbiBfYWRkR2xvYmFsKG5hbWUsIG9iaikge1xuICByZXR1cm4gbmFtZSAmJiAoX2dsb2JhbHNbbmFtZV0gPSBvYmopICYmIF9pbnN0YWxsU2NvcGUgJiYgKF9pbnN0YWxsU2NvcGVbbmFtZV0gPSBvYmopIHx8IF9nbG9iYWxzO1xufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgcmV0dXJuIDA7XG59LFxuICAgIF9yZXNlcnZlZFByb3BzID0ge30sXG4gICAgX2xhenlUd2VlbnMgPSBbXSxcbiAgICBfbGF6eUxvb2t1cCA9IHt9LFxuICAgIF9sYXN0UmVuZGVyZWRGcmFtZSxcbiAgICBfcGx1Z2lucyA9IHt9LFxuICAgIF9lZmZlY3RzID0ge30sXG4gICAgX25leHRHQ0ZyYW1lID0gMzAsXG4gICAgX2hhcm5lc3NQbHVnaW5zID0gW10sXG4gICAgX2NhbGxiYWNrTmFtZXMgPSBcIlwiLFxuICAgIF9oYXJuZXNzID0gZnVuY3Rpb24gX2hhcm5lc3ModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXSxcbiAgICAgIGhhcm5lc3NQbHVnaW4sXG4gICAgICBpO1xuICBfaXNPYmplY3QodGFyZ2V0KSB8fCBfaXNGdW5jdGlvbih0YXJnZXQpIHx8ICh0YXJnZXRzID0gW3RhcmdldHNdKTtcblxuICBpZiAoIShoYXJuZXNzUGx1Z2luID0gKHRhcmdldC5fZ3NhcCB8fCB7fSkuaGFybmVzcykpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBhIGhhcm5lc3MuIFdlIGFzc3VtZSB0YXJnZXRzIHBhc3NlZCBpbnRvIGFuIGFuaW1hdGlvbiB3aWxsIGJlIG9mIHNpbWlsYXIgdHlwZSwgbWVhbmluZyB0aGUgc2FtZSBraW5kIG9mIGhhcm5lc3MgY2FuIGJlIHVzZWQgZm9yIHRoZW0gYWxsIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgaSA9IF9oYXJuZXNzUGx1Z2lucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tICYmICFfaGFybmVzc1BsdWdpbnNbaV0udGFyZ2V0VGVzdCh0YXJnZXQpKSB7fVxuXG4gICAgaGFybmVzc1BsdWdpbiA9IF9oYXJuZXNzUGx1Z2luc1tpXTtcbiAgfVxuXG4gIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdGFyZ2V0c1tpXSAmJiAodGFyZ2V0c1tpXS5fZ3NhcCB8fCAodGFyZ2V0c1tpXS5fZ3NhcCA9IG5ldyBHU0NhY2hlKHRhcmdldHNbaV0sIGhhcm5lc3NQbHVnaW4pKSkgfHwgdGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0cztcbn0sXG4gICAgX2dldENhY2hlID0gZnVuY3Rpb24gX2dldENhY2hlKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRvQXJyYXkodGFyZ2V0KSlbMF0uX2dzYXA7XG59LFxuICAgIF9nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2KSB7XG4gIHJldHVybiAodiA9IHRhcmdldFtwcm9wZXJ0eV0pICYmIF9pc0Z1bmN0aW9uKHYpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgdjtcbn0sXG4gICAgX2ZvckVhY2hOYW1lID0gZnVuY3Rpb24gX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jKSB7XG4gIHJldHVybiAobmFtZXMgPSBuYW1lcy5zcGxpdChcIixcIikpLmZvckVhY2goZnVuYykgfHwgbmFtZXM7XG59LFxuICAgIC8vc3BsaXQgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBuYW1lcyBpbnRvIGFuIGFycmF5LCB0aGVuIHJ1biBhIGZvckVhY2goKSBmdW5jdGlvbiBhbmQgcmV0dXJuIHRoZSBzcGxpdCBhcnJheSAodGhpcyBpcyBqdXN0IGEgd2F5IHRvIGNvbnNvbGlkYXRlL3Nob3J0ZW4gc29tZSBjb2RlKS5cbl9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9wYXJzZVZhcnMgPSBmdW5jdGlvbiBfcGFyc2VWYXJzKHBhcmFtcywgdHlwZSwgcGFyZW50KSB7XG4gIC8vcmVhZHMgdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gb25lIG9mIHRoZSBrZXkgbWV0aG9kcyBhbmQgZmlndXJlcyBvdXQgaWYgdGhlIHVzZXIgaXMgZGVmaW5pbmcgdGhpbmdzIHdpdGggdGhlIE9MRC9sZWdhY3kgc3ludGF4IHdoZXJlIHRoZSBkdXJhdGlvbiBpcyB0aGUgMm5kIHBhcmFtZXRlciwgYW5kIHRoZW4gaXQgYWRqdXN0cyB0aGluZ3MgYWNjb3JkaW5nbHkgYW5kIHNwaXRzIGJhY2sgdGhlIGNvcnJlY3RlZCB2YXJzIG9iamVjdCAod2l0aCB0aGUgZHVyYXRpb24gYWRkZWQgaWYgbmVjZXNzYXJ5LCBhcyB3ZWxsIGFzIHJ1bkJhY2t3YXJkcyBvciBzdGFydEF0IG9yIGltbWVkaWF0ZVJlbmRlcikuIHR5cGUgMCA9IHRvKCkvc3RhZ2dlclRvKCksIDEgPSBmcm9tKCkvc3RhZ2dlckZyb20oKSwgMiA9IGZyb21UbygpL3N0YWdnZXJGcm9tVG8oKVxuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycztcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaXJWYXJzID0gdmFycztcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgIShcImltbWVkaWF0ZVJlbmRlclwiIGluIGlyVmFycykpIHtcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXG4gICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgIHBhcmVudCA9IF9pc05vdEZhbHNlKHBhcmVudC52YXJzLmluaGVyaXQpICYmIHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IHAgPT09IFwiZHVyYXRpb25cIiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICB9XG59LFxuICAgIF9tZXJnZSA9IGZ1bmN0aW9uIF9tZXJnZShiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIGJhc2VbcF0gPSB0b01lcmdlW3BdO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59LFxuICAgIF9tZXJnZURlZXAgPSBmdW5jdGlvbiBfbWVyZ2VEZWVwKGJhc2UsIHRvTWVyZ2UpIHtcbiAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgcCAhPT0gXCJfX3Byb3RvX19cIiAmJiBwICE9PSBcImNvbnN0cnVjdG9yXCIgJiYgcCAhPT0gXCJwcm90b3R5cGVcIiAmJiAoYmFzZVtwXSA9IF9pc09iamVjdCh0b01lcmdlW3BdKSA/IF9tZXJnZURlZXAoYmFzZVtwXSB8fCAoYmFzZVtwXSA9IHt9KSwgdG9NZXJnZVtwXSkgOiB0b01lcmdlW3BdKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfY29weUV4Y2x1ZGluZyA9IGZ1bmN0aW9uIF9jb3B5RXhjbHVkaW5nKG9iaiwgZXhjbHVkaW5nKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2luaGVyaXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9pbmhlcml0RGVmYXVsdHModmFycykge1xuICB2YXIgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xufSxcbiAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24uX2RwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xuXG4gICAgX3NldEVuZChhbmltYXRpb24pO1xuXG4gICAgcGFyZW50Ll9kaXJ0eSB8fCBfdW5jYWNoZShwYXJlbnQsIGFuaW1hdGlvbik7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG5cbi8qXG5fdG90YWxUaW1lVG9UaW1lID0gKGNsYW1wZWRUb3RhbFRpbWUsIGR1cmF0aW9uLCByZXBlYXQsIHJlcGVhdERlbGF5LCB5b3lvKSA9PiB7XG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcblx0XHR0aW1lID0gX3JvdW5kKGNsYW1wZWRUb3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uKTtcblx0aWYgKHRpbWUgPiBkdXJhdGlvbikge1xuXHRcdHRpbWUgPSBkdXJhdGlvbjtcblx0fVxuXHRyZXR1cm4gKHlveW8gJiYgKH5+KGNsYW1wZWRUb3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSAmIDEpKSA/IGR1cmF0aW9uIC0gdGltZSA6IHRpbWU7XG59LFxuKi9cbl9wb3N0QWRkQ2hlY2tzID0gZnVuY3Rpb24gX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKSB7XG4gIHZhciB0O1xuXG4gIGlmIChjaGlsZC5fdGltZSB8fCBjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikge1xuICAgIC8vaW4gY2FzZSwgZm9yIGV4YW1wbGUsIHRoZSBfc3RhcnQgaXMgbW92ZWQgb24gYSB0d2VlbiB0aGF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkLiBJbWFnaW5lIGl0J3MgYXQgaXRzIGVuZCBzdGF0ZSwgdGhlbiB0aGUgc3RhcnRUaW1lIGlzIG1vdmVkIFdBWSBsYXRlciAoYWZ0ZXIgdGhlIGVuZCBvZiB0aGlzIHRpbWVsaW5lKSwgaXQgc2hvdWxkIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLlxuICAgIHQgPSBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lbGluZS5yYXdUaW1lKCksIGNoaWxkKTtcblxuICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vaWYgdGhlIHRpbWVsaW5lIGhhcyBhbHJlYWR5IGVuZGVkIGJ1dCB0aGUgaW5zZXJ0ZWQgdHdlZW4vdGltZWxpbmUgZXh0ZW5kcyB0aGUgZHVyYXRpb24sIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0aW1lbGluZSBhZ2FpbiBzbyB0aGF0IGl0IHJlbmRlcnMgcHJvcGVybHkuIFdlIHNob3VsZCBhbHNvIGFsaWduIHRoZSBwbGF5aGVhZCB3aXRoIHRoZSBwYXJlbnQgdGltZWxpbmUncyB3aGVuIGFwcHJvcHJpYXRlLlxuXG5cbiAgaWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG4gICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xuICAgICAgdCA9IHRpbWVsaW5lO1xuXG4gICAgICB3aGlsZSAodC5fZHApIHtcbiAgICAgICAgdC5yYXdUaW1lKCkgPj0gMCAmJiB0LnRvdGFsVGltZSh0Ll90VGltZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LiBJZiBpdCdzIGN1cnJlbnRseSB6ZXJvLCB0aG91Z2gsIGl0IG1heSBub3QgYmUgc2NoZWR1bGVkIHRvIHJlbmRlciB1bnRpbCBsYXRlciBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgaXQgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBwbGF5aGVhZCBwb3NpdGlvbi4gT25seSBtb3ZlIHRvIGNhdGNoIHVwIHdpdGggdGhlIHBsYXloZWFkLlxuXG4gICAgICAgIHQgPSB0Ll9kcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07IC8vIGhlbHBzIGVuc3VyZSB0aGF0IHRoZSBuZXh0IHJlbmRlcigpIHdpbGwgYmUgZm9yY2VkIChjcm9zc2luZ1N0YXJ0ID0gdHJ1ZSBpbiByZW5kZXIoKSksIGV2ZW4gaWYgdGhlIGR1cmF0aW9uIGhhc24ndCBjaGFuZ2VkICh3ZSdyZSBhZGRpbmcgYSBjaGlsZCB3aGljaCB3b3VsZCBuZWVkIHRvIGdldCByZW5kZXJlZCkuIERlZmluaXRlbHkgYW4gZWRnZSBjYXNlLiBOb3RlOiB3ZSBNVVNUIGRvIHRoaXMgQUZURVIgdGhlIGxvb3AgYWJvdmUgd2hlcmUgdGhlIHRvdGFsVGltZSgpIG1pZ2h0IHRyaWdnZXIgYSByZW5kZXIoKSBiZWNhdXNlIHRoaXMgX2FkZFRvVGltZWxpbmUoKSBtZXRob2QgZ2V0cyBjYWxsZWQgZnJvbSB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBCRUZPUkUgdHdlZW5zIGV2ZW4gcmVjb3JkIHRoZWlyIHRhcmdldHMsIGV0Yy4gc28gd2Ugd291bGRuJ3Qgd2FudCB0aGluZ3MgdG8gZ2V0IHRyaWdnZXJlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuXG4gIH1cbn0sXG4gICAgX2FkZFRvVGltZWxpbmUgPSBmdW5jdGlvbiBfYWRkVG9UaW1lbGluZSh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSB7XG4gIGNoaWxkLnBhcmVudCAmJiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gIGNoaWxkLl9zdGFydCA9IF9yb3VuZChwb3NpdGlvbiArIGNoaWxkLl9kZWxheSk7XG4gIGNoaWxkLl9lbmQgPSBfcm91bmQoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICB0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQ7XG4gIHNraXBDaGVja3MgfHwgX3Bvc3RBZGRDaGVja3ModGltZWxpbmUsIGNoaWxkKTtcbiAgcmV0dXJuIHRpbWVsaW5lO1xufSxcbiAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICByZXR1cm4gKF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIgfHwgX21pc3NpbmdQbHVnaW4oXCJzY3JvbGxUcmlnZ2VyXCIsIHRyaWdnZXIpKSAmJiBfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSh0cmlnZ2VyLCBhbmltYXRpb24pO1xufSxcbiAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykge1xuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUpO1xuXG4gIGlmICghdHdlZW4uX2luaXR0ZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmICghZm9yY2UgJiYgdHdlZW4uX3B0ICYmICh0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSAhPT0gZmFsc2UgfHwgIXR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5KSAmJiBfbGFzdFJlbmRlcmVkRnJhbWUgIT09IF90aWNrZXIuZnJhbWUpIHtcbiAgICBfbGF6eVR3ZWVucy5wdXNoKHR3ZWVuKTtcblxuICAgIHR3ZWVuLl9sYXp5ID0gW3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHNdO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5fdHMgJiYgcGFyZW50Ll9pbml0dGVkICYmICFwYXJlbnQuX2xvY2sgJiYgKHBhcmVudC5yYXdUaW1lKCkgPCAwIHx8IF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQocGFyZW50KSk7XG59LFxuICAgIC8vIGNoZWNrIHBhcmVudCdzIF9sb2NrIGJlY2F1c2Ugd2hlbiBhIHRpbWVsaW5lIHJlcGVhdHMveW95b3MgYW5kIGRvZXMgaXRzIGFydGlmaWNpYWwgd3JhcHBpbmcsIHdlIHNob3VsZG4ndCBmb3JjZSB0aGUgcmF0aW8gYmFjayB0byAwXG5fcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgIHJhdGlvID0gdG90YWxUaW1lIDwgMCB8fCAhdG90YWxUaW1lICYmICghdHdlZW4uX3N0YXJ0ICYmIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQodHdlZW4pIHx8ICh0d2Vlbi5fdHMgPCAwIHx8IHR3ZWVuLl9kcC5fdHMgPCAwKSAmJiB0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIgJiYgdHdlZW4uZGF0YSAhPT0gXCJpc1N0YXJ0XCIpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLlxuICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICB0VGltZSA9IDAsXG4gICAgICBwdCxcbiAgICAgIGl0ZXJhdGlvbixcbiAgICAgIHByZXZJdGVyYXRpb247XG5cbiAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHRoYXQgaGFzIGEgcmVwZWF0IHdpdGggYSByZXBlYXREZWxheVxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSk7XG4gICAgdHdlZW4uX3lveW8gJiYgaXRlcmF0aW9uICYgMSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuXG4gICAgaWYgKGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgcHJldlJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgdHdlZW4udmFycy5yZXBlYXRSZWZyZXNoICYmIHR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmF0aW8gIT09IHByZXZSYXRpbyB8fCBmb3JjZSB8fCB0d2Vlbi5felRpbWUgPT09IF90aW55TnVtIHx8ICF0b3RhbFRpbWUgJiYgdHdlZW4uX3pUaW1lKSB7XG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAvLyBpZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcbiAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTsgLy8gd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuXG5cbiAgICBzdXBwcmVzc0V2ZW50cyB8fCAoc3VwcHJlc3NFdmVudHMgPSB0b3RhbFRpbWUgJiYgIXByZXZJdGVyYXRpb24pOyAvLyBpZiBpdCB3YXMgcmVuZGVyZWQgcHJldmlvdXNseSBhdCBleGFjdGx5IDAgKF96VGltZSkgYW5kIG5vdyB0aGUgcGxheWhlYWQgaXMgbW92aW5nIGF3YXksIERPTidUIGZpcmUgY2FsbGJhY2tzIG90aGVyd2lzZSB0aGV5J2xsIHNlZW0gbGlrZSBkdXBsaWNhdGVzLlxuXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcbiAgICB0d2Vlbi5fZnJvbSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuICAgIHR3ZWVuLl90aW1lID0gMDtcbiAgICB0d2Vlbi5fdFRpbWUgPSB0VGltZTtcbiAgICBzdXBwcmVzc0V2ZW50cyB8fCBfY2FsbGJhY2sodHdlZW4sIFwib25TdGFydFwiKTtcbiAgICBwdCA9IHR3ZWVuLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHR3ZWVuLl9zdGFydEF0ICYmIHRvdGFsVGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcblxuICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcbiAgfVxufSxcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XG4gIHZhciBjaGlsZDtcblxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICBpZiAoIWNoaWxkLl9kdXIgJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPj0gdGltZSkge1xuICAgICAgaWYgKCFjaGlsZC5fZHVyICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gIHZhciByZXBlYXQgPSBhbmltYXRpb24uX3JlcGVhdCxcbiAgICAgIGR1ciA9IF9yb3VuZChkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kKGR1ciAqIChyZXBlYXQgKyAxKSArIGFuaW1hdGlvbi5fckRlbGF5ICogcmVwZWF0KTtcbiAgdG90YWxQcm9ncmVzcyAmJiAhbGVhdmVQbGF5aGVhZCA/IF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl90VGltZSA9IGFuaW1hdGlvbi5fdER1ciAqIHRvdGFsUHJvZ3Jlc3MpIDogYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gIHNraXBVbmNhY2hlIHx8IF91bmNhY2hlKGFuaW1hdGlvbi5wYXJlbnQsIGFuaW1hdGlvbik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKGFuaW1hdGlvbikge1xuICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xufSxcbiAgICBfemVyb1Bvc2l0aW9uID0ge1xuICBfc3RhcnQ6IDAsXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmNcbn0sXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uKSB7XG4gIHZhciBsYWJlbHMgPSBhbmltYXRpb24ubGFiZWxzLFxuICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgIC8vaW4gY2FzZSB0aGVyZSdzIGEgY2hpbGQgdGhhdCBpbmZpbml0ZWx5IHJlcGVhdHMsIHVzZXJzIGFsbW9zdCBuZXZlciBpbnRlbmQgZm9yIHRoZSBpbnNlcnRpb24gcG9pbnQgb2YgYSBuZXcgY2hpbGQgdG8gYmUgYmFzZWQgb24gYSBTVVBFUiBsb25nIHZhbHVlIGxpa2UgdGhhdCBzbyB3ZSBjbGlwIGl0IGFuZCBhc3N1bWUgdGhlIG1vc3QgcmVjZW50bHktYWRkZWQgY2hpbGQncyBlbmRUaW1lIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gIGksXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XG4gICAgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cbiAgICBpID0gcG9zaXRpb24uY2hhckF0KDApO1xuXG4gICAgaWYgKGkgPT09IFwiPFwiIHx8IGkgPT09IFwiPlwiKSB7XG4gICAgICByZXR1cm4gKGkgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCk7XG4gICAgfVxuXG4gICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBwb3NpdGlvbiBpbiBsYWJlbHMgfHwgKGxhYmVsc1twb3NpdGlvbl0gPSBjbGlwcGVkRHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGxhYmVsc1twb3NpdGlvbl07XG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gKyhwb3NpdGlvbi5jaGFyQXQoaSAtIDEpICsgcG9zaXRpb24uc3Vic3RyKGkgKyAxKSk7XG4gICAgcmV0dXJuIGkgPiAxID8gX3BhcnNlUG9zaXRpb24oYW5pbWF0aW9uLCBwb3NpdGlvbi5zdWJzdHIoMCwgaSAtIDEpKSArIG9mZnNldCA6IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldDtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbiA9PSBudWxsID8gY2xpcHBlZER1cmF0aW9uIDogK3Bvc2l0aW9uO1xufSxcbiAgICBfY29uZGl0aW9uYWxSZXR1cm4gPSBmdW5jdGlvbiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmMpIHtcbiAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gZnVuYyh2YWx1ZSkgOiBmdW5jO1xufSxcbiAgICBfY2xhbXAgPSBmdW5jdGlvbiBfY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG59LFxuICAgIGdldFVuaXQgPSBmdW5jdGlvbiBnZXRVbml0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHZhciB2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSk7XG5cbiAgcmV0dXJuIHYgPyB2YWx1ZS5zdWJzdHIodi5pbmRleCArIHZbMF0ubGVuZ3RoKSA6IFwiXCI7XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgbGVhdmVTdHJpbmdzKSB7XG4gIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgJiYgKF9jb3JlSW5pdHRlZCB8fCAhX3dha2UoKSkgPyBfc2xpY2UuY2FsbChfZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZShhKSB7XG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gIH0pO1xufSxcbiAgICAvLyBhbHRlcm5hdGl2ZSB0aGF0J3MgYSBiaXQgZmFzdGVyIGFuZCBtb3JlIHJlbGlhYmx5IGRpdmVyc2UgYnV0IGJpZ2dlcjogICBmb3IgKGxldCBqLCB2LCBpID0gYS5sZW5ndGg7IGk7IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKSwgdiA9IGFbLS1pXSwgYVtpXSA9IGFbal0sIGFbal0gPSB2KTsgcmV0dXJuIGE7XG4vL2ZvciBkaXN0cmlidXRpbmcgdmFsdWVzIGFjcm9zcyBhbiBhcnJheS4gQ2FuIGFjY2VwdCBhIG51bWJlciwgYSBmdW5jdGlvbiBvciAobW9zdCBjb21tb25seSkgYSBmdW5jdGlvbiB3aGljaCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHtiYXNlLCBhbW91bnQsIGZyb20sIGVhc2UsIGdyaWQsIGF4aXMsIGxlbmd0aCwgZWFjaH0uIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOiBpbmRleCwgdGFyZ2V0LCBhcnJheS4gUmVjb2duaXplcyB0aGUgZm9sbG93aW5nXG5kaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XG4gIGlmIChfaXNGdW5jdGlvbih2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdmFyIHZhcnMgPSBfaXNPYmplY3QodikgPyB2IDoge1xuICAgIGVhY2g6IHZcbiAgfSxcbiAgICAgIC8vbjoxIGlzIGp1c3QgdG8gaW5kaWNhdGUgdiB3YXMgYSBudW1iZXI7IHdlIGxldmVyYWdlIHRoYXQgbGF0ZXIgdG8gc2V0IHYgYWNjb3JkaW5nIHRvIHRoZSBsZW5ndGggd2UgZ2V0LiBJZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sIHdlIHRyZWF0IGl0IGxpa2UgdGhlIG9sZCBzdGFnZ2VyIHZhbHVlIHdoZXJlIDAuMSwgZm9yIGV4YW1wbGUsIHdvdWxkIG1lYW4gdGhhdCB0aGluZ3Mgd291bGQgYmUgZGlzdHJpYnV0ZWQgd2l0aCAwLjEgYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHJhdGhlciB0aGFuIGEgdG90YWwgXCJhbW91bnRcIiB0aGF0J3MgY2h1bmtlZCBvdXQgYW1vbmcgdGhlbSBhbGwuXG4gIGVhc2UgPSBfcGFyc2VFYXNlKHZhcnMuZWFzZSksXG4gICAgICBmcm9tID0gdmFycy5mcm9tIHx8IDAsXG4gICAgICBiYXNlID0gcGFyc2VGbG9hdCh2YXJzLmJhc2UpIHx8IDAsXG4gICAgICBjYWNoZSA9IHt9LFxuICAgICAgaXNEZWNpbWFsID0gZnJvbSA+IDAgJiYgZnJvbSA8IDEsXG4gICAgICByYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG4gICAgICBheGlzID0gdmFycy5heGlzLFxuICAgICAgcmF0aW9YID0gZnJvbSxcbiAgICAgIHJhdGlvWSA9IGZyb207XG5cbiAgaWYgKF9pc1N0cmluZyhmcm9tKSkge1xuICAgIHJhdGlvWCA9IHJhdGlvWSA9IHtcbiAgICAgIGNlbnRlcjogLjUsXG4gICAgICBlZGdlczogLjUsXG4gICAgICBlbmQ6IDFcbiAgICB9W2Zyb21dIHx8IDA7XG4gIH0gZWxzZSBpZiAoIWlzRGVjaW1hbCAmJiByYXRpb3MpIHtcbiAgICByYXRpb1ggPSBmcm9tWzBdO1xuICAgIHJhdGlvWSA9IGZyb21bMV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xuICAgIHZhciBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuICAgICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSxcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZCxcbiAgICAgICAgaixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIHdyYXBBdDtcblxuICAgIGlmICghZGlzdGFuY2VzKSB7XG4gICAgICB3cmFwQXQgPSB2YXJzLmdyaWQgPT09IFwiYXV0b1wiID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblxuICAgICAgaWYgKCF3cmFwQXQpIHtcbiAgICAgICAgbWF4ID0gLV9iaWdOdW07XG5cbiAgICAgICAgd2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7fVxuXG4gICAgICAgIHdyYXBBdC0tO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZXMgPSBjYWNoZVtsXSA9IFtdO1xuICAgICAgb3JpZ2luWCA9IHJhdGlvcyA/IE1hdGgubWluKHdyYXBBdCwgbCkgKiByYXRpb1ggLSAuNSA6IGZyb20gJSB3cmFwQXQ7XG4gICAgICBvcmlnaW5ZID0gcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogZnJvbSAvIHdyYXBBdCB8IDA7XG4gICAgICBtYXggPSAwO1xuICAgICAgbWluID0gX2JpZ051bTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgIHkgPSBvcmlnaW5ZIC0gKGogLyB3cmFwQXQgfCAwKTtcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcbiAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgIGQgPCBtaW4gJiYgKG1pbiA9IGQpO1xuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZChkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgKHYgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDE7IC8vdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGxpa2UgMjQgKiAwLjEgPT0gMi40MDAwMDAwMDAwMDAwMDA0KSwgd2UgY2hvcCBvZmYgYXQgYSBzcGVjaWZpYyBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG11Y2ggZmFzdGVyIHRoYW4gdG9GaXhlZCgpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcDtcbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcGFyYW1zLFxuICAgICAgc2NvcGU7XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdO1xuICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gIGV4ZWN1dGVMYXp5Rmlyc3QgJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXG4gIHJldHVybiBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gIGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWdbXCJkZWZhdWx0XCJdIHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgfSA6IGNvbmZpZyxcbiAgICAgIC8vaW4gY2FzZSBzb21lb25lIHBhc3NlcyBpbiBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHBsdWdpbiwgbGlrZSBDdXN0b21FYXNlXG4gIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICByZW5kZXI6IF9yZW5kZXJQcm9wVHdlZW5zLFxuICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICBtb2RpZmllcjogX2FkZFBsdWdpbk1vZGlmaWVyLFxuICAgIHJhd1ZhcnM6IDBcbiAgfSxcbiAgICAgIHN0YXRpY3MgPSB7XG4gICAgdGFyZ2V0VGVzdDogMCxcbiAgICBnZXQ6IDAsXG4gICAgZ2V0U2V0dGVyOiBfZ2V0U2V0dGVyLFxuICAgIGFsaWFzZXM6IHt9LFxuICAgIHJlZ2lzdGVyOiAwXG4gIH07XG5cbiAgX3dha2UoKTtcblxuICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdHMoUGx1Z2luLCBfc2V0RGVmYXVsdHMoX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBpbnN0YW5jZURlZmF1bHRzKSwgc3RhdGljcykpOyAvL3N0YXRpYyBtZXRob2RzXG5cblxuICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgIH1cblxuICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgfVxuXG4gIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gIGggPSBoIDwgMCA/IGggKyAxIDogaCA+IDEgPyBoIC0gMSA6IGg7XG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xufSxcbiAgICBzcGxpdENvbG9yID0gZnVuY3Rpb24gc3BsaXRDb2xvcih2LCB0b0hTTCwgZm9yY2VBbHBoYSkge1xuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgcyxcbiAgICAgIGwsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBkLFxuICAgICAgd2FzSFNMO1xuXG4gIGlmICghYSkge1xuICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgYSA9IF9jb2xvckxvb2t1cFt2XTtcbiAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGIgKyAodi5sZW5ndGggPT09IDUgPyB2LmNoYXJBdCg0KSArIHYuY2hhckF0KDQpIDogXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcbiAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgIHJldHVybiBbYSA+PiAxNiwgYSA+PiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgIH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcbiAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgIGggPSArYVswXSAlIDM2MCAvIDM2MDtcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgIGcgPSBsIDw9IC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICBhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXG4gIHA7XG5cbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xufSgpLFxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXG4gICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgIHRvSFNMO1xuICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgdG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl90aWNrZXJBY3RpdmUsXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXG4gICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxuICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgIF9pZCxcbiAgICAgIF9yZXEsXG4gICAgICBfcmFmLFxuICAgICAgX3NlbGYsXG4gICAgICBfZGVsdGEsXG4gICAgICBfaSxcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgZnJhbWU7XG5cbiAgICBlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCAmJiAoX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnKTtcbiAgICBfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuICAgIHRpbWUgPSBfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWU7XG4gICAgb3ZlcmxhcCA9IHRpbWUgLSBfbmV4dFRpbWU7XG5cbiAgICBpZiAob3ZlcmxhcCA+IDAgfHwgbWFudWFsKSB7XG4gICAgICBmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XG4gICAgICBfZGVsdGEgPSB0aW1lIC0gX3NlbGYudGltZSAqIDEwMDA7XG4gICAgICBfc2VsZi50aW1lID0gdGltZSA9IHRpbWUgLyAxMDAwO1xuICAgICAgX25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcbiAgICAgIGRpc3BhdGNoID0gMTtcbiAgICB9XG5cbiAgICBtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgX2xpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgLy8gdXNlIF9pIGFuZCBjaGVjayBfbGlzdGVuZXJzLmxlbmd0aCBpbnN0ZWFkIG9mIGEgdmFyaWFibGUgYmVjYXVzZSBhIGxpc3RlbmVyIGNvdWxkIGdldCByZW1vdmVkIGR1cmluZyB0aGUgbG9vcCwgYW5kIGlmIHRoYXQgaGFwcGVucyB0byBhbiBlbGVtZW50IGxlc3MgdGhhbiB0aGUgY3VycmVudCBpbmRleCwgaXQnZCB0aHJvdyB0aGluZ3Mgb2ZmIGluIHRoZSBsb29wLlxuICAgICAgICBfbGlzdGVuZXJzW19pXSh0aW1lLCBfZGVsdGEsIGZyYW1lLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3NlbGYgPSB7XG4gICAgdGltZTogMCxcbiAgICBmcmFtZTogMCxcbiAgICB0aWNrOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgX3RpY2sodHJ1ZSk7XG4gICAgfSxcbiAgICBkZWx0YVJhdGlvOiBmdW5jdGlvbiBkZWx0YVJhdGlvKGZwcykge1xuICAgICAgcmV0dXJuIF9kZWx0YSAvICgxMDAwIC8gKGZwcyB8fCA2MCkpO1xuICAgIH0sXG4gICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XG4gICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XG4gICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgX2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgIV93aW4uZ3NhcCAmJiBfd2luIHx8IHt9KTtcblxuICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgX25leHRUaW1lIC0gX3NlbGYudGltZSAqIDEwMDAgKyAxIHwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDE7XG5cbiAgICAgICAgX3RpY2soMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzbGVlcDogZnVuY3Rpb24gc2xlZXAoKSB7XG4gICAgICAoX3JhZiA/IF93aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XG4gICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgIH0sXG4gICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxIC8gX3RpbnlOdW07IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXG4gICAgICBfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG4gICAgfSxcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XG4gICAgICBfZ2FwID0gMTAwMCAvIChfZnBzIHx8IDI0MCk7XG4gICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChjYWxsYmFjaykge1xuICAgICAgX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSA8IDAgJiYgX2xpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgX3dha2UoKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIH4oaSA9IF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykpICYmIF9saXN0ZW5lcnMuc3BsaWNlKGksIDEpICYmIF9pID49IGkgJiYgX2ktLTtcbiAgICB9LFxuICAgIF9saXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIF9zZWxmO1xufSgpLFxuICAgIF93YWtlID0gZnVuY3Rpb24gX3dha2UoKSB7XG4gIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbn0sXG4gICAgLy9hbHNvIGVuc3VyZXMgdGhlIGNvcmUgY2xhc3NlcyBhcmUgaW5pdGlhbGl6ZWQuXG5cbi8qXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogRUFTSU5HXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG5fZWFzZU1hcCA9IHt9LFxuICAgIF9jdXN0b21FYXNlRXhwID0gL15bXFxkLlxcLU1dW1xcZC5cXC0sXFxzXS8sXG4gICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgIF9wYXJzZU9iamVjdEluU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT2JqZWN0SW5TdHJpbmcodmFsdWUpIHtcbiAgLy90YWtlcyBhIHN0cmluZyBsaWtlIFwie3dpZ2dsZXM6MTAsIHR5cGU6YW50aWNpcGF0ZX0pXCIgYW5kIHR1cm5zIGl0IGludG8gYSByZWFsIG9iamVjdC4gTm90aWNlIGl0IGVuZHMgaW4gXCIpXCIgYW5kIGluY2x1ZGVzIHRoZSB7fSB3cmFwcGVycy4gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZWFzZSBjb25maWdzIGFuZCBwcmlvcml0aXplZCBvcHRpbWl6YXRpb24gcmF0aGVyIHRoYW4gcmV1c2FiaWxpdHkuXG4gIHZhciBvYmogPSB7fSxcbiAgICAgIHNwbGl0ID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDMpLnNwbGl0KFwiOlwiKSxcbiAgICAgIGtleSA9IHNwbGl0WzBdLFxuICAgICAgaSA9IDEsXG4gICAgICBsID0gc3BsaXQubGVuZ3RoLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWwsXG4gICAgICBwYXJzZWRWYWw7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICBpbmRleCA9IGkgIT09IGwgLSAxID8gdmFsLmxhc3RJbmRleE9mKFwiLFwiKSA6IHZhbC5sZW5ndGg7XG4gICAgcGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XG4gICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICBrZXkgPSB2YWwuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX3ZhbHVlSW5QYXJlbnRoZXNlcyA9IGZ1bmN0aW9uIF92YWx1ZUluUGFyZW50aGVzZXModmFsdWUpIHtcbiAgdmFyIG9wZW4gPSB2YWx1ZS5pbmRleE9mKFwiKFwiKSArIDEsXG4gICAgICBjbG9zZSA9IHZhbHVlLmluZGV4T2YoXCIpXCIpLFxuICAgICAgbmVzdGVkID0gdmFsdWUuaW5kZXhPZihcIihcIiwgb3Blbik7XG4gIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcob3Blbiwgfm5lc3RlZCAmJiBuZXN0ZWQgPCBjbG9zZSA/IHZhbHVlLmluZGV4T2YoXCIpXCIsIGNsb3NlICsgMSkgOiBjbG9zZSk7XG59LFxuICAgIF9jb25maWdFYXNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIF9jb25maWdFYXNlRnJvbVN0cmluZyhuYW1lKSB7XG4gIC8vbmFtZSBjYW4gYmUgYSBzdHJpbmcgbGlrZSBcImVsYXN0aWMub3V0KDEsMC41KVwiLCBhbmQgcGFzcyBpbiBfZWFzZU1hcCBhcyBvYmogYW5kIGl0J2xsIHBhcnNlIGl0IG91dCBhbmQgY2FsbCB0aGUgYWN0dWFsIGZ1bmN0aW9uIGxpa2UgX2Vhc2VNYXAuRWxhc3RpYy5lYXNlT3V0LmNvbmZpZygxLDAuNSkuIEl0IHdpbGwgYWxzbyBwYXJzZSBjdXN0b20gZWFzZSBzdHJpbmdzIGFzIGxvbmcgYXMgQ3VzdG9tRWFzZSBpcyBsb2FkZWQgYW5kIHJlZ2lzdGVyZWQgKGludGVybmFsbHkgYXMgX2Vhc2VNYXAuX0NFKS5cbiAgdmFyIHNwbGl0ID0gKG5hbWUgKyBcIlwiKS5zcGxpdChcIihcIiksXG4gICAgICBlYXNlID0gX2Vhc2VNYXBbc3BsaXRbMF1dO1xuICByZXR1cm4gZWFzZSAmJiBzcGxpdC5sZW5ndGggPiAxICYmIGVhc2UuY29uZmlnID8gZWFzZS5jb25maWcuYXBwbHkobnVsbCwgfm5hbWUuaW5kZXhPZihcIntcIikgPyBbX3BhcnNlT2JqZWN0SW5TdHJpbmcoc3BsaXRbMV0pXSA6IF92YWx1ZUluUGFyZW50aGVzZXMobmFtZSkuc3BsaXQoXCIsXCIpLm1hcChfbnVtZXJpY0lmUG9zc2libGUpKSA6IF9lYXNlTWFwLl9DRSAmJiBfY3VzdG9tRWFzZUV4cC50ZXN0KG5hbWUpID8gX2Vhc2VNYXAuX0NFKFwiXCIsIG5hbWUpIDogZWFzZTtcbn0sXG4gICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZSgxIC0gcCk7XG4gIH07XG59LFxuICAgIC8vIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuXG5fcHJvcGFnYXRlWW95b0Vhc2UgPSBmdW5jdGlvbiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95bykge1xuICB2YXIgY2hpbGQgPSB0aW1lbGluZS5fZmlyc3QsXG4gICAgICBlYXNlO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG4gICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQsIGlzWW95byk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcbiAgICAgIGlmIChjaGlsZC50aW1lbGluZSkge1xuICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UoY2hpbGQudGltZWxpbmUsIGlzWW95byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlID0gY2hpbGQuX2Vhc2U7XG4gICAgICAgIGNoaWxkLl9lYXNlID0gY2hpbGQuX3lFYXNlO1xuICAgICAgICBjaGlsZC5feUVhc2UgPSBlYXNlO1xuICAgICAgICBjaGlsZC5feW95byA9IGlzWW95bztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICB9XG59LFxuICAgIF9wYXJzZUVhc2UgPSBmdW5jdGlvbiBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSB7XG4gIHJldHVybiAhZWFzZSA/IGRlZmF1bHRFYXNlIDogKF9pc0Z1bmN0aW9uKGVhc2UpID8gZWFzZSA6IF9lYXNlTWFwW2Vhc2VdIHx8IF9jb25maWdFYXNlRnJvbVN0cmluZyhlYXNlKSkgfHwgZGVmYXVsdEVhc2U7XG59LFxuICAgIF9pbnNlcnRFYXNlID0gZnVuY3Rpb24gX2luc2VydEVhc2UobmFtZXMsIGVhc2VJbiwgZWFzZU91dCwgZWFzZUluT3V0KSB7XG4gIGlmIChlYXNlT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gMSAtIGVhc2VJbigxIC0gcCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChlYXNlSW5PdXQgPT09IHZvaWQgMCkge1xuICAgIGVhc2VJbk91dCA9IGZ1bmN0aW9uIGVhc2VJbk91dChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlYXNlID0ge1xuICAgIGVhc2VJbjogZWFzZUluLFxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgZWFzZUluT3V0OiBlYXNlSW5PdXRcbiAgfSxcbiAgICAgIGxvd2VyY2FzZU5hbWU7XG5cbiAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9lYXNlTWFwW25hbWVdID0gX2dsb2JhbHNbbmFtZV0gPSBlYXNlO1xuICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCldID0gZWFzZU91dDtcblxuICAgIGZvciAodmFyIHAgaW4gZWFzZSkge1xuICAgICAgX2Vhc2VNYXBbbG93ZXJjYXNlTmFtZSArIChwID09PSBcImVhc2VJblwiID8gXCIuaW5cIiA6IHAgPT09IFwiZWFzZU91dFwiID8gXCIub3V0XCIgOiBcIi5pbk91dFwiKV0gPSBfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyBwXSA9IGVhc2VbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2Vhc2VJbk91dEZyb21PdXQgPSBmdW5jdGlvbiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwIDwgLjUgPyAoMSAtIGVhc2VPdXQoMSAtIHAgKiAyKSkgLyAyIDogLjUgKyBlYXNlT3V0KChwIC0gLjUpICogMikgLyAyO1xuICB9O1xufSxcbiAgICBfY29uZmlnRWxhc3RpYyA9IGZ1bmN0aW9uIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gIHZhciBwMSA9IGFtcGxpdHVkZSA+PSAxID8gYW1wbGl0dWRlIDogMSxcbiAgICAgIC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG4gIHAyID0gKHBlcmlvZCB8fCAodHlwZSA/IC4zIDogLjQ1KSkgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpLFxuICAgICAgcDMgPSBwMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyBwMSkgfHwgMCksXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPT09IDEgPyAxIDogcDEgKiBNYXRoLnBvdygyLCAtMTAgKiBwKSAqIF9zaW4oKHAgLSBwMykgKiBwMikgKyAxO1xuICB9LFxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XG5cbiAgcDIgPSBfMlBJIC8gcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufSxcbiAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xuICBpZiAob3ZlcnNob290ID09PSB2b2lkIDApIHtcbiAgICBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuICB9XG5cbiAgdmFyIGVhc2VPdXQgPSBmdW5jdGlvbiBlYXNlT3V0KHApIHtcbiAgICByZXR1cm4gcCA/IC0tcCAqIHAgKiAoKG92ZXJzaG9vdCArIDEpICogcCArIG92ZXJzaG9vdCkgKyAxIDogMDtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKG92ZXJzaG9vdCkge1xuICAgIHJldHVybiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpO1xuICB9O1xuXG4gIHJldHVybiBlYXNlO1xufTsgLy8gYSBjaGVhcGVyIChrYiBhbmQgY3B1KSBidXQgbW9yZSBtaWxkIHdheSB0byBnZXQgYSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgYnkgZmVlZGluZyBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxuLy8gX3dlaWdodGVkRWFzZSA9IHJhdGlvID0+IHtcbi8vIFx0bGV0IHkgPSAwLjUgKyByYXRpbyAvIDI7XG4vLyBcdHJldHVybiBwID0+ICgyICogKDEgLSBwKSAqIHAgKiB5ICsgcCAqIHApO1xuLy8gfSxcbi8vIGEgc3Ryb25nZXIgKGJ1dCBtb3JlIGV4cGVuc2l2ZSBrYi9jcHUpIHBhcmFtZXRlcml6ZWQgd2VpZ2h0ZWQgZWFzZSB0aGF0IGxldHMgeW91IGZlZWQgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2VTdHJvbmcgPSByYXRpbyA9PiB7XG4vLyBcdHJhdGlvID0gLjUgKyByYXRpbyAvIDI7XG4vLyBcdGxldCBvID0gMSAvIDMgKiAocmF0aW8gPCAuNSA/IHJhdGlvIDogMSAtIHJhdGlvKSxcbi8vIFx0XHRiID0gcmF0aW8gLSBvLFxuLy8gXHRcdGMgPSByYXRpbyArIG87XG4vLyBcdHJldHVybiBwID0+IHAgPT09IDEgPyBwIDogMyAqIGIgKiAoMSAtIHApICogKDEgLSBwKSAqIHAgKyAzICogYyAqICgxIC0gcCkgKiBwICogcCArIHAgKiBwICogcDtcbi8vIH07XG5cblxuX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gIHZhciBwb3dlciA9IGkgPCA1ID8gaSArIDEgOiBpO1xuXG4gIF9pbnNlcnRFYXNlKG5hbWUgKyBcIixQb3dlclwiICsgKHBvd2VyIC0gMSksIGkgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gIH0gOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwO1xuICB9LCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHAsIHBvd2VyKTtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XG4gIH0pO1xufSk7XG5cbl9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuXG5faW5zZXJ0RWFzZShcIkVsYXN0aWNcIiwgX2NvbmZpZ0VsYXN0aWMoXCJpblwiKSwgX2NvbmZpZ0VsYXN0aWMoXCJvdXRcIiksIF9jb25maWdFbGFzdGljKCkpO1xuXG4oZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIG4xID0gMSAvIGMsXG4gICAgICBuMiA9IDIgKiBuMSxcbiAgICAgIG4zID0gMi41ICogbjEsXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPCBuMSA/IG4gKiBwICogcCA6IHAgPCBuMiA/IG4gKiBNYXRoLnBvdyhwIC0gMS41IC8gYywgMikgKyAuNzUgOiBwIDwgbjMgPyBuICogKHAgLT0gMi4yNSAvIGMpICogcCArIC45Mzc1IDogbiAqIE1hdGgucG93KHAgLSAyLjYyNSAvIGMsIDIpICsgLjk4NDM3NTtcbiAgfTtcblxuICBfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0sIGVhc2VPdXQpO1xufSkoNy41NjI1LCAyLjc1KTtcblxuX2luc2VydEVhc2UoXCJFeHBvXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID8gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSA6IDA7XG59KTtcblxuX2luc2VydEVhc2UoXCJDaXJjXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiAtKF9zcXJ0KDEgLSBwICogcCkgLSAxKTtcbn0pO1xuXG5faW5zZXJ0RWFzZShcIlNpbmVcIiwgZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDE7XG59KTtcblxuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcblxuX2Vhc2VNYXAuU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5zdGVwcyA9IF9nbG9iYWxzLlN0ZXBwZWRFYXNlID0ge1xuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcHMgPSAxO1xuICAgIH1cblxuICAgIHZhciBwMSA9IDEgLyBzdGVwcyxcbiAgICAgICAgcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKSxcbiAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICBtYXggPSAxIC0gX3RpbnlOdW07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICB9O1xuICB9XG59O1xuX2RlZmF1bHRzLmVhc2UgPSBfZWFzZU1hcFtcInF1YWQub3V0XCJdO1xuXG5fZm9yRWFjaE5hbWUoXCJvbkNvbXBsZXRlLG9uVXBkYXRlLG9uU3RhcnQsb25SZXBlYXQsb25SZXZlcnNlQ29tcGxldGUsb25JbnRlcnJ1cHRcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDQUNIRVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR1NDYWNoZSA9IGZ1bmN0aW9uIEdTQ2FjaGUodGFyZ2V0LCBoYXJuZXNzKSB7XG4gIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICB0YXJnZXQuX2dzYXAgPSB0aGlzO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgdGhpcy5nZXQgPSBoYXJuZXNzID8gaGFybmVzcy5nZXQgOiBfZ2V0UHJvcGVydHk7XG4gIHRoaXMuc2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0U2V0dGVyIDogX2dldFNldHRlcjtcbn07XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFOSU1BVElPTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5leHBvcnQgdmFyIEFuaW1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbih2YXJzLCB0aW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZTtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuX2RlbGF5ID0gK3ZhcnMuZGVsYXkgfHwgMDtcblxuICAgIGlmICh0aGlzLl9yZXBlYXQgPSB2YXJzLnJlcGVhdCA9PT0gSW5maW5pdHkgPyAtMiA6IHZhcnMucmVwZWF0IHx8IDApIHtcbiAgICAgIC8vIFRPRE86IHJlcGVhdDogSW5maW5pdHkgb24gYSB0aW1lbGluZSdzIGNoaWxkcmVuIG11c3QgZmxhZyB0aGF0IHRpbWVsaW5lIGludGVybmFsbHkgYW5kIGFmZmVjdCBpdHMgdG90YWxEdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHN0b3AgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiB3aGVuIHJlYWNoaW5nIHRoZSBzdGFydC5cbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhcnMucmVwZWF0RGVsYXkgfHwgMDtcbiAgICAgIHRoaXMuX3lveW8gPSAhIXZhcnMueW95byB8fCAhIXZhcnMueW95b0Vhc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fdHMgPSAxO1xuXG4gICAgX3NldER1cmF0aW9uKHRoaXMsICt2YXJzLmR1cmF0aW9uLCAxLCAxKTtcblxuICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcbiAgICBfdGlja2VyQWN0aXZlIHx8IF90aWNrZXIud2FrZSgpO1xuICAgIHBhcmVudCAmJiBfYWRkVG9UaW1lbGluZShwYXJlbnQsIHRoaXMsIHRpbWUgfHwgdGltZSA9PT0gMCA/IHRpbWUgOiBwYXJlbnQuX3RpbWUsIDEpO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgdGhpcy5yZXZlcnNlKCk7XG4gICAgdmFycy5wYXVzZWQgJiYgdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQucGFyZW50Ll90aW1lICE9PSBwYXJlbnQuX3N0YXJ0ICsgKHBhcmVudC5fdHMgPj0gMCA/IHBhcmVudC5fdFRpbWUgLyBwYXJlbnQuX3RzIDogKHBhcmVudC50b3RhbER1cmF0aW9uKCkgLSBwYXJlbnQuX3RUaW1lKSAvIC1wYXJlbnQuX3RzKSkge1xuICAgICAgICAgIHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuX2RwLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiAodGhpcy5fdHMgPiAwICYmIF90b3RhbFRpbWUgPCB0aGlzLl90RHVyIHx8IHRoaXMuX3RzIDwgMCAmJiBfdG90YWxUaW1lID4gMCB8fCAhdGhpcy5fdER1ciAmJiAhX3RvdGFsVGltZSkpIHtcbiAgICAgICAgLy9pZiB0aGUgYW5pbWF0aW9uIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgcHV0IGl0IGJhY2sgaW50byBpdHMgbGFzdCBwYXJlbnQgKHJlY29yZGVkIGFzIF9kcCBmb3IgZXhhY3RseSBjYXNlcyBsaWtlIHRoaXMpLiBMaW1pdCB0byBwYXJlbnRzIHdpdGggYXV0b1JlbW92ZUNoaWxkcmVuIChsaWtlIGdsb2JhbFRpbWVsaW5lKSBzbyB0aGF0IGlmIHRoZSB1c2VyIG1hbnVhbGx5IHJlbW92ZXMgYW4gYW5pbWF0aW9uIGZyb20gYSB0aW1lbGluZSBhbmQgdGhlbiBhbHRlcnMgaXRzIHBsYXloZWFkLCBpdCBkb2Vzbid0IGdldCBhZGRlZCBiYWNrIGluLlxuICAgICAgICBfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSB8fCAhX3RvdGFsVGltZSAmJiAhdGhpcy5faW5pdHRlZCAmJiAodGhpcy5hZGQgfHwgdGhpcy5fcHRMb29rdXApKSB7XG4gICAgICAvLyBjaGVjayBmb3IgX3B0TG9va3VwIG9uIGEgVHdlZW4gaW5zdGFuY2UgdG8gZW5zdXJlIGl0IGhhcyBhY3R1YWxseSBmaW5pc2hlZCBiZWluZyBpbnN0YW50aWF0ZWQsIG90aGVyd2lzZSBpZiB0aGlzLnJldmVyc2UoKSBnZXRzIGNhbGxlZCBpbiB0aGUgQW5pbWF0aW9uIGNvbnN0cnVjdG9yLCBpdCBjb3VsZCB0cmlnZ2VyIGEgcmVuZGVyKCkgaGVyZSBldmVuIHRob3VnaCB0aGUgX3RhcmdldHMgd2VyZW4ndCBwb3B1bGF0ZWQsIHRodXMgd2hlbiBfaW5pdCgpIGlzIGNhbGxlZCB0aGVyZSB3b24ndCBiZSBhbnkgUHJvcFR3ZWVucyAoaXQnbGwgYWN0IGxpa2UgdGhlIHR3ZWVuIGlzIG5vbi1mdW5jdGlvbmFsKVxuICAgICAgdGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gX3RvdGFsVGltZSk7IC8vIG90aGVyd2lzZSwgaWYgYW4gYW5pbWF0aW9uIGlzIHBhdXNlZCwgdGhlbiB0aGUgcGxheWhlYWQgaXMgbW92ZWQgYmFjayB0byB6ZXJvLCB0aGVuIHJlc3VtZWQsIGl0J2QgcmV2ZXJ0IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRpbWUgYXQgdGhlIHBhdXNlXG4gICAgICAvL2lmICghdGhpcy5fbG9jaykgeyAvLyBhdm9pZCBlbmRsZXNzIHJlY3Vyc2lvbiAobm90IHN1cmUgd2UgbmVlZCB0aGlzIHlldCBvciBpZiBpdCdzIHdvcnRoIHRoZSBwZXJmb3JtYW5jZSBoaXQpXG4gICAgICAvLyAgIHRoaXMuX2xvY2sgPSAxO1xuXG4gICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpOyAvLyAgIHRoaXMuX2xvY2sgPSAwO1xuICAgICAgLy99XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udGltZSA9IGZ1bmN0aW9uIHRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZShNYXRoLm1pbih0aGlzLnRvdGFsRHVyYXRpb24oKSwgdmFsdWUgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcykpICUgdGhpcy5fZHVyIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIHByaW9yaXRpemUgcmVuZGVyaW5nIHdoZXJlIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBsaW5lcyB1cCBpbnN0ZWFkIG9mIHRoaXMuX3RUaW1lIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgYSB0d2VlbiB0aGF0J3MgYW5pbWF0aW5nIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGxvb3AgKHNhbWUgcGFyZW50KSwgdGh1cyBpZiB0aGUgdGltZVNjYWxlIHR3ZWVuIHJlbmRlcnMgZmlyc3QsIGl0IHdvdWxkIGFsdGVyIF9zdGFydCBCRUZPUkUgX3RUaW1lIHdhcyBzZXQgb24gdGhhdCB0aWNrIChpbiB0aGUgcmVuZGVyaW5nIGxvb3ApLCBlZmZlY3RpdmVseSBmcmVlemluZyBpdCB1bnRpbCB0aGUgdGltZVNjYWxlIHR3ZWVuIGZpbmlzaGVzLlxuXG4gICAgdGhpcy5fcnRzID0gK3ZhbHVlIHx8IDA7XG4gICAgdGhpcy5fdHMgPSB0aGlzLl9wcyB8fCB2YWx1ZSA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSB3aGljaCB3b3VsZCBiZSAwIGlmIHRoZSBhbmltYXRpb24gaXMgcGF1c2VkLlxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSkpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkgJiYgTWF0aC5hYnModGhpcy5felRpbWUpICE9PSBfdGlueU51bSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3VGltZSA9IGZ1bmN0aW9uIHJhd1RpbWUod3JhcFJlcGVhdHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7IC8vIF9kcCA9IGRldGF0Y2hlZCBwYXJlbnRcblxuICAgIHJldHVybiAhcGFyZW50ID8gdGhpcy5fdFRpbWUgOiB3cmFwUmVwZWF0cyAmJiAoIXRoaXMuX3RzIHx8IHRoaXMuX3JlcGVhdCAmJiB0aGlzLl90aW1lICYmIHRoaXMudG90YWxQcm9ncmVzcygpIDwgMSkgPyB0aGlzLl90VGltZSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIDogIXRoaXMuX3RzID8gdGhpcy5fdFRpbWUgOiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnQucmF3VGltZSh3cmFwUmVwZWF0cyksIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMsXG4gICAgICAgIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID8gcmF3VGltZSA6IGFuaW1hdGlvbi5yYXdUaW1lKCk7XG5cbiAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICB0aW1lID0gYW5pbWF0aW9uLl9zdGFydCArIHRpbWUgLyAoYW5pbWF0aW9uLl90cyB8fCAxKTtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5fZHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yZXBlYXQgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAtMiA6IHZhbHVlO1xuICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlcGVhdCA9PT0gLTIgPyBJbmZpbml0eSA6IHRoaXMuX3JlcGVhdDtcbiAgfTtcblxuICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yRGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl95b3lvO1xuICB9O1xuXG4gIF9wcm90by5zZWVrID0gZnVuY3Rpb24gc2Vlayhwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICB9O1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuICAgIHJldHVybiB0aGlzLnJldmVyc2VkKHRydWUpLnBhdXNlZChmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGF0VGltZSAhPSBudWxsICYmIHRoaXMuc2VlayhhdFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZXZlcnNlZCA9IGZ1bmN0aW9uIHJldmVyc2VkKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3J0cyA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xuICAgIHRoaXMuX3pUaW1lID0gLV90aW55TnVtO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgcmF3VGltZTtcbiAgICByZXR1cm4gISEoIXBhcmVudCB8fCB0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICB2YXIgdmFycyA9IHRoaXMudmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBkZWxldGUgdmFyc1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgcGFyYW1zICYmICh2YXJzW3R5cGUgKyBcIlBhcmFtc1wiXSA9IHBhcmFtcyk7XG4gICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICB9O1xuXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG4gICAgICAgICAgX3Jlc29sdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgICAgICAgdmFyIF90aGVuID0gc2VsZi50aGVuO1xuICAgICAgICBzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcblxuICAgICAgICBfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcbiAgICAgICAgcmVzb2x2ZShmKTtcbiAgICAgICAgc2VsZi50aGVuID0gX3RoZW47XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2VsZi5faW5pdHRlZCAmJiBzZWxmLnRvdGFsUHJvZ3Jlc3MoKSA9PT0gMSAmJiBzZWxmLl90cyA+PSAwIHx8ICFzZWxmLl90VGltZSAmJiBzZWxmLl90cyA8IDApIHtcbiAgICAgICAgX3Jlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3Byb20gPSBfcmVzb2x2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2ludGVycnVwdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0aW9uO1xufSgpO1xuXG5fc2V0RGVmYXVsdHMoQW5pbWF0aW9uLnByb3RvdHlwZSwge1xuICBfdGltZTogMCxcbiAgX3N0YXJ0OiAwLFxuICBfZW5kOiAwLFxuICBfdFRpbWU6IDAsXG4gIF90RHVyOiAwLFxuICBfZGlydHk6IDAsXG4gIF9yZXBlYXQ6IDAsXG4gIF95b3lvOiBmYWxzZSxcbiAgcGFyZW50OiBudWxsLFxuICBfaW5pdHRlZDogZmFsc2UsXG4gIF9yRGVsYXk6IDAsXG4gIF90czogMSxcbiAgX2RwOiAwLFxuICByYXRpbzogMCxcbiAgX3pUaW1lOiAtX3RpbnlOdW0sXG4gIF9wcm9tOiAwLFxuICBfcHM6IGZhbHNlLFxuICBfcnRzOiAxXG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSU1FTElORVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUaW1lbGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbikge1xuICBfaW5oZXJpdHNMb29zZShUaW1lbGluZSwgX0FuaW1hdGlvbik7XG5cbiAgZnVuY3Rpb24gVGltZWxpbmUodmFycywgdGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzLCB0aW1lKSB8fCB0aGlzO1xuICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xuICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgX3RoaXMucGFyZW50ICYmIF9wb3N0QWRkQ2hlY2tzKF90aGlzLnBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHZhcnMuc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFycy5zY3JvbGxUcmlnZ2VyKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFRpbWVsaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDAsIHRoaXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBfaXNOdW1iZXIodmFycykgPyBhcmd1bWVudHNbM10gOiBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgX3BhcnNlVmFycyhhcmd1bWVudHMsIDEsIHRoaXMpLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBfaXNOdW1iZXIodmFycykgPyBhcmd1bWVudHNbM10gOiBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAyLCB0aGlzKSwgX3BhcnNlUG9zaXRpb24odGhpcywgX2lzTnVtYmVyKGZyb21WYXJzKSA/IGFyZ3VtZW50c1s0XSA6IHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfSAvL09OTFkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkhIE1heWJlIGRlbGV0ZT9cbiAgO1xuXG4gIF9wcm90bzIuc3RhZ2dlclRvID0gZnVuY3Rpb24gc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcbiAgICB2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuICAgIHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XG4gICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB2YXJzLnJ1bkJhY2t3YXJkcyA9IDE7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICB0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuICAgIF9pbmhlcml0RGVmYXVsdHModG9WYXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICB9O1xuXG4gIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRvdGFsVGltZSA+IHREdXIgLSBfdGlueU51bSAmJiB0b3RhbFRpbWUgPj0gMCA/IHREdXIgOiB0b3RhbFRpbWUgPCBfdGlueU51bSA/IDAgOiB0b3RhbFRpbWUsXG4gICAgICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgIHRpbWVTY2FsZSxcbiAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICB5b3lvLFxuICAgICAgICBpc1lveW87XG5cbiAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiBkdXIpIHtcbiAgICAgICAgLy9pZiB0b3RhbER1cmF0aW9uKCkgZmluZHMgYSBjaGlsZCB3aXRoIGEgbmVnYXRpdmUgc3RhcnRUaW1lIGFuZCBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCB0aGluZ3MgZ2V0IHNoaWZ0ZWQgYXJvdW5kIGludGVybmFsbHkgc28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHRpbWUgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiBhIHR3ZWVuIHN0YXJ0cyBhdCAtMzAgd2UgbXVzdCBzaGlmdCBFVkVSWVRISU5HIGZvcndhcmQgMzAgc2Vjb25kcyBhbmQgbW92ZSB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIGJhY2t3YXJkIGJ5IDMwIHNlY29uZHMgc28gdGhhdCB0aGluZ3MgYWxpZ24gd2l0aCB0aGUgcGxheWhlYWQgKG5vIGp1bXApLlxuICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICAgIHRvdGFsVGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgIHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XG4gICAgICBwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblxuICAgICAgaWYgKGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgICAgZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAvL2FkanVzdCB0aGUgdGltZSBmb3IgcmVwZWF0cyBhbmQgeW95b3NcbiAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmQodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZChpdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uKSksIHN1cHByZXNzRXZlbnRzLCAhZHVyKS5fbG9jayA9IDA7XG4gICAgICAgICAgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmQocHJldlRpbWUpLCBfcm91bmQodGltZSkpO1xuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XG4gICAgICAgICAgdFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICAgIHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG4gICAgICAgIHRoaXMuX2luaXR0ZWQgPSAxO1xuICAgICAgICB0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcbiAgICAgICAgcHJldlRpbWUgPSAwOyAvLyB1cG9uIGluaXQsIHRoZSBwbGF5aGVhZCBzaG91bGQgYWx3YXlzIGdvIGZvcndhcmQ7IHNvbWVvbmUgY291bGQgaW52YWxpZGF0ZSgpIGEgY29tcGxldGVkIHRpbWVsaW5lIGFuZCB0aGVuIGlmIHRoZXkgcmVzdGFydCgpLCB0aGF0IHdvdWxkIG1ha2UgY2hpbGQgdHdlZW5zIHJlbmRlciBpbiByZXZlcnNlIG9yZGVyIHdoaWNoIGNvdWxkIGxvY2sgaW4gdGhlIHdyb25nIHN0YXJ0aW5nIHZhbHVlcyBpZiB0aGV5IGJ1aWxkIG9uIGVhY2ggb3RoZXIsIGxpa2UgdGwudG8ob2JqLCB7eDogMTAwfSkudG8ob2JqLCB7eDogMH0pLlxuICAgICAgfVxuXG4gICAgICAhcHJldlRpbWUgJiYgKHRpbWUgfHwgIWR1ciAmJiB0b3RhbFRpbWUgPj0gMCkgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgIGlmICh0aW1lID49IHByZXZUaW1lICYmIHRvdGFsVGltZSA+PSAwKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IHRpbWUgPj0gY2hpbGQuX3N0YXJ0KSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/ICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgICAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG4gICAgICAgICAgICAgIHBhdXNlVHdlZW4gPSAwO1xuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IC1fdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBmbGFnIHpUaW1lIGFzIG5lZ2F0aXZlIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9sYXN0O1xuICAgICAgICB2YXIgYWRqdXN0ZWRUaW1lID0gdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWU7IC8vd2hlbiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoaXMgdGltZWxpbmUsIHdlIG11c3QgcGFzcyB0aGF0IGluZm9ybWF0aW9uIGRvd24gdG8gdGhlIGNoaWxkIGFuaW1hdGlvbnMgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBrbm93IHdoZXRoZXIgdG8gcmVuZGVyIHRoZWlyIHN0YXJ0aW5nIG9yIGVuZGluZyB2YWx1ZXMuXG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9wcmV2O1xuXG4gICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IGFkanVzdGVkVGltZSA8PSBjaGlsZC5fZW5kKSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/IChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArIChhZGp1c3RlZFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBhZGp1c3QgelRpbWUgc28gdGhhdCBzbyB0aGF0IHRoZSBuZXh0IHRpbWUgcmVuZGVyKCkgaXMgY2FsbGVkIGl0J2xsIGJlIGZvcmNlZCAodG8gcmVuZGVyIGFueSByZW1haW5pbmcgY2hpbGRyZW4pXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXVzZVR3ZWVuICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHBhdXNlVHdlZW4ucmVuZGVyKHRpbWUgPj0gcHJldlRpbWUgPyAwIDogLV90aW55TnVtKS5felRpbWUgPSB0aW1lID49IHByZXZUaW1lID8gMSA6IC0xO1xuXG4gICAgICAgIGlmICh0aGlzLl90cykge1xuICAgICAgICAgIC8vdGhlIGNhbGxiYWNrIHJlc3VtZWQgcGxheWJhY2shIFNvIHNpbmNlIHdlIG1heSBoYXZlIGhlbGQgYmFjayB0aGUgcGxheWhlYWQgZHVlIHRvIHdoZXJlIHRoZSBwYXVzZSBpcyBwb3NpdGlvbmVkLCBnbyBhaGVhZCBhbmQganVtcCB0byB3aGVyZSBpdCdzIFNVUFBPU0VEIHRvIGJlIChpZiBubyBwYXVzZSBoYXBwZW5lZCkuXG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7IC8vaWYgdGhlIHBhdXNlIHdhcyBhdCBhbiBlYXJsaWVyIHRpbWUgYW5kIHRoZSB1c2VyIHJlc3VtZWQgaW4gdGhlIGNhbGxiYWNrLCBpdCBjb3VsZCByZXBvc2l0aW9uIHRoZSB0aW1lbGluZSAoY2hhbmdpbmcgaXRzIHN0YXJ0VGltZSksIHRocm93aW5nIHRoaW5ncyBvZmYgc2xpZ2h0bHksIHNvIHdlIG1ha2Ugc3VyZSB0aGUgX3N0YXJ0IGRvZXNuJ3Qgc2hpZnQuXG5cbiAgICAgICAgICBfc2V0RW5kKHRoaXMpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIiwgdHJ1ZSk7XG4gICAgICBpZiAodFRpbWUgPT09IHREdXIgJiYgdER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSB8fCAhdFRpbWUgJiYgcHJldlRpbWUpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0IHx8IE1hdGguYWJzKHRpbWVTY2FsZSkgIT09IE1hdGguYWJzKHRoaXMuX3RzKSkgaWYgKCF0aGlzLl9sb2NrKSB7XG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG5cbiAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcbiAgICAgIGlmIChfaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGQob2JqLCBwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGFiZWwoY2hpbGQsIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICBjaGlsZCA9IFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzICE9PSBjaGlsZCA/IF9hZGRUb1RpbWVsaW5lKHRoaXMsIGNoaWxkLCBwb3NpdGlvbikgOiB0aGlzOyAvL2Rvbid0IGFsbG93IGEgdGltZWxpbmUgdG8gYmUgYWRkZWQgdG8gaXRzZWxmIGFzIGEgY2hpbGQhXG4gIH07XG5cbiAgX3Byb3RvMi5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgIG5lc3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR3ZWVucyA9PT0gdm9pZCAwKSB7XG4gICAgICB0d2VlbnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aW1lbGluZXMgPT09IHZvaWQgMCkge1xuICAgICAgdGltZWxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZ25vcmVCZWZvcmVUaW1lID0gLV9iaWdOdW07XG4gICAgfVxuXG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG4gICAgICAgICAgdHdlZW5zICYmIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZWxpbmVzICYmIGEucHVzaChjaGlsZCk7XG4gICAgICAgICAgbmVzdGVkICYmIGEucHVzaC5hcHBseShhLCBjaGlsZC5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5nZXRDaGlsZHJlbigxLCAxLCAxKSxcbiAgICAgICAgaSA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGFuaW1hdGlvbnNbaV0udmFycy5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5raWxsVHdlZW5zT2YoY2hpbGQpO1xuICAgIH1cblxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBjaGlsZCk7XG5cbiAgICBpZiAoY2hpbGQgPT09IHRoaXMuX3JlY2VudCkge1xuICAgICAgdGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5fZm9yY2luZyA9IDE7XG5cbiAgICBpZiAoIXRoaXMuX2RwICYmIHRoaXMuX3RzKSB7XG4gICAgICAvL3NwZWNpYWwgY2FzZSBmb3IgdGhlIGdsb2JhbCB0aW1lbGluZSAob3IgYW55IG90aGVyIHRoYXQgaGFzIG5vIHBhcmVudCBvciBkZXRhY2hlZCBwYXJlbnQpLlxuICAgICAgdGhpcy5fc3RhcnQgPSBfcm91bmQoX3RpY2tlci50aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUyIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSBfdG90YWxUaW1lMikgLyAtdGhpcy5fdHMpKTtcbiAgICB9XG5cbiAgICBfQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuY2FsbCh0aGlzLCBfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpO1xuXG4gICAgdGhpcy5fZm9yY2luZyA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuICAgIHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24gcmVtb3ZlTGFiZWwobGFiZWwpIHtcbiAgICBkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB0ID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2sgfHwgX2VtcHR5RnVuYywgcGFyYW1zKTtcbiAgICB0LmRhdGEgPSBcImlzUGF1c2VcIjtcbiAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIHQsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uIHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSxcbiAgICAgICAgaSA9IHR3ZWVucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiAhPT0gdHdlZW5zW2ldICYmIHR3ZWVuc1tpXS5raWxsKHRhcmdldHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmdldFR3ZWVuc09mID0gZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBpc0dsb2JhbFRpbWUgPSBfaXNOdW1iZXIob25seUFjdGl2ZSksXG4gICAgICAgIC8vIGEgbnVtYmVyIGlzIGludGVycHJldGVkIGFzIGEgZ2xvYmFsIHRpbWUuIElmIHRoZSBhbmltYXRpb24gc3BhbnNcbiAgICBjaGlsZHJlbjtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgaWYgKF9hcnJheUNvbnRhaW5zQW55KGNoaWxkLl90YXJnZXRzLCBwYXJzZWRUYXJnZXRzKSAmJiAoaXNHbG9iYWxUaW1lID8gKCFfb3ZlcndyaXRpbmdUd2VlbiB8fCBjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHtcbiAgICAgICAgICAvLyBub3RlOiBpZiB0aGlzIGlzIGZvciBvdmVyd3JpdGluZywgaXQgc2hvdWxkIG9ubHkgYmUgZm9yIHR3ZWVucyB0aGF0IGFyZW4ndCBwYXVzZWQgYW5kIGFyZSBpbml0dGVkLlxuICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGNoaWxkcmVuID0gY2hpbGQuZ2V0VHdlZW5zT2YocGFyc2VkVGFyZ2V0cywgb25seUFjdGl2ZSkpLmxlbmd0aCkge1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIHRhcmdldHMoKSBvbiB0aW1lbGluZXNcbiAgLy8gdGFyZ2V0cygpIHtcbiAgLy8gXHRsZXQgcmVzdWx0ID0gW107XG4gIC8vIFx0dGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaCh0ID0+IHJlc3VsdC5wdXNoKC4uLnQudGFyZ2V0cygpKSk7XG4gIC8vIFx0cmV0dXJuIHJlc3VsdDtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvMi50d2VlblRvID0gZnVuY3Rpb24gdHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgIF9vblN0YXJ0ID0gX3ZhcnMub25TdGFydCxcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF92YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcbiAgICAgIGVhc2U6IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIHRsLl90aW1lKSAvIHRsLnRpbWVTY2FsZSgpKTtcbiAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgX29uU3RhcnQgJiYgX29uU3RhcnQuYXBwbHkodHdlZW4sIG9uU3RhcnRQYXJhbXMgfHwgW10pOyAvL2luIGNhc2UgdGhlIHVzZXIgaGFkIGFuIG9uU3RhcnQgaW4gdGhlIHZhcnMgLSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBpdC5cbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG5cbiAgICByZXR1cm4gaW1tZWRpYXRlUmVuZGVyID8gdHdlZW4ucmVuZGVyKDApIDogdHdlZW47XG4gIH07XG5cbiAgX3Byb3RvMi50d2VlbkZyb21UbyA9IGZ1bmN0aW9uIHR3ZWVuRnJvbVRvKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuICAgIHJldHVybiB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgX3NldERlZmF1bHRzKHtcbiAgICAgIHN0YXJ0QXQ6IHtcbiAgICAgICAgdGltZTogX3BhcnNlUG9zaXRpb24odGhpcywgZnJvbVBvc2l0aW9uKVxuICAgICAgfVxuICAgIH0sIHZhcnMpKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlY2VudCA9IGZ1bmN0aW9uIHJlY2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjZW50O1xuICB9O1xuXG4gIF9wcm90bzIubmV4dExhYmVsID0gZnVuY3Rpb24gbmV4dExhYmVsKGFmdGVyVGltZSkge1xuICAgIGlmIChhZnRlclRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgYWZ0ZXJUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYWZ0ZXJUaW1lKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5wcmV2aW91c0xhYmVsID0gZnVuY3Rpb24gcHJldmlvdXNMYWJlbChiZWZvcmVUaW1lKSB7XG4gICAgaWYgKGJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgYmVmb3JlVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGJlZm9yZVRpbWUpLCAxKTtcbiAgfTtcblxuICBfcHJvdG8yLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uIGN1cnJlbnRMYWJlbCh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zZWVrKHZhbHVlLCB0cnVlKSA6IHRoaXMucHJldmlvdXNMYWJlbCh0aGlzLl90aW1lICsgX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90bzIuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uIHNoaWZ0Q2hpbGRyZW4oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZ25vcmVCZWZvcmVUaW1lID0gMDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgbGFiZWxzID0gdGhpcy5sYWJlbHMsXG4gICAgICAgIHA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBjaGlsZC5fc3RhcnQgKz0gYW1vdW50O1xuICAgICAgICBjaGlsZC5fZW5kICs9IGFtb3VudDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICBpZiAoYWRqdXN0TGFiZWxzKSB7XG4gICAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgICAgIGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICAgIGxhYmVsc1twXSArPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgY2hpbGQuaW52YWxpZGF0ZSgpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gX0FuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgaWYgKGluY2x1ZGVMYWJlbHMgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZUxhYmVscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIG5leHQ7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9kcCAmJiAodGhpcy5fdGltZSA9IHRoaXMuX3RUaW1lID0gdGhpcy5fcFRpbWUgPSAwKTtcbiAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIHZhciBtYXggPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICBwcmV2U3RhcnQgPSBfYmlnTnVtLFxuICAgICAgICBwcmV2LFxuICAgICAgICBzdGFydCxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLl9kaXJ0eSkge1xuICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBwcmV2ID0gY2hpbGQuX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblxuICAgICAgICBjaGlsZC5fZGlydHkgJiYgY2hpbGQudG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xuXG4gICAgICAgIGlmIChzdGFydCA+IHByZXZTdGFydCAmJiBzZWxmLl9zb3J0ICYmIGNoaWxkLl90cyAmJiAhc2VsZi5fbG9jaykge1xuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcbiAgICAgICAgICBzZWxmLl9sb2NrID0gMTsgLy9wcmV2ZW50IGVuZGxlc3MgcmVjdXJzaXZlIGNhbGxzIC0gdGhlcmUgYXJlIG1ldGhvZHMgdGhhdCBnZXQgdHJpZ2dlcmVkIHRoYXQgY2hlY2sgZHVyYXRpb24vdG90YWxEdXJhdGlvbiB3aGVuIHdlIGFkZCgpLlxuXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGNoaWxkLl90cykge1xuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG4gICAgICAgICAgbWF4IC09IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICBzZWxmLl90aW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XG4gICAgICAgICAgcHJldlN0YXJ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLl9lbmQgPiBtYXggJiYgY2hpbGQuX3RzICYmIChtYXggPSBjaGlsZC5fZW5kKTtcbiAgICAgICAgY2hpbGQgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICBfc2V0RHVyYXRpb24oc2VsZiwgc2VsZiA9PT0gX2dsb2JhbFRpbWVsaW5lICYmIHNlbGYuX3RpbWUgPiBtYXggPyBzZWxmLl90aW1lIDogbWF4LCAxLCAxKTtcblxuICAgICAgc2VsZi5fZGlydHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLl90RHVyO1xuICB9O1xuXG4gIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICBpZiAoX2dsb2JhbFRpbWVsaW5lLl90cykge1xuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XG5cbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7XG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgdmFyIGNoaWxkID0gX2dsb2JhbFRpbWVsaW5lLl9maXJzdDtcbiAgICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLl90cykgaWYgKF9jb25maWcuYXV0b1NsZWVwICYmIF90aWNrZXIuX2xpc3RlbmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gIF9sb2NrOiAwLFxuICBfaGFzUGF1c2U6IDAsXG4gIF9mb3JjaW5nOiAwXG59KTtcblxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgdmFyIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAxLCBfcmVuZGVyQ29tcGxleFN0cmluZywgbnVsbCwgc2V0dGVyKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnROdW1zLFxuICAgICAgY29sb3IsXG4gICAgICBlbmROdW0sXG4gICAgICBjaHVuayxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgaGFzUmFuZG9tLFxuICAgICAgYTtcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoaGFzUmFuZG9tID0gfmVuZC5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gIH1cblxuICBpZiAoc3RyaW5nRmlsdGVyKSB7XG4gICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICBzdHJpbmdGaWx0ZXIoYSwgdGFyZ2V0LCBwcm9wKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLlxuXG4gICAgc3RhcnQgPSBhWzBdO1xuICAgIGVuZCA9IGFbMV07XG4gIH1cblxuICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xuICAgIGVuZE51bSA9IHJlc3VsdFswXTtcbiAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICBjb2xvciA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbbWF0Y2hJbmRleCAtIDFdKSB8fCAwOyAvL3RoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cbiAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KGVuZE51bS5zdWJzdHIoMikpICogKGVuZE51bS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgZW5kID0gcGFyc2VGbG9hdChwYXJzZWRTdGFydCkgKyBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpICogKGVuZC5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VkU3RhcnQgIT09IGVuZCkge1xuICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpKSB7XG4gICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICB9XG5cbiAgICAhY3VycmVudFZhbHVlICYmICEocHJvcCBpbiB0YXJnZXQpICYmIF9taXNzaW5nUGx1Z2luKHByb3AsIGVuZCk7XG4gICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgfVxufSxcbiAgICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gIF9pc0Z1bmN0aW9uKHZhcnMpICYmICh2YXJzID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gIH1cblxuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgdmFyIHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXG4gIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICBpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG4gICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldOyAvL25vdGU6IHdlIGNhbid0IHVzZSB0d2Vlbi5fcHRMb29rdXBbaW5kZXhdIGJlY2F1c2UgZm9yIHN0YWdnZXJlZCB0d2VlbnMsIHRoZSBpbmRleCBmcm9tIHRoZSBmdWxsVGFyZ2V0cyBhcnJheSB3b24ndCBtYXRjaCB3aGF0IGl0IGlzIGluIGVhY2ggaW5kaXZpZHVhbCB0d2VlbiB0aGF0IHNwYXducyBmcm9tIHRoZSBzdGFnZ2VyLlxuXG4gICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSxcbiAgICBfb3ZlcndyaXRpbmdUd2VlbixcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXG5faW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSkge1xuICB2YXIgdmFycyA9IHR3ZWVuLnZhcnMsXG4gICAgICBlYXNlID0gdmFycy5lYXNlLFxuICAgICAgc3RhcnRBdCA9IHZhcnMuc3RhcnRBdCxcbiAgICAgIGltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgbGF6eSA9IHZhcnMubGF6eSxcbiAgICAgIG9uVXBkYXRlID0gdmFycy5vblVwZGF0ZSxcbiAgICAgIG9uVXBkYXRlUGFyYW1zID0gdmFycy5vblVwZGF0ZVBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGUgPSB2YXJzLmNhbGxiYWNrU2NvcGUsXG4gICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgIHlveW9FYXNlID0gdmFycy55b3lvRWFzZSxcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgIGR1ciA9IHR3ZWVuLl9kdXIsXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgcGFyZW50ID0gdHdlZW4ucGFyZW50LFxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQucGFyZW50Ll90YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIiAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIHRsID0gdHdlZW4udGltZWxpbmUsXG4gICAgICBjbGVhblZhcnMsXG4gICAgICBpLFxuICAgICAgcCxcbiAgICAgIHB0LFxuICAgICAgdGFyZ2V0LFxuICAgICAgaGFzUHJpb3JpdHksXG4gICAgICBnc0RhdGEsXG4gICAgICBoYXJuZXNzLFxuICAgICAgcGx1Z2luLFxuICAgICAgcHRMb29rdXAsXG4gICAgICBpbmRleCxcbiAgICAgIGhhcm5lc3NWYXJzLFxuICAgICAgb3ZlcndyaXR0ZW47XG4gIHRsICYmICgha2V5ZnJhbWVzIHx8ICFlYXNlKSAmJiAoZWFzZSA9IFwibm9uZVwiKTtcbiAgdHdlZW4uX2Vhc2UgPSBfcGFyc2VFYXNlKGVhc2UsIF9kZWZhdWx0cy5lYXNlKTtcbiAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblxuICBpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHtcbiAgICAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cbiAgICB5b3lvRWFzZSA9IHR3ZWVuLl95RWFzZTtcbiAgICB0d2Vlbi5feUVhc2UgPSB0d2Vlbi5fZWFzZTtcbiAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuICB9XG5cbiAgaWYgKCF0bCkge1xuICAgIC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxuICAgIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuICAgIGhhcm5lc3NWYXJzID0gaGFybmVzcyAmJiB2YXJzW2hhcm5lc3MucHJvcF07IC8vc29tZW9uZSBtYXkgbmVlZCB0byBzcGVjaWZ5IENTUy1zcGVjaWZpYyB2YWx1ZXMgQU5EIG5vbi1DU1MgdmFsdWVzLCBsaWtlIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBcInhcIiBwcm9wZXJ0eSBwbHVzIGl0J3MgYSBzdGFuZGFyZCBET00gZWxlbWVudC4gV2UgYWxsb3cgcGVvcGxlIHRvIGRpc3Rpbmd1aXNoIGJ5IHdyYXBwaW5nIHBsdWdpbi1zcGVjaWZpYyBzdHVmZiBpbiBhIGNzczp7fSBvYmplY3QgZm9yIGV4YW1wbGUuXG5cbiAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG4gICAgcHJldlN0YXJ0QXQgJiYgcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKS5raWxsKCk7XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6IF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGU6IGNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHN0YWdnZXI6IDBcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblxuXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgICAgIGF1dG9SZXZlcnQgfHwgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICAgICAgICB9IGVsc2UgaWYgKGR1ciAmJiAhKHRpbWUgPCAwICYmIHByZXZTdGFydEF0KSkge1xuICAgICAgICAgIHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuICAgICAgICAgIHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnVuQmFja3dhcmRzICYmIGR1cikge1xuICAgICAgLy9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuICAgICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICAgICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgIC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IGltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG4gICAgICAgICAgc3RhZ2dlcjogMCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCAvL2Vuc3VyZXMgdGhhdCBuZXN0ZWQgdHdlZW5zIHRoYXQgaGFkIGEgc3RhZ2dlciBhcmUgaGFuZGxlZCBwcm9wZXJseSwgbGlrZSBnc2FwLmZyb20oXCIuY2xhc3NcIiwge3k6Z3NhcC51dGlscy53cmFwKFstMTAwLDEwMF0pfSlcblxuICAgICAgICB9LCBjbGVhblZhcnMpO1xuICAgICAgICBoYXJuZXNzVmFycyAmJiAocFtoYXJuZXNzLnByb3BdID0gaGFybmVzc1ZhcnMpOyAvLyBpbiBjYXNlIHNvbWVvbmUgZG9lcyBzb21ldGhpbmcgbGlrZSAuZnJvbSguLi4sIHtjc3M6e319KVxuXG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIHApKTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2Vlbi5fcHQgPSAwO1xuICAgIGxhenkgPSBkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkgfHwgbGF6eSAmJiAhZHVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICBnc0RhdGEgPSB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModGFyZ2V0cylbaV0uX2dzYXA7XG4gICAgICB0d2Vlbi5fcHRMb29rdXBbaV0gPSBwdExvb2t1cCA9IHt9O1xuICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblxuICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgIGlmIChoYXJuZXNzICYmIChwbHVnaW4gPSBuZXcgaGFybmVzcygpKS5pbml0KHRhcmdldCwgaGFybmVzc1ZhcnMgfHwgY2xlYW5WYXJzLCB0d2VlbiwgaW5kZXgsIGZ1bGxUYXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwbHVnaW4ubmFtZSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHB0TG9va3VwW25hbWVdID0gcHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXJuZXNzIHx8IGhhcm5lc3NWYXJzKSB7XG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IF9jaGVja1BsdWdpbihwLCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCBmdWxsVGFyZ2V0cykpKSB7XG4gICAgICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB0TG9va3VwW3BdID0gcHQgPSBfYWRkUHJvcFR3ZWVuLmNhbGwodHdlZW4sIHRhcmdldCwgcCwgXCJnZXRcIiwgY2xlYW5WYXJzW3BdLCBpbmRleCwgZnVsbFRhcmdldHMsIDAsIHZhcnMuc3RyaW5nRmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcblxuICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XG5cbiAgICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXQsIHB0TG9va3VwLCB0d2Vlbi5nbG9iYWxUaW1lKDApKTsgLy9BbHNvIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxuXG5cbiAgICAgICAgb3ZlcndyaXR0ZW4gPSAhdHdlZW4ucGFyZW50O1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHR3ZWVuLl9wdCAmJiBsYXp5ICYmIChfbGF6eUxvb2t1cFtnc0RhdGEuaWRdID0gMSk7XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgdHdlZW4uX29uSW5pdCAmJiB0d2Vlbi5fb25Jbml0KHR3ZWVuKTsgLy9wbHVnaW5zIGxpa2UgUm91bmRQcm9wcyBtdXN0IHdhaXQgdW50aWwgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIGFyZSBpbnN0YW50aWF0ZWQuIEluIHRoZSBwbHVnaW4ncyBpbml0KCkgZnVuY3Rpb24sIGl0IHNldHMgdGhlIF9vbkluaXQgb24gdGhlIHR3ZWVuIGluc3RhbmNlLiBNYXkgbm90IGJlIHByZXR0eS9pbnR1aXRpdmUsIGJ1dCBpdCdzIGZhc3QgYW5kIGtlZXBzIGZpbGUgc2l6ZSBkb3duLlxuICB9XG5cbiAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXG5cbiAgdHdlZW4uX29uVXBkYXRlID0gb25VcGRhdGU7XG4gIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47IC8vIGlmIG92ZXJ3cml0dGVuUHJvcHMgcmVzdWx0ZWQgaW4gdGhlIGVudGlyZSB0d2VlbiBiZWluZyBraWxsZWQsIGRvIE5PVCBmbGFnIGl0IGFzIGluaXR0ZWQgb3IgZWxzZSBpdCBtYXkgcmVuZGVyIGZvciBvbmUgdGljay5cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfcGFyc2VGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VGdW5jT3JTdHJpbmcodmFsdWUsIHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xufSxcbiAgICBfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZVwiLFxuICAgIF9zdGFnZ2VyUHJvcHNUb1NraXAgPSAoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiKS5zcGxpdChcIixcIik7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHdlZW4sIF9BbmltYXRpb24yKTtcblxuICBmdW5jdGlvbiBUd2Vlbih0YXJnZXRzLCB2YXJzLCB0aW1lLCBza2lwSW5oZXJpdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRpbWUuZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHRpbWU7XG4gICAgICB0aW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycyksIHRpbWUpIHx8IHRoaXM7XG4gICAgdmFyIF90aGlzMyR2YXJzID0gX3RoaXMzLnZhcnMsXG4gICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF90aGlzMyR2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcbiAgICAgICAga2V5ZnJhbWVzID0gX3RoaXMzJHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcbiAgICAgICAgeW95b0Vhc2UgPSBfdGhpczMkdmFycy55b3lvRWFzZSxcbiAgICAgICAgcGFyZW50ID0gX3RoaXMzLnBhcmVudCxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IChfaXNBcnJheSh0YXJnZXRzKSB8fCBfaXNUeXBlZEFycmF5KHRhcmdldHMpID8gX2lzTnVtYmVyKHRhcmdldHNbMF0pIDogXCJsZW5ndGhcIiBpbiB2YXJzKSA/IFt0YXJnZXRzXSA6IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIHRsLFxuICAgICAgICBpLFxuICAgICAgICBjb3B5LFxuICAgICAgICBsLFxuICAgICAgICBwLFxuICAgICAgICBjdXJUYXJnZXQsXG4gICAgICAgIHN0YWdnZXJGdW5jLFxuICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2U7XG4gICAgX3RoaXMzLl90YXJnZXRzID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGggPyBfaGFybmVzcyhwYXJzZWRUYXJnZXRzKSA6IF93YXJuKFwiR1NBUCB0YXJnZXQgXCIgKyB0YXJnZXRzICsgXCIgbm90IGZvdW5kLiBodHRwczovL2dyZWVuc29jay5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xuICAgIF90aGlzMy5fcHRMb29rdXAgPSBbXTsgLy9Qcm9wVHdlZW4gbG9va3VwLiBBbiBhcnJheSBjb250YWluaW5nIGFuIG9iamVjdCBmb3IgZWFjaCB0YXJnZXQsIGhhdmluZyBrZXlzIGZvciBlYWNoIHR3ZWVuaW5nIHByb3BlcnR5XG5cbiAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblxuICAgIGlmIChrZXlmcmFtZXMgfHwgc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgIHZhcnMgPSBfdGhpczMudmFycztcbiAgICAgIHRsID0gX3RoaXMzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgICAgICAgZGF0YTogXCJuZXN0ZWRcIixcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9XG4gICAgICB9KTtcbiAgICAgIHRsLmtpbGwoKTtcbiAgICAgIHRsLnBhcmVudCA9IHRsLl9kcCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcbiAgICAgIHRsLl9zdGFydCA9IDA7XG5cbiAgICAgIGlmIChrZXlmcmFtZXMpIHtcbiAgICAgICAgX3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtcbiAgICAgICAgICBlYXNlOiBcIm5vbmVcIlxuICAgICAgICB9KTtcblxuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG4gICAgICAgIHN0YWdnZXJGdW5jID0gc3RhZ2dlciA/IGRpc3RyaWJ1dGUoc3RhZ2dlcikgOiBfZW1wdHlGdW5jO1xuXG4gICAgICAgIGlmIChfaXNPYmplY3Qoc3RhZ2dlcikpIHtcbiAgICAgICAgICAvL3VzZXJzIGNhbiBwYXNzIGluIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQvb25Db21wbGV0ZSBpbiB0aGUgc3RhZ2dlciBvYmplY3QuIFRoZXNlIHNob3VsZCBmaXJlIHdpdGggZWFjaCBpbmRpdmlkdWFsIHR3ZWVuLlxuICAgICAgICAgIGZvciAocCBpbiBzdGFnZ2VyKSB7XG4gICAgICAgICAgICBpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgaWYgKF9zdGFnZ2VyUHJvcHNUb1NraXAuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHZhcnNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29weS5zdGFnZ2VyID0gMDtcbiAgICAgICAgICB5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcbiAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG4gICAgICAgICAgY3VyVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1tpXTsgLy9kb24ndCBqdXN0IGNvcHkgZHVyYXRpb24gb3IgZGVsYXkgYmVjYXVzZSBpZiB0aGV5J3JlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLCB3ZSdkIGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGJlY2F1c2UgX2lzRnVuY09yU3RyaW5nKCkgd291bGQgZXZhbHVhdGUgYXMgdHJ1ZSBpbiB0aGUgY2hpbGQgdHdlZW5zLCBlbnRlcmluZyB0aGlzIGxvb3AsIGV0Yy4gU28gd2UgcGFyc2UgdGhlIHZhbHVlIHN0cmFpZ2h0IGZyb20gdmFycyBhbmQgZGVmYXVsdCB0byAwLlxuXG4gICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcbiAgICAgICAgICBjb3B5LmRlbGF5ID0gKCtfcGFyc2VGdW5jT3JTdHJpbmcoZGVsYXksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSB8fCAwKSAtIF90aGlzMy5fZGVsYXk7XG5cbiAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGRvZXMgZGVsYXk6XCJyYW5kb20oMSwgNSlcIiwgcmVwZWF0Oi0xLCBmb3IgZXhhbXBsZSwgdGhlIGRlbGF5IHNob3VsZG4ndCBiZSBpbnNpZGUgdGhlIHJlcGVhdC5cbiAgICAgICAgICAgIF90aGlzMy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG4gICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xuICAgICAgICAgICAgY29weS5kZWxheSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7IC8vIGlmIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIGlzIDAsIHdlIGRvbid0IG5lZWQgYSB0aW1lbGluZSBpbnRlcm5hbGx5IVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgcGFyZW50ICYmIF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKTtcblxuICAgIGlmIChpbW1lZGlhdGVSZW5kZXIgfHwgIWR1cmF0aW9uICYmICFrZXlmcmFtZXMgJiYgX3RoaXMzLl9zdGFydCA9PT0gX3JvdW5kKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNZb3lvID0gdGhpcy5feW95byAmJiBpdGVyYXRpb24gJiAxO1xuXG4gICAgICAgIGlmIChpc1lveW8pIHtcbiAgICAgICAgICB5b3lvRWFzZSA9IHRoaXMuX3lFYXNlO1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kKGN5Y2xlRHVyYXRpb24gKiBpdGVyYXRpb24pLCB0cnVlKS5pbnZhbGlkYXRlKCkuX2xvY2sgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgaWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSAwOyAvLyBpbiBjb25zdHJ1Y3RvciBpZiBpbW1lZGlhdGVSZW5kZXIgaXMgdHJ1ZSwgd2Ugc2V0IF90VGltZSB0byAtX3RpbnlOdW0gdG8gaGF2ZSB0aGUgcGxheWhlYWQgY3Jvc3MgdGhlIHN0YXJ0aW5nIHBvaW50IGJ1dCB3ZSBjYW4ndCBsZWF2ZSBfdFRpbWUgYXMgYSBuZWdhdGl2ZSBudW1iZXIuXG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICB0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogcmF0aW8sIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwZWF0ICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lKSkge1xuICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGFuZCB0VGltZSBhcmUgemVybywgd2Ugc2hvdWxkbid0IGZpcmUgdGhlIG9uUmV2ZXJzZUNvbXBsZXRlLiBUaGlzIGNvdWxkIGhhcHBlbiBpZiB5b3UgZ3NhcC50byguLi4ge3BhdXNlZDp0cnVlfSkucGxheSgpO1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzMudGFyZ2V0cyA9IGZ1bmN0aW9uIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gIH07XG5cbiAgX3Byb3RvMy5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gdGhpcy5fbGF6eSA9IHRoaXMucmF0aW8gPSAwO1xuICAgIHRoaXMuX3B0TG9va3VwID0gW107XG4gICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHMgJiYgKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gX2ludGVycnVwdCh0aGlzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgIHZhciB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG4gICAgICB0aGlzLnRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCB2YXJzLCBfb3ZlcndyaXRpbmdUd2VlbiAmJiBfb3ZlcndyaXRpbmdUd2Vlbi52YXJzLm92ZXJ3cml0ZSAhPT0gdHJ1ZSkuX2ZpcnN0IHx8IF9pbnRlcnJ1cHQodGhpcyk7IC8vIGlmIG5vdGhpbmcgaXMgbGVmdCB0d2VlbmluZywgaW50ZXJydXB0LlxuXG4gICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAga2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG4gICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgIG92ZXJ3cml0dGVuUHJvcHMsXG4gICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgaTtcblxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH1cblxuICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgaWYgKHZhcnMgIT09IFwiYWxsXCIpIHtcbiAgICAgIC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFycyA9IHA7XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICB9XG5cbiAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnM7XG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCBfcGFyc2VWYXJzKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIF9wYXJzZVZhcnMoYXJndW1lbnRzLCAyKSk7XG4gIH07XG5cbiAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gIH07XG5cbiAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICB9O1xuXG4gIHJldHVybiBUd2Vlbjtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFR3ZWVuLnByb3RvdHlwZSwge1xuICBfdGFyZ2V0czogW10sXG4gIF9sYXp5OiAwLFxuICBfc3RhcnRBdDogMCxcbiAgX29wOiAwLFxuICBfb25Jbml0OiAwXG59KTsgLy9hZGQgdGhlIHBlcnRpbmVudCB0aW1lbGluZSBtZXRob2RzIHRvIFR3ZWVuIGluc3RhbmNlcyBzbyB0aGF0IHVzZXJzIGNhbiBjaGFpbiBjb252ZW5pZW50bHkgYW5kIGNyZWF0ZSBhIHRpbWVsaW5lIGF1dG9tYXRpY2FsbHkuIChyZW1vdmVkIGR1ZSB0byBjb25jZXJucyB0aGF0IGl0J2QgdWx0aW1hdGVseSBhZGQgdG8gbW9yZSBjb25mdXNpb24gZXNwZWNpYWxseSBmb3IgYmVnaW5uZXJzKVxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xuLy8gXHRUd2Vlbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbi8vIFx0XHRsZXQgdGwgPSBuZXcgVGltZWxpbmUoKTtcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xuLy8gXHR9XG4vLyB9KTtcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cblxuXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICB9O1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFBST1BUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbnZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSh2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0oZGF0YS5mcCwgdmFsdWUpO1xufSxcbiAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgdmFsdWUpO1xufSxcbiAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih0YXJnZXRbcHJvcGVydHldKSA/IF9zZXR0ZXJGdW5jIDogX2lzVW5kZWZpbmVkKHRhcmdldFtwcm9wZXJ0eV0pICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUgPyBfc2V0dGVyQXR0cmlidXRlIDogX3NldHRlclBsYWluO1xufSxcbiAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgcyA9IFwiXCI7XG5cbiAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuYjtcbiAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAvL2UgPSBlbmRpbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG4gIH1cblxuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcywgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxufSxcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgIHB0ID0gbmV4dDtcbiAgfVxufSxcbiAgICBfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uIF9raWxsUHJvcFR3ZWVuc09mKHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG59LFxuICAgIF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2V0dGVyV2l0aE1vZGlmaWVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xufSxcbiAgICBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5ID0gZnVuY3Rpb24gX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eShwYXJlbnQpIHtcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgIG5leHQsXG4gICAgICBwdDIsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3Q7IC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgd2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpIHtcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0ID0gcHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICBwdDIuX3ByZXYgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHB0O1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHBhcmVudC5fcHQgPSBmaXJzdDtcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXG5cblxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICB0aGlzLnMgPSBzdGFydDtcbiAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgdGhpcy5wID0gcHJvcDtcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG4gICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0Ll9wcmV2ID0gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFByb3BUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXG4gICAgdGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblxuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgfTtcblxuICByZXR1cm4gUHJvcFR3ZWVuO1xufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXG5cbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbn0pO1xuXG5fZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuX2dsb2JhbHMuVGltZWxpbmVMaXRlID0gX2dsb2JhbHMuVGltZWxpbmVNYXggPSBUaW1lbGluZTtcbl9nbG9iYWxUaW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gIHNvcnRDaGlsZHJlbjogZmFsc2UsXG4gIGRlZmF1bHRzOiBfZGVmYXVsdHMsXG4gIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSxcbiAgaWQ6IFwicm9vdFwiLFxuICBzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZVxufSk7XG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogR1NBUFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgX2dzYXAgPSB7XG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVsaW5lKHZhcnMpO1xuICB9LFxuICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSk7XG4gIH0sXG4gIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgX2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KVswXSk7IC8vaW4gY2FzZSBzZWxlY3RvciB0ZXh0IG9yIGFuIGFycmF5IGlzIHBhc3NlZCBpblxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIHVuaXQgPT09IFwibmF0aXZlXCIgJiYgKHVuaXQgPSBcIlwiKTtcbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGFuIGFsaWFzLCBsaWtlIFwicm90YXRlXCIgZm9yIFwicm90YXRpb25cIi5cbiAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ID0gMDtcbiAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgIHAucmVuZGVyKDEsIHApO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcbiAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG4gICAgfTtcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYyKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMi5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMi5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYyLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYyLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG1hcFJhbmdlOiBtYXBSYW5nZSxcbiAgICBwaXBlOiBwaXBlLFxuICAgIHVuaXRpemU6IHVuaXRpemUsXG4gICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgIHNodWZmbGU6IHNodWZmbGVcbiAgfSxcbiAgaW5zdGFsbDogX2luc3RhbGwsXG4gIGVmZmVjdHM6IF9lZmZlY3RzLFxuICB0aWNrZXI6IF90aWNrZXIsXG4gIHVwZGF0ZVJvb3Q6IFRpbWVsaW5lLnVwZGF0ZVJvb3QsXG4gIHBsdWdpbnM6IF9wbHVnaW5zLFxuICBnbG9iYWxUaW1lbGluZTogX2dsb2JhbFRpbWVsaW5lLFxuICBjb3JlOiB7XG4gICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgZ2xvYmFsczogX2FkZEdsb2JhbCxcbiAgICBUd2VlbjogVHdlZW4sXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgIGdldENhY2hlOiBfZ2V0Q2FjaGUsXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXG4gICAgc3VwcHJlc3NPdmVyd3JpdGVzOiBmdW5jdGlvbiBzdXBwcmVzc092ZXJ3cml0ZXModmFsdWUpIHtcbiAgICAgIHJldHVybiBfc3VwcHJlc3NPdmVyd3JpdGVzID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG5fZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxkZWxheWVkQ2FsbCxzZXQsa2lsbFR3ZWVuc09mXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfZ3NhcFtuYW1lXSA9IFR3ZWVuW25hbWVdO1xufSk7XG5cbl90aWNrZXIuYWRkKFRpbWVsaW5lLnVwZGF0ZVJvb3QpO1xuXG5fcXVpY2tUd2VlbiA9IF9nc2FwLnRvKHt9LCB7XG4gIGR1cmF0aW9uOiAwXG59KTsgLy8gLS0tLSBFWFRSQSBQTFVHSU5TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBfZ2V0UGx1Z2luUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2dldFBsdWdpblByb3BUd2VlbihwbHVnaW4sIHByb3ApIHtcbiAgdmFyIHB0ID0gcGx1Z2luLl9wdDtcblxuICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcCAmJiBwdC5vcCAhPT0gcHJvcCAmJiBwdC5mcCAhPT0gcHJvcCkge1xuICAgIHB0ID0gcHQuX25leHQ7XG4gIH1cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRNb2RpZmllcnMgPSBmdW5jdGlvbiBfYWRkTW9kaWZpZXJzKHR3ZWVuLCBtb2RpZmllcnMpIHtcbiAgdmFyIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgcHQ7XG5cbiAgZm9yIChwIGluIG1vZGlmaWVycykge1xuICAgIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xuXG4gICAgICBpZiAocHQgJiYgKHB0ID0gcHQuZCkpIHtcbiAgICAgICAgaWYgKHB0Ll9wdCkge1xuICAgICAgICAgIC8vIGlzIGEgcGx1Z2luXG4gICAgICAgICAgcHQgPSBfZ2V0UGx1Z2luUHJvcFR3ZWVuKHB0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0ICYmIHB0Lm1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyc1twXSwgdHdlZW4sIHRhcmdldHNbaV0sIHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfYnVpbGRNb2RpZmllclBsdWdpbiA9IGZ1bmN0aW9uIF9idWlsZE1vZGlmaWVyUGx1Z2luKG5hbWUsIG1vZGlmaWVyKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdWYXJzOiAxLFxuICAgIC8vZG9uJ3QgcHJlLXByb2Nlc3MgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG9yIFwicmFuZG9tKClcIiBzdHJpbmdzLlxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgICAgdHdlZW4uX29uSW5pdCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICB2YXIgdGVtcCwgcDtcblxuICAgICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcFtuYW1lXSA9IDE7XG4gICAgICAgICAgfSk7IC8vaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdG8gcm91bmRQcm9wcywgbGlrZSBcIngseVwiLCB3ZSByb3VuZCB0byB3aG9sZSBudW1iZXJzLlxuXG5cbiAgICAgICAgICB2YXJzID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICB0ZW1wW3BdID0gbW9kaWZpZXIodmFyc1twXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBfYWRkTW9kaWZpZXJzKHR3ZWVuLCB2YXJzKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTsgLy9yZWdpc3RlciBjb3JlIHBsdWdpbnNcblxuXG5leHBvcnQgdmFyIGdzYXAgPSBfZ3NhcC5yZWdpc3RlclBsdWdpbih7XG4gIG5hbWU6IFwiYXR0clwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHAsIHB0O1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgIHB0ICYmIChwdC5vcCA9IHApO1xuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiBcImVuZEFycmF5XCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5hZGQodGFyZ2V0LCBpLCB0YXJnZXRbaV0gfHwgMCwgdmFsdWVbaV0pO1xuICAgIH1cbiAgfVxufSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJyb3VuZFByb3BzXCIsIF9yb3VuZE1vZGlmaWVyKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJtb2RpZmllcnNcIiksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwic25hcFwiLCBzbmFwKSkgfHwgX2dzYXA7IC8vdG8gcHJldmVudCB0aGUgY29yZSBwbHVnaW5zIGZyb20gYmVpbmcgZHJvcHBlZCB2aWEgYWdncmVzc2l2ZSB0cmVlIHNoYWtpbmcsIHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBpbiB0aGlzIHdheS5cblxuVHdlZW4udmVyc2lvbiA9IFRpbWVsaW5lLnZlcnNpb24gPSBnc2FwLnZlcnNpb24gPSBcIjMuNi4wXCI7XG5fY29yZVJlYWR5ID0gMTtcblxuaWYgKF93aW5kb3dFeGlzdHMoKSkge1xuICBfd2FrZSgpO1xufVxuXG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSB9OyAvL2V4cG9ydCBzb21lIGludGVybmFsIG1ldGhvZHMvb3JvamVjdHMgZm9yIHVzZSBpbiBDU1NQbHVnaW4gc28gdGhhdCB3ZSBjYW4gZXh0ZXJuYWxpemUgdGhhdCBmaWxlIGFuZCBhbGxvdyBjdXN0b20gYnVpbGRzIHRoYXQgZXhjbHVkZSBpdC5cblxuZXhwb3J0IHsgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfcmVwbGFjZVJhbmRvbSwgX2NoZWNrUGx1Z2luLCBfcGx1Z2lucywgX3RpY2tlciwgX2NvbmZpZywgX3JvdW5kTW9kaWZpZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSB9OyIsImltcG9ydCB7IGdzYXAsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgVHdlZW5MaXRlLCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4IH0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5pbXBvcnQgeyBDU1NQbHVnaW4gfSBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxuICAgIC8vIHRvIHByb3RlY3QgZnJvbSB0cmVlIHNoYWtpbmdcblR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBDU1NQbHVnaW4sIFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25maWcgPSB7XG4gICAgREVCVUc6IGZhbHNlLFxuICAgIExJQl9WRVJTSU9OOiAnMi40MS4wJ1xufTtcblxuLy8gc2luY2UgZXM2IGltcG9ydHMgYXJlIHN0YXRpYyBhbmQgd2UgcnVuIHVuaXQgdGVzdHMgZnJvbSB0aGUgY29uc29sZSwgd2luZG93IHdvbid0IGJlIGRlZmluZWQgd2hlbiBpbXBvcnRpbmcgdGhpcyBmaWxlXG52YXIgd2luZG93JDE7XG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGxvYyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcnXG4gICAgfTtcbiAgICB3aW5kb3ckMSA9IHtcbiAgICAgICAgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogJycgfSxcbiAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgICAgICByZWZlcnJlcjogJydcbiAgICAgICAgfSxcbiAgICAgICAgc2NyZWVuOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgbG9jYXRpb246IGxvY1xuICAgIH07XG59IGVsc2Uge1xuICAgIHdpbmRvdyQxID0gd2luZG93O1xufVxuXG4vKlxuICogU2F2ZWQgcmVmZXJlbmNlcyB0byBsb25nIHZhcmlhYmxlIG5hbWVzLCBzbyB0aGF0IGNsb3N1cmUgY29tcGlsZXIgY2FuXG4gKiBtaW5pbWl6ZSBmaWxlIHNpemUuXG4gKi9cblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG52YXIgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xudmFyIHdpbmRvd0NvbnNvbGUgPSB3aW5kb3ckMS5jb25zb2xlO1xudmFyIG5hdmlnYXRvciQxID0gd2luZG93JDEubmF2aWdhdG9yO1xudmFyIGRvY3VtZW50JDEgPSB3aW5kb3ckMS5kb2N1bWVudDtcbnZhciB3aW5kb3dPcGVyYSA9IHdpbmRvdyQxLm9wZXJhO1xudmFyIHNjcmVlbiA9IHdpbmRvdyQxLnNjcmVlbjtcbnZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IkMS51c2VyQWdlbnQ7XG52YXIgbmF0aXZlQmluZCA9IEZ1bmNQcm90by5iaW5kO1xudmFyIG5hdGl2ZUZvckVhY2ggPSBBcnJheVByb3RvLmZvckVhY2g7XG52YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZjtcbnZhciBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcDtcbnZhciBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBicmVha2VyID0ge307XG52YXIgXyA9IHtcbiAgICB0cmltOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0jUG9seWZpbGxcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgIH1cbn07XG5cbi8vIENvbnNvbGUgb3ZlcnJpZGVcbnZhciBjb25zb2xlID0ge1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2coYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICB3YXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgd2FybmluZzonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4uYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2FybihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGNyaXRpY2FsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nX2Z1bmNfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihmdW5jLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9ICdbJyArIHByZWZpeCArICddICcgKyBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07XG52YXIgY29uc29sZV93aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvZzogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZS5sb2csIHByZWZpeCksXG4gICAgICAgIGVycm9yOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlLmVycm9yLCBwcmVmaXgpLFxuICAgICAgICBjcml0aWNhbDogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZS5jcml0aWNhbCwgcHJlZml4KVxuICAgIH07XG59O1xuXG5cbi8vIFVOREVSU0NPUkVcbi8vIEVtYmVkIHBhcnQgb2YgdGhlIFVuZGVyc2NvcmUgTGlicmFyeVxuXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0ge307XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICAgIHZhciBzZWxmID0gbmV3IGN0b3IoKTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG5fLmJpbmRfaW5zdGFuY2VfbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAodmFyIGZ1bmMgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Yob2JqW2Z1bmNdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqW2Z1bmNdID0gXy5iaW5kKG9ialtmdW5jXSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopPX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICovXG5fLmVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5lc2NhcGVIVE1MID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBlc2NhcGVkID0gcztcbiAgICBpZiAoZXNjYXBlZCAmJiBfLmlzU3RyaW5nKGVzY2FwZWQpKSB7XG4gICAgICAgIGVzY2FwZWQgPSBlc2NhcGVkXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cbl8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZnJvbSBhIGNvbW1lbnQgb24gaHR0cDovL2Riai5vcmcvZGJqLz9wPTI4NlxuLy8gZmFpbHMgb24gb25seSBvbmUgdmVyeSByYXJlIGFuZCBkZWxpYmVyYXRlIGN1c3RvbSBvYmplY3Q6XG4vLyB2YXIgYm9tYiA9IHsgdG9TdHJpbmcgOiB1bmRlZmluZWQsIHZhbHVlT2Y6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFwiZnVuY3Rpb24gQk9NQkEhXCI7IH19O1xuXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAvXlxccypcXGJmdW5jdGlvblxcYi8udGVzdChmKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5fLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NhbGxlZScpKTtcbn07XG5cbl8udG9BcnJheSA9IGZ1bmN0aW9uKGl0ZXJhYmxlKSB7XG4gICAgaWYgKCFpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZS50b0FycmF5KSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS50b0FycmF5KCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF8udmFsdWVzKGl0ZXJhYmxlKTtcbn07XG5cbl8ubWFwID0gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVNYXAgJiYgYXJyLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfLmVhY2goYXJyLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY2FsbGJhY2suY2FsbChjb250ZXh0LCBpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59O1xuXG5fLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSBrZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgKGZvdW5kID0gKHZhbHVlID09PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJyZWFrZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG5fLmluY2x1ZGVzID0gZnVuY3Rpb24oc3RyLCBuZWVkbGUpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG59O1xuXG4vLyBVbmRlcnNjb3JlIEFkZG9uc1xuXy5pbmhlcml0ID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgc3VwZXJjbGFzcygpO1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzO1xuICAgIHN1YmNsYXNzLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIChvYmogPT09IE9iamVjdChvYmopICYmICFfLmlzQXJyYXkob2JqKSk7XG59O1xuXG5fLmlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbn07XG5cbl8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxuXy5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbl8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxuXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59O1xuXG5fLmVuY29kZURhdGVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc0RhdGUodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZm9ybWF0RGF0ZSh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmVuY29kZURhdGVzKHYpOyAvLyByZWN1cnNlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXy50aW1lc3RhbXAgPSBmdW5jdGlvbigpIHtcbiAgICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG59O1xuXG5fLmZvcm1hdERhdGUgPSBmdW5jdGlvbihkKSB7XG4gICAgLy8gWVlZWS1NTS1ERFRISDpNTTpTUyBpbiBVVENcbiAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XG4gICAgfVxuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgK1xuICAgICAgICBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKTtcbn07XG5cbl8uc2FmZXdyYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5jcml0aWNhbCgnSW1wbGVtZW50YXRpb24gZXJyb3IuIFBsZWFzZSB0dXJuIG9uIGRlYnVnIGFuZCBjb250YWN0IHN1cHBvcnRAbWl4cGFuZWwuY29tLicpO1xuICAgICAgICAgICAgaWYgKENvbmZpZy5ERUJVRyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5jcml0aWNhbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5fLnNhZmV3cmFwX2NsYXNzID0gZnVuY3Rpb24oa2xhc3MsIGZ1bmN0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZVtmdW5jdGlvbnNbaV1dID0gXy5zYWZld3JhcChrbGFzcy5wcm90b3R5cGVbZnVuY3Rpb25zW2ldXSk7XG4gICAgfVxufTtcblxuXy5zYWZld3JhcF9pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgZnVuYyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZihvYmpbZnVuY10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmpbZnVuY10gPSBfLnNhZmV3cmFwKG9ialtmdW5jXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5fLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIF8uZWFjaChwLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHYpICYmIHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0W2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKlxuICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY29weSBvZiBvYmplY3QgYWZ0ZXIgdHJ1bmNhdGluZyBpdC4gIElmXG4gKiBwYXNzZWQgYW4gQXJyYXkgb3IgT2JqZWN0IGl0IHdpbGwgaXRlcmF0ZSB0aHJvdWdoIG9iaiBhbmRcbiAqIHRydW5jYXRlIGFsbCB0aGUgdmFsdWVzIHJlY3Vyc2l2ZWx5LlxuICovXG5fLnRydW5jYXRlID0gZnVuY3Rpb24ob2JqLCBsZW5ndGgpIHtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXQgPSBvYmouc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0ID0ge307XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbl8uSlNPTkVuY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obWl4ZWRfdmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1peGVkX3ZhbDtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICAgICAgdmFyIG1ldGEgPSB7IC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID9cbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RyID0gZnVuY3Rpb24oa2V5LCBob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciBnYXAgPSAnJztcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSAnICAgICc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7IC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgICAgICB2YXIgayA9ICcnOyAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgICAgIHZhciB2ID0gJyc7IC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicmFja2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICdbXFxuJyArIGdhcCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG4gICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ30nIDogJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgICAgIHJldHVybiBzdHIoJycsIHtcbiAgICAgICAgICAgICcnOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuICogU2xpZ2h0bHkgbW9kaWZpZWQgdG8gdGhyb3cgYSByZWFsIEVycm9yIHJhdGhlciB0aGFuIGEgUE9KT1xuICovXG5fLkpTT05EZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgZXNjYXBlZSA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgICAgICcvJzogJy8nLFxuICAgICAgICAgICAgJ2InOiAnXFxiJyxcbiAgICAgICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICAgICAnbic6ICdcXG4nLFxuICAgICAgICAgICAgJ3InOiAnXFxyJyxcbiAgICAgICAgICAgICd0JzogJ1xcdCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgZXJyb3IgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBTeW50YXhFcnJvcihtKTtcbiAgICAgICAgICAgIGUuYXQgPSBhdDtcbiAgICAgICAgICAgIGUudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCBcXCcnICsgYyArICdcXCcgaW5zdGVhZCBvZiBcXCcnICsgY2ggKyAnXFwnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignQmFkIG51bWJlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIHN0cmluZycpO1xuICAgICAgICB9LFxuICAgICAgICB3aGl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd29yZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCBcIicgKyBjaCArICdcIicpO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSwgLy8gUGxhY2Vob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cbiAgICAgICAgYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7IC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIGFycmF5Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7IC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBvYmplY3QnKTtcbiAgICAgICAgfTtcblxuICAgIHZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsXG4gICAgICAgIC8vIGEgbnVtYmVyLCBvciBhIHdvcmQuXG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZVxuICAgIC8vIGFib3ZlIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB0ZXh0ID0gc291cmNlO1xuICAgICAgICBhdCA9IDA7XG4gICAgICAgIGNoID0gJyAnO1xuICAgICAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdTeW50YXggZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5cbl8uYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gJycsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhID0gXy51dGY4RW5jb2RlKGRhdGEpO1xuXG4gICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICAgIG8xID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgYml0cyA9IG8xIDw8IDE2IHwgbzIgPDwgOCB8IG8zO1xuXG4gICAgICAgIGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG4gICAgICAgIGgyID0gYml0cyA+PiAxMiAmIDB4M2Y7XG4gICAgICAgIGgzID0gYml0cyA+PiA2ICYgMHgzZjtcbiAgICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gYjY0LmNoYXJBdChoMSkgKyBiNjQuY2hhckF0KGgyKSArIGI2NC5jaGFyQXQoaDMpICsgYjY0LmNoYXJBdChoNCk7XG4gICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoICUgMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTIpICsgJz09JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTEpICsgJz0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYztcbn07XG5cbl8udXRmOEVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IChzdHJpbmcgKyAnJykucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuXG4gICAgdmFyIHV0ZnRleHQgPSAnJyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZDtcbiAgICB2YXIgc3RyaW5nbCA9IDAsXG4gICAgICAgIG47XG5cbiAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgc3RyaW5nbDsgbisrKSB7XG4gICAgICAgIHZhciBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICB2YXIgZW5jID0gbnVsbDtcblxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9IGVsc2UgaWYgKChjMSA+IDEyNykgJiYgKGMxIDwgMjA0OCkpIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDYpIHwgMTkyLCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gMTIpIHwgMjI0LCAoKGMxID4+IDYpICYgNjMpIHwgMTI4LCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0ZnRleHQgKz0gZW5jO1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQgPSBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIHN0cmluZy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGZ0ZXh0O1xufTtcblxuXy5VVUlEID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVGltZS90aWNrcyBpbmZvcm1hdGlvblxuICAgIC8vIDEqbmV3IERhdGUoKSBpcyBhIGNyb3NzIGJyb3dzZXIgdmVyc2lvbiBvZiBEYXRlLm5vdygpXG4gICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGQgPSAxICogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIC8vIHRoaXMgd2hpbGUgbG9vcCBmaWd1cmVzIGhvdyBtYW55IGJyb3dzZXIgdGlja3MgZ28gYnlcbiAgICAgICAgLy8gYmVmb3JlIDEqbmV3IERhdGUoKSByZXR1cm5zIGEgbmV3IG51bWJlciwgaWUgdGhlIGFtb3VudFxuICAgICAgICAvLyBvZiB0aWNrcyB0aGF0IGdvIGJ5IHBlciBtaWxsaXNlY29uZFxuICAgICAgICB3aGlsZSAoZCA9PSAxICogbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQudG9TdHJpbmcoMTYpICsgaS50b1N0cmluZygxNik7XG4gICAgfTtcblxuICAgIC8vIE1hdGguUmFuZG9tIGVudHJvcHlcbiAgICB2YXIgUiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikucmVwbGFjZSgnLicsICcnKTtcbiAgICB9O1xuXG4gICAgLy8gVXNlciBhZ2VudCBlbnRyb3B5XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgdXNlciBhZ2VudCBzdHJpbmcsIGFuZCB0aGVuIHhvcnNcbiAgICAvLyB0b2dldGhlciBlYWNoIHNlcXVlbmNlIG9mIDggYnl0ZXMuICBUaGlzIHByb2R1Y2VzIGEgZmluYWxcbiAgICAvLyBzZXF1ZW5jZSBvZiA4IGJ5dGVzIHdoaWNoIGl0IHJldHVybnMgYXMgaGV4LlxuICAgIHZhciBVQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQsXG4gICAgICAgICAgICBpLCBjaCwgYnVmZmVyID0gW10sXG4gICAgICAgICAgICByZXQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHhvcihyZXN1bHQsIGJ5dGVfYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBqLCB0bXAgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJ5dGVfYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0bXAgfD0gKGJ1ZmZlcltqXSA8PCBqICogOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IF4gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHVhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBidWZmZXIudW5zaGlmdChjaCAmIDB4RkYpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0LnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2UgPSAoc2NyZWVuLmhlaWdodCAqIHNjcmVlbi53aWR0aCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gKFQoKSArICctJyArIFIoKSArICctJyArIFVBKCkgKyAnLScgKyBzZSArICctJyArIFQoKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8vIF8uaXNCbG9ja2VkVUEoKVxuLy8gVGhpcyBpcyB0byBibG9jayB2YXJpb3VzIHdlYiBzcGlkZXJzIGZyb20gZXhlY3V0aW5nIG91ciBKUyBhbmRcbi8vIHNlbmRpbmcgZmFsc2UgdHJhY2tpbmcgZGF0YVxudmFyIEJMT0NLRURfVUFfU1RSUyA9IFtcbiAgICAnYmFpZHVzcGlkZXInLFxuICAgICdiaW5nYm90JyxcbiAgICAnYmluZ3ByZXZpZXcnLFxuICAgICdmYWNlYm9va2V4dGVybmFsJyxcbiAgICAncGludGVyZXN0JyxcbiAgICAnc2NyZWFtaW5nIGZyb2cnLFxuICAgICd5YWhvbyEgc2x1cnAnLFxuICAgICd5YW5kZXhib3QnLFxuXG4gICAgLy8gYSB3aG9sZSBidW5jaCBvZiBnb29nLXNwZWNpZmljIGNyYXdsZXJzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2VhcmNoL2RvY3MvYWR2YW5jZWQvY3Jhd2xpbmcvb3ZlcnZpZXctZ29vZ2xlLWNyYXdsZXJzXG4gICAgJ2Fkc2JvdC1nb29nbGUnLFxuICAgICdhcGlzLWdvb2dsZScsXG4gICAgJ2R1cGxleHdlYi1nb29nbGUnLFxuICAgICdmZWVkZmV0Y2hlci1nb29nbGUnLFxuICAgICdnb29nbGUgZmF2aWNvbicsXG4gICAgJ2dvb2dsZSB3ZWIgcHJldmlldycsXG4gICAgJ2dvb2dsZS1yZWFkLWFsb3VkJyxcbiAgICAnZ29vZ2xlYm90JyxcbiAgICAnZ29vZ2xld2VibGlnaHQnLFxuICAgICdtZWRpYXBhcnRuZXJzLWdvb2dsZScsXG4gICAgJ3N0b3JlYm90LWdvb2dsZSdcbl07XG5fLmlzQmxvY2tlZFVBID0gZnVuY3Rpb24odWEpIHtcbiAgICB2YXIgaTtcbiAgICB1YSA9IHVhLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IEJMT0NLRURfVUFfU1RSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodWEuaW5kZXhPZihCTE9DS0VEX1VBX1NUUlNbaV0pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdD19IGZvcm1kYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGFyZ19zZXBhcmF0b3JcbiAqL1xuXy5IVFRQQnVpbGRRdWVyeSA9IGZ1bmN0aW9uKGZvcm1kYXRhLCBhcmdfc2VwYXJhdG9yKSB7XG4gICAgdmFyIHVzZV92YWwsIHVzZV9rZXksIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGFyZ19zZXBhcmF0b3IpKSB7XG4gICAgICAgIGFyZ19zZXBhcmF0b3IgPSAnJic7XG4gICAgfVxuXG4gICAgXy5lYWNoKGZvcm1kYXRhLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICB1c2VfdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgdXNlX2tleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICB0bXBfYXJyW3RtcF9hcnIubGVuZ3RoXSA9IHVzZV9rZXkgKyAnPScgKyB1c2VfdmFsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRtcF9hcnIuam9pbihhcmdfc2VwYXJhdG9yKTtcbn07XG5cbl8uZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uKHVybCwgcGFyYW0pIHtcbiAgICAvLyBFeHBlY3RzIGEgcmF3IFVSTFxuXG4gICAgcGFyYW0gPSBwYXJhbS5yZXBsYWNlKC9bW10vLCAnXFxcXFsnKS5yZXBsYWNlKC9bXFxdXS8sICdcXFxcXScpO1xuICAgIHZhciByZWdleFMgPSAnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UyksXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwgfHwgKHJlc3VsdHMgJiYgdHlwZW9mKHJlc3VsdHNbMV0pICE9PSAnc3RyaW5nJyAmJiByZXN1bHRzWzFdLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzFdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTa2lwcGluZyBkZWNvZGluZyBmb3IgbWFsZm9ybWVkIHF1ZXJ5IHBhcmFtOiAnICsgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIH1cbn07XG5cblxuLy8gXy5jb29raWVcbi8vIE1ldGhvZHMgcGFydGlhbGx5IGJvcnJvd2VkIGZyb20gcXVpcmtzbW9kZS5vcmcvanMvY29va2llcy5odG1sXG5fLmNvb2tpZSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50JDEuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNvb2tpZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvb2tpZSA9IF8uSlNPTkRlY29kZShfLmNvb2tpZS5nZXQobmFtZSkpIHx8IHt9O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG5cbiAgICBzZXRfc2Vjb25kczogZnVuY3Rpb24obmFtZSwgdmFsdWUsIHNlY29uZHMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJyxcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnJyxcbiAgICAgICAgICAgIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmRzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoc2Vjb25kcyAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZGF5cywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLCBleHBpcmVzID0gJycsIHNlY3VyZSA9ICcnO1xuXG4gICAgICAgIGlmIChkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNkb21haW4gPSAnOyBkb21haW49JyArIGRvbWFpbl9vdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc19jcm9zc19zdWJkb21haW4pIHtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBleHRyYWN0X2RvbWFpbihkb2N1bWVudCQxLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGNkb21haW4gPSBkb21haW4gPyAnOyBkb21haW49LicgKyBkb21haW4gOiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY3Jvc3Nfc2l0ZSkge1xuICAgICAgICAgICAgaXNfc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlY3VyZSA9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19zZWN1cmUpIHtcbiAgICAgICAgICAgIHNlY3VyZSArPSAnOyBzZWN1cmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld19jb29raWVfdmFsID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmV3X2Nvb2tpZV92YWw7XG4gICAgICAgIHJldHVybiBuZXdfY29va2llX3ZhbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lLCBpc19jcm9zc19zdWJkb21haW4sIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICBfLmNvb2tpZS5zZXQobmFtZSwgJycsIC0xLCBpc19jcm9zc19zdWJkb21haW4sIGZhbHNlLCBmYWxzZSwgZG9tYWluX292ZXJyaWRlKTtcbiAgICB9XG59O1xuXG52YXIgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IG51bGw7XG52YXIgbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24oc3RvcmFnZSwgZm9yY2VDaGVjaykge1xuICAgIGlmIChfbG9jYWxTdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsICYmICFmb3JjZUNoZWNrKSB7XG4gICAgICAgIHJldHVybiBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIHZhciBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHN0b3JhZ2UgPSBzdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIHZhciBrZXkgPSAnX19tcGxzc18nICsgY2hlYXBfZ3VpZCg4KSxcbiAgICAgICAgICAgIHZhbCA9ICd4eXonO1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWwpO1xuICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleSkgIT09IHZhbCkge1xuICAgICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn07XG5cbi8vIF8ubG9jYWxTdG9yYWdlXG5fLmxvY2FsU3RvcmFnZSA9IHtcbiAgICBpc19zdXBwb3J0ZWQ6IGZ1bmN0aW9uKGZvcmNlX2NoZWNrKSB7XG4gICAgICAgIHZhciBzdXBwb3J0ZWQgPSBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQobnVsbCwgZm9yY2VfY2hlY2spO1xuICAgICAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignbG9jYWxTdG9yYWdlIHVuc3VwcG9ydGVkOyBmYWxsaW5nIGJhY2sgdG8gY29va2llIHN0b3JlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdsb2NhbFN0b3JhZ2UgZXJyb3I6ICcgKyBtc2cpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfLkpTT05EZWNvZGUoXy5sb2NhbFN0b3JhZ2UuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5yZWdpc3Rlcl9ldmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyB3cml0dGVuIGJ5IERlYW4gRWR3YXJkcywgMjAwNVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBUaW5vIFppamRlbCAtIGNyaXNwQHhzNGFsbC5ubFxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBDYXJsIFN2ZXJyZSAtIG1haWxAY2FybHN2ZXJyZS5jb21cbiAgICAvLyB3aXRoIGlucHV0IGZyb20gTWl4cGFuZWxcbiAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDUvMTAvYWRkLWV2ZW50L1xuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE5MzA0NDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb2xkU2Nob29sXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQ2FwdHVyZVxuICAgICAqL1xuICAgIHZhciByZWdpc3Rlcl9ldmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9sZFNjaG9vbCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHZhbGlkIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVnaXN0ZXJfZXZlbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIW9sZFNjaG9vbCkge1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsICEhdXNlQ2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb250eXBlID0gJ29uJyArIHR5cGU7XG4gICAgICAgICAgICB2YXIgb2xkX2hhbmRsZXIgPSBlbGVtZW50W29udHlwZV07IC8vIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIGVsZW1lbnRbb250eXBlXSA9IG1ha2VIYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIG9sZF9oYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSGFuZGxlcihlbGVtZW50LCBuZXdfaGFuZGxlciwgb2xkX2hhbmRsZXJzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgZml4RXZlbnQod2luZG93LmV2ZW50KTtcblxuICAgICAgICAgICAgLy8gdGhpcyBiYXNpY2FsbHkgaGFwcGVucyBpbiBmaXJlZm94IHdoZW5ldmVyIGFub3RoZXIgc2NyaXB0XG4gICAgICAgICAgICAvLyBvdmVyd3JpdGVzIHRoZSBvbmxvYWQgY2FsbGJhY2sgYW5kIGRvZXNuJ3QgcGFzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgIC8vIG9iamVjdCB0byBwcmV2aW91c2x5IGRlZmluZWQgY2FsbGJhY2tzLiAgQWxsIHRoZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdGhhdCBkb24ndCBkZWZpbmUgd2luZG93LmV2ZW50IGltcGxlbWVudCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAvLyBzbyB0aGUgZG9tX2xvYWRlZCBoYW5kbGVyIHdpbGwgc3RpbGwgYmUgZmlyZWQgYXMgdXN1YWwuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkX3Jlc3VsdCwgbmV3X3Jlc3VsdDtcblxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvbGRfaGFuZGxlcnMpKSB7XG4gICAgICAgICAgICAgICAgb2xkX3Jlc3VsdCA9IG9sZF9oYW5kbGVycyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdfcmVzdWx0ID0gbmV3X2hhbmRsZXIuY2FsbChlbGVtZW50LCBldmVudCk7XG5cbiAgICAgICAgICAgIGlmICgoZmFsc2UgPT09IG9sZF9yZXN1bHQpIHx8IChmYWxzZSA9PT0gbmV3X3Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZml4RXZlbnQucHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfTtcbiAgICBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJfZXZlbnQ7XG59KSgpO1xuXG5cbnZhciBUT0tFTl9NQVRDSF9SRUdFWCA9IG5ldyBSZWdFeHAoJ14oXFxcXHcqKVxcXFxbKFxcXFx3KykoWz1+XFxcXHxcXFxcXlxcXFwkXFxcXCpdPyk9P1wiPyhbXlxcXFxdXCJdKilcIj9cXFxcXSQnKTtcblxuXy5kb21fcXVlcnkgPSAoZnVuY3Rpb24oKSB7XG4gICAgLyogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIC0gcmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50IG9iamVjdHMgZnJvbSB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgIG1hdGNoaW5nIHRoZSBDU1Mgc2VsZWN0b3IuIFNlbGVjdG9ycyBjYW4gY29udGFpbiBlbGVtZW50IG5hbWVzLFxuICAgIGNsYXNzIG5hbWVzIGFuZCBpZHMgYW5kIGNhbiBiZSBuZXN0ZWQuIEZvciBleGFtcGxlOlxuXG4gICAgZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3IoJ2RpdiNtYWluIHAgYS5leHRlcm5hbCcpXG5cbiAgICBXaWxsIHJldHVybiBhbiBhcnJheSBvZiBhbGwgJ2EnIGVsZW1lbnRzIHdpdGggJ2V4dGVybmFsJyBpbiB0aGVpclxuICAgIGNsYXNzIGF0dHJpYnV0ZSB0aGF0IGFyZSBjb250YWluZWQgaW5zaWRlICdwJyBlbGVtZW50cyB0aGF0IGFyZVxuICAgIGNvbnRhaW5lZCBpbnNpZGUgdGhlICdkaXYnIGVsZW1lbnQgd2hpY2ggaGFzIGlkPVwibWFpblwiXG5cbiAgICBOZXcgaW4gdmVyc2lvbiAwLjQ6IFN1cHBvcnQgZm9yIENTUzIgYW5kIENTUzMgYXR0cmlidXRlIHNlbGVjdG9yczpcbiAgICBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblxuICAgIFZlcnNpb24gMC40IC0gU2ltb24gV2lsbGlzb24sIE1hcmNoIDI1dGggMjAwM1xuICAgIC0tIFdvcmtzIGluIFBob2VuaXggMC41LCBNb3ppbGxhIDEuMywgT3BlcmEgNywgSW50ZXJuZXQgRXhwbG9yZXIgNiwgSW50ZXJuZXQgRXhwbG9yZXIgNSBvbiBXaW5kb3dzXG4gICAgLS0gT3BlcmEgNyBmYWlsc1xuXG4gICAgVmVyc2lvbiAwLjUgLSBDYXJsIFN2ZXJyZSwgSmFuIDd0aCAyMDEzXG4gICAgLS0gTm93IHVzZXMgalF1ZXJ5LWVzcXVlIGBoYXNDbGFzc2AgZm9yIHRlc3RpbmcgY2xhc3MgbmFtZVxuICAgIGVxdWFsaXR5LiAgVGhpcyBmaXhlcyBhIGJ1ZyByZWxhdGVkIHRvICctJyBjaGFyYWN0ZXJzIGJlaW5nXG4gICAgY29uc2lkZXJlZCBub3QgcGFydCBvZiBhICd3b3JkJyBpbiByZWdleC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4oZSkge1xuICAgICAgICAvLyBSZXR1cm5zIGFsbCBjaGlsZHJlbiBvZiBlbGVtZW50LiBXb3JrYXJvdW5kIHJlcXVpcmVkIGZvciBJRTUvV2luZG93cy4gVWdoLlxuICAgICAgICByZXR1cm4gZS5hbGwgPyBlLmFsbCA6IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICB9XG5cbiAgICB2YXIgYmFkX3doaXRlc3BhY2UgPSAvW1xcdFxcclxcbl0vZztcblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnICcgKyBzZWxlY3RvciArICcgJztcbiAgICAgICAgcmV0dXJuICgoJyAnICsgZWxlbS5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoYmFkX3doaXRlc3BhY2UsICcgJykuaW5kZXhPZihjbGFzc05hbWUpID49IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGZhaWwgZ3JhY2VmdWxseSBpbiBsZXNzZXIgYnJvd3NlcnNcbiAgICAgICAgaWYgKCFkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BsaXQgc2VsZWN0b3IgaW4gdG8gdG9rZW5zXG4gICAgICAgIHZhciB0b2tlbnMgPSBzZWxlY3Rvci5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgdG9rZW4sIGJpdHMsIHRhZ05hbWUsIGZvdW5kLCBmb3VuZENvdW50LCBpLCBqLCBrLCBlbGVtZW50cywgY3VycmVudENvbnRleHRJbmRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gW2RvY3VtZW50JDFdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5pbmRleE9mKCcjJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRva2VuIGlzIGFuIElEIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcjJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gYml0c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50JDEuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCAodGFnTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gdGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBub3QgZm91bmQgb3IgdGFnIHdpdGggdGhhdCBJRCBub3QgZm91bmQsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50Q29udGV4dCB0byBjb250YWluIGp1c3QgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbZWxlbWVudF07XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gY29udGFpbnMgYSBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGJpdHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBiaXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gJyonO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHZXQgZWxlbWVudHMgbWF0Y2hpbmcgdGFnLCBmaWx0ZXIgdGhlbSBmb3IgY2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRbal0uY2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzU3RyaW5nKGZvdW5kW2pdLmNsYXNzTmFtZSkgJiYgLy8gc29tZSBTVkcgZWxlbWVudHMgaGF2ZSBjbGFzc05hbWVzIHdoaWNoIGFyZSBub3Qgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2xhc3MoZm91bmRbal0sIGNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29kZSB0byBkZWFsIHdpdGggYXR0cmlidXRlIHNlbGVjdG9yc1xuICAgICAgICAgICAgdmFyIHRva2VuX21hdGNoID0gdG9rZW4ubWF0Y2goVE9LRU5fTUFUQ0hfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKHRva2VuX21hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuX21hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRva2VuX21hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyT3BlcmF0b3IgPSB0b2tlbl9tYXRjaFszXTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdG9rZW5fbWF0Y2hbNF07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdyYWIgYWxsIG9mIHRoZSB0YWdOYW1lIGVsZW1lbnRzIHdpdGhpbiBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyZW50Q29udGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gZ2V0QWxsQ2hpbGRyZW4oY3VycmVudENvbnRleHRbal0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kW2ZvdW5kQ291bnQrK10gPSBlbGVtZW50c1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja0Z1bmN0aW9uOyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byBmaWx0ZXIgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdHRyT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6IC8vIEVxdWFsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpID09IGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOiAvLyBNYXRjaCBvbmUgb2Ygc3BhY2Ugc2VwZXJhdGVkIHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFxiJyArIGF0dHJWYWx1ZSArICdcXFxcYicpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOiAvLyBNYXRjaCBzdGFydCB3aXRoIHZhbHVlIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIGh5cGhlblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIGF0dHJWYWx1ZSArICctPycpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ14nOiAvLyBNYXRjaCBzdGFydHMgd2l0aCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKS5pbmRleE9mKGF0dHJWYWx1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlIC0gZmFpbHMgd2l0aCBcIldhcm5pbmdcIiBpbiBPcGVyYSA3XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxhc3RJbmRleE9mKGF0dHJWYWx1ZSkgPT0gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmxlbmd0aCAtIGF0dHJWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzogLy8gTWF0Y2ggZW5kcyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdGVzdCBmb3IgZXhpc3RlbmNlIG9mIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRnVuY3Rpb24oZm91bmRbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dFtjdXJyZW50Q29udGV4dEluZGV4KytdID0gZm91bmRbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWxlcnQoJ0F0dHJpYnV0ZSBTZWxlY3RvcjogJyt0YWdOYW1lKycgJythdHRyTmFtZSsnICcrYXR0ck9wZXJhdG9yKycgJythdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRvIG5leHQgdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0b2tlbiBpcyBKVVNUIGFuIGVsZW1lbnQgKG5vdCBhIGNsYXNzIG9yIElEIHNlbGVjdG9yKVxuICAgICAgICAgICAgdGFnTmFtZSA9IHRva2VuO1xuICAgICAgICAgICAgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIGZvdW5kQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBjdXJyZW50Q29udGV4dFtqXS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWxlbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihxdWVyeSkge1xuICAgICAgICBpZiAoXy5pc0VsZW1lbnQocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3F1ZXJ5XTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHF1ZXJ5KSAmJiAhXy5pc1VuZGVmaW5lZChxdWVyeS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVNlbGVjdG9yLmNhbGwodGhpcywgcXVlcnkpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbl8uaW5mbyA9IHtcbiAgICBjYW1wYWlnblBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW1wYWlnbl9rZXl3b3JkcyA9ICd1dG1fc291cmNlIHV0bV9tZWRpdW0gdXRtX2NhbXBhaWduIHV0bV9jb250ZW50IHV0bV90ZXJtJy5zcGxpdCgnICcpLFxuICAgICAgICAgICAga3cgPSAnJyxcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICBfLmVhY2goY2FtcGFpZ25fa2V5d29yZHMsIGZ1bmN0aW9uKGt3a2V5KSB7XG4gICAgICAgICAgICBrdyA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwga3drZXkpO1xuICAgICAgICAgICAgaWYgKGt3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBrdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgc2VhcmNoRW5naW5lOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZ29vZ2xlLihbXi8/XSopJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZ29vZ2xlJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKiliaW5nLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpbmcnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKXlhaG9vLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3lhaG9vJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKilkdWNrZHVja2dvLmNvbScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2R1Y2tkdWNrZ28nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VhcmNoSW5mbzogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IF8uaW5mby5zZWFyY2hFbmdpbmUocmVmZXJyZXIpLFxuICAgICAgICAgICAgcGFyYW0gPSAoc2VhcmNoICE9ICd5YWhvbycpID8gJ3EnIDogJ3AnLFxuICAgICAgICAgICAgcmV0ID0ge307XG5cbiAgICAgICAgaWYgKHNlYXJjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0Wyckc2VhcmNoX2VuZ2luZSddID0gc2VhcmNoO1xuXG4gICAgICAgICAgICB2YXIga2V5d29yZCA9IF8uZ2V0UXVlcnlQYXJhbShyZWZlcnJlciwgcGFyYW0pO1xuICAgICAgICAgICAgaWYgKGtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0WydtcF9rZXl3b3JkJ10gPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoaWNoIGJyb3dzZXIgaXMgcnVubmluZyB0aGlzIHNjcmlwdC5cbiAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIGNoZWNrcyBhcmUgaW1wb3J0YW50IHNpbmNlIG1hbnkgdXNlciBhZ2VudHNcbiAgICAgKiBpbmNsdWRlIGtleSB3b3JkcyB1c2VkIGluIGxhdGVyIGNoZWNrcy5cbiAgICAgKi9cbiAgICBicm93c2VyOiBmdW5jdGlvbih1c2VyX2FnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZlbmRvciA9IHZlbmRvciB8fCAnJzsgLy8gdmVuZG9yIGlzIHVuZGVmaW5lZCBmb3IgYXQgbGVhc3QgSUU5XG4gICAgICAgIGlmIChvcGVyYSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICcgT1BSLycpKSB7XG4gICAgICAgICAgICBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnTWluaScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdPcGVyYSBNaW5pJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnT3BlcmEnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnSUVNb2JpbGUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdXUERlc2t0b3AnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3JlciBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1NhbXN1bmdCcm93c2VyLycpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5zYW1zdW5nLmNvbS9pbnRlcm5ldC91c2VyLWFnZW50LXN0cmluZy1mb3JtYXRcbiAgICAgICAgICAgIHJldHVybiAnU2Ftc3VuZyBJbnRlcm5ldCc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRWRnZScpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNaWNyb3NvZnQgRWRnZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRkJJT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGYWNlYm9vayBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Nocm9tZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQ3JpT1MnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ1dFQicpIHx8IF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ1VDQnJvd3NlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1VDIEJyb3dzZXInO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0Z4aU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmlyZWZveCBpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModmVuZG9yLCAnQXBwbGUnKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01vYmlsZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb2JpbGUgU2FmYXJpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdBbmRyb2lkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCBNb2JpbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0tvbnF1ZXJvcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0tvbnF1ZXJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnRmlyZWZveCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01TSUUnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdUcmlkZW50LycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ludGVybmV0IEV4cGxvcmVyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdHZWNrbycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vemlsbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIHZlcnNpb24gaXMgcnVubmluZyB0aGlzIHNjcmlwdCxcbiAgICAgKiBwYXJzaW5nIG1ham9yIGFuZCBtaW5vciB2ZXJzaW9uIChlLmcuLCA0Mi4xKS4gVXNlciBhZ2VudCBzdHJpbmdzIGZyb206XG4gICAgICogaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tL3BhZ2VzL3VzZXJhZ2VudHN0cmluZy5waHBcbiAgICAgKi9cbiAgICBicm93c2VyVmVyc2lvbjogZnVuY3Rpb24odXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCB2ZW5kb3IsIG9wZXJhKTtcbiAgICAgICAgdmFyIHZlcnNpb25SZWdleHMgPSB7XG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJzogL3J2OihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01pY3Jvc29mdCBFZGdlJzogL0VkZ2U/XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQ2hyb21lJzogL0Nocm9tZVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSBpT1MnOiAvQ3JpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdVQyBCcm93c2VyJyA6IC8oVUNCcm93c2VyfFVDV0VCKVxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ1NhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW9iaWxlIFNhZmFyaSc6IC9WZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnT3BlcmEnOiAvKE9wZXJhfE9QUilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94JzogL0ZpcmVmb3hcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdGaXJlZm94IGlPUyc6IC9GeGlPU1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0tvbnF1ZXJvcic6IC9Lb25xdWVyb3I6KFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnQmxhY2tCZXJyeSc6IC9CbGFja0JlcnJ5IChcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0FuZHJvaWQgTW9iaWxlJzogL2FuZHJvaWRcXHMoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYW1zdW5nIEludGVybmV0JzogL1NhbXN1bmdCcm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnSW50ZXJuZXQgRXhwbG9yZXInOiAvKHJ2OnxNU0lFICkoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNb3ppbGxhJzogL3J2OihcXGQrKFxcLlxcZCspPykvXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZWdleCA9IHZlcnNpb25SZWdleHNbYnJvd3Nlcl07XG4gICAgICAgIGlmIChyZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHVzZXJBZ2VudC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDJdKTtcbiAgICB9LFxuXG4gICAgb3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHVzZXJBZ2VudDtcbiAgICAgICAgaWYgKC9XaW5kb3dzL2kudGVzdChhKSkge1xuICAgICAgICAgICAgaWYgKC9QaG9uZS8udGVzdChhKSB8fCAvV1BEZXNrdG9wLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpT1MnO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL01hYy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWFjIE9TIFgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9MaW51eC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0NyT1MvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIE9TJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXZpY2U6IGZ1bmN0aW9uKHVzZXJfYWdlbnQpIHtcbiAgICAgICAgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdCh1c2VyX2FnZW50KSB8fCAvV1BEZXNrdG9wLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGFkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQYWQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUG9kLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQb2QgVG91Y2gnO1xuICAgICAgICB9IGVsc2UgaWYgKC9pUGhvbmUvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlZmVycmluZ0RvbWFpbjogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gcmVmZXJyZXIuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvciQxLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRyZWZlcnJlcic6IGRvY3VtZW50JDEucmVmZXJyZXIsXG4gICAgICAgICAgICAnJHJlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKGRvY3VtZW50JDEucmVmZXJyZXIpLFxuICAgICAgICAgICAgJyRkZXZpY2UnOiBfLmluZm8uZGV2aWNlKHVzZXJBZ2VudClcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiB3aW5kb3ckMS5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IkMS52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckc2NyZWVuX2hlaWdodCc6IHNjcmVlbi5oZWlnaHQsXG4gICAgICAgICAgICAnJHNjcmVlbl93aWR0aCc6IHNjcmVlbi53aWR0aCxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICckbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT04sXG4gICAgICAgICAgICAnJGluc2VydF9pZCc6IGNoZWFwX2d1aWQoKSxcbiAgICAgICAgICAgICd0aW1lJzogXy50aW1lc3RhbXAoKSAvIDEwMDAgLy8gZXBvY2ggdGltZSBpbiBzZWNvbmRzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwZW9wbGVfcHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJyRvcyc6IF8uaW5mby5vcygpLFxuICAgICAgICAgICAgJyRicm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IkMS52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IkMS52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcGFnZXZpZXdJbmZvOiBmdW5jdGlvbihwYWdlKSB7XG4gICAgICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJ21wX3BhZ2UnOiBwYWdlLFxuICAgICAgICAgICAgJ21wX3JlZmVycmVyJzogZG9jdW1lbnQkMS5yZWZlcnJlcixcbiAgICAgICAgICAgICdtcF9icm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IkMS52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICdtcF9wbGF0Zm9ybSc6IF8uaW5mby5vcygpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbnZhciBjaGVhcF9ndWlkID0gZnVuY3Rpb24obWF4bGVuKSB7XG4gICAgdmFyIGd1aWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbiAgICByZXR1cm4gbWF4bGVuID8gZ3VpZC5zdWJzdHJpbmcoMCwgbWF4bGVuKSA6IGd1aWQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGRldGVybWluaXN0aWNhbGx5IHdoZXRoZXIgdG8gaW5jbHVkZSBvciBleGNsdWRlIGZyb20gYSBmZWF0dXJlIHJvbGxvdXQvdGVzdCBiYXNlZCBvbiB0aGVcbiAqIGdpdmVuIHN0cmluZyBhbmQgdGhlIGRlc2lyZWQgcGVyY2VudGFnZSB0byBpbmNsdWRlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBydW4gdGhlIGNoZWNrIGFnYWluc3QgKGZvciBpbnN0YW5jZSBhIHByb2plY3QncyB0b2tlbilcbiAqIEBwYXJhbSB7U3RyaW5nfSBmZWF0dXJlIC0gbmFtZSBvZiBmZWF0dXJlIChmb3IgaW5jbHVzaW9uIGluIGhhc2gsIHRvIGVuc3VyZSBkaWZmZXJlbnQgcmVzdWx0c1xuICogZm9yIGRpZmZlcmVudCBmZWF0dXJlcylcbiAqIEBwYXJhbSB7TnVtYmVyfSBwZXJjZW50X2FsbG93ZWQgLSBwZXJjZW50YWdlIGNoYW5jZSB0aGF0IGEgZ2l2ZW4gc3RyaW5nIHdpbGwgYmUgaW5jbHVkZWRcbiAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKi9cbnZhciBkZXRlcm1pbmVfZWxpZ2liaWxpdHkgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKHN0ciwgZmVhdHVyZSwgcGVyY2VudF9hbGxvd2VkKSB7XG4gICAgc3RyID0gc3RyICsgZmVhdHVyZTtcblxuICAgIC8vIEJlcm5zdGVpbidzIGhhc2g6IGh0dHA6Ly93d3cuY3NlLnlvcmt1LmNhL35vei9oYXNoLmh0bWwjZGpiMlxuICAgIHZhciBoYXNoID0gNTM4MTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpICsgaGFzaCkgKyBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoO1xuICAgIH1cbiAgICB2YXIgZGFydCA9IChoYXNoID4+PiAwKSAlIDEwMDtcbiAgICByZXR1cm4gZGFydCA8IHBlcmNlbnRfYWxsb3dlZDtcbn0pO1xuXG4vLyBuYWl2ZSB3YXkgdG8gZXh0cmFjdCBkb21haW4gbmFtZSAoZXhhbXBsZS5jb20pIGZyb20gZnVsbCBob3N0bmFtZSAobXkuc3ViLmV4YW1wbGUuY29tKVxudmFyIFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0qXFwuW2Etel0rJC9pO1xuLy8gdGhpcyBuZXh0IG9uZSBhdHRlbXB0cyB0byBhY2NvdW50IGZvciBzb21lIGNjU0xEcywgZS5nLiBleHRyYWN0aW5nIG94Zm9yZC5hYy51ayBmcm9tIHd3dy5veGZvcmQuYWMudWtcbnZhciBET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0rXFwuW2Etei5dezIsNn0kL2k7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGV4dHJhY3QgbWFpbiBkb21haW4gbmFtZSBmcm9tIGZ1bGwgaG9zdG5hbWUsIHVzaW5nIGEgZmV3IGJsdW50IGhldXJpc3RpY3MuIEZvclxuICogY29tbW9uIFRMRHMgbGlrZSAuY29tLy5vcmcgdGhhdCBhbHdheXMgaGF2ZSBhIHNpbXBsZSBTTEQuVExEIHN0cnVjdHVyZSAoZXhhbXBsZS5jb20pLCB3ZVxuICogc2ltcGx5IGV4dHJhY3QgdGhlIGxhc3QgdHdvIC4tc2VwYXJhdGVkIHBhcnRzIG9mIHRoZSBob3N0bmFtZSAoU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCkuXG4gKiBGb3Igb3RoZXJzLCB3ZSBhdHRlbXB0IHRvIGFjY291bnQgZm9yIHNob3J0IGNjU0xEK1RMRCBjb21ib3MgKC5hYy51aykgd2l0aCB0aGUgbGVnYWN5XG4gKiBET01BSU5fTUFUQ0hfUkVHRVggKGtlcHQgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBNaXhwYW5lbFxuICogaW50ZWdyYXRpb25zKS4gVGhlIG9ubHkgX3JlbGlhYmxlXyB3YXkgdG8gZXh0cmFjdCBkb21haW4gZnJvbSBob3N0bmFtZSBpcyB3aXRoIGFuIHVwLXRvLWRhdGVcbiAqIGxpc3QgbGlrZSBhdCBodHRwczovL3B1YmxpY3N1ZmZpeC5vcmcvIHNvIGZvciBjYXNlcyB0aGF0IHRoaXMgaGVscGVyIGZhaWxzIGF0LCB0aGUgU0RLXG4gKiBvZmZlcnMgdGhlICdjb29raWVfZG9tYWluJyBjb25maWcgb3B0aW9uIHRvIHNldCBpdCBleHBsaWNpdGx5LlxuICogQGV4YW1wbGVcbiAqIGV4dHJhY3RfZG9tYWluKCdteS5zdWIuZXhhbXBsZS5jb20nKVxuICogLy8gJ2V4YW1wbGUuY29tJ1xuICovXG52YXIgZXh0cmFjdF9kb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSkge1xuICAgIHZhciBkb21haW5fcmVnZXggPSBET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgdmFyIHBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgdGxkID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRsZC5sZW5ndGggPiA0IHx8IHRsZCA9PT0gJ2NvbScgfHwgdGxkID09PSAnb3JnJykge1xuICAgICAgICBkb21haW5fcmVnZXggPSBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3RuYW1lLm1hdGNoKGRvbWFpbl9yZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogJyc7XG59O1xuXG52YXIgSlNPTlN0cmluZ2lmeSA9IG51bGw7XG52YXIgSlNPTlBhcnNlID0gbnVsbDtcbmlmICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU09OU3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTlBhcnNlID0gSlNPTi5wYXJzZTtcbn1cbkpTT05TdHJpbmdpZnkgPSBKU09OU3RyaW5naWZ5IHx8IF8uSlNPTkVuY29kZTtcbkpTT05QYXJzZSA9IEpTT05QYXJzZSB8fCBfLkpTT05EZWNvZGU7XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuX1sndG9BcnJheSddICAgICAgICAgICAgICAgID0gXy50b0FycmF5O1xuX1snaXNPYmplY3QnXSAgICAgICAgICAgICAgID0gXy5pc09iamVjdDtcbl9bJ0pTT05FbmNvZGUnXSAgICAgICAgICAgICA9IF8uSlNPTkVuY29kZTtcbl9bJ0pTT05EZWNvZGUnXSAgICAgICAgICAgICA9IF8uSlNPTkRlY29kZTtcbl9bJ2lzQmxvY2tlZFVBJ10gICAgICAgICAgICA9IF8uaXNCbG9ja2VkVUE7XG5fWydpc0VtcHR5T2JqZWN0J10gICAgICAgICAgPSBfLmlzRW1wdHlPYmplY3Q7XG5fWydpbmZvJ10gICAgICAgICAgICAgICAgICAgPSBfLmluZm87XG5fWydpbmZvJ11bJ2RldmljZSddICAgICAgICAgPSBfLmluZm8uZGV2aWNlO1xuX1snaW5mbyddWydicm93c2VyJ10gICAgICAgID0gXy5pbmZvLmJyb3dzZXI7XG5fWydpbmZvJ11bJ2Jyb3dzZXJWZXJzaW9uJ10gPSBfLmluZm8uYnJvd3NlclZlcnNpb247XG5fWydpbmZvJ11bJ3Byb3BlcnRpZXMnXSAgICAgPSBfLmluZm8ucHJvcGVydGllcztcblxuLyoqXG4gKiBEb21UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEb21UcmFja2VyID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBpbnRlcmZhY2VcbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMubXAgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IHVzZXJfY2FsbGJhY2tcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbihxdWVyeSwgZXZlbnRfbmFtZSwgcHJvcGVydGllcywgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudHMgPSBfLmRvbV9xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBET00gcXVlcnkgKCcgKyBxdWVyeSArICcpIHJldHVybmVkIDAgZWxlbWVudHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF8uZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBfLnJlZ2lzdGVyX2V2ZW50KGVsZW1lbnQsIHRoaXMub3ZlcnJpZGVfZXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGF0LmNyZWF0ZV9wcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGF0Lm1wLmdldF9jb25maWcoJ3RyYWNrX2xpbmtzX3RpbWVvdXQnKTtcblxuICAgICAgICAgICAgdGhhdC5ldmVudF9oYW5kbGVyKGUsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtaXhwYW5lbCBzZXJ2ZXJzIGRvbid0IGdldCBiYWNrIHRvIHVzIGluIHRpbWVcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRydWUpLCB0aW1lb3V0KTtcblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgdHJhY2tpbmcgZXZlbnRcbiAgICAgICAgICAgIHRoYXQubXAudHJhY2soZXZlbnRfbmFtZSwgcHJvcHMsIHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdXNlcl9jYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB0aW1lb3V0X29jY3VyZWRcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2tfY2FsbGJhY2sgPSBmdW5jdGlvbih1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKSB7XG4gICAgdGltZW91dF9vY2N1cmVkID0gdGltZW91dF9vY2N1cmVkIHx8IGZhbHNlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gb3B0aW9ucyBpcyByZWZlcmVuY2VkIGZyb20gYm90aCBjYWxsYmFja3MsIHNvIHdlIGNhbiBoYXZlXG4gICAgICAgIC8vIGEgJ2xvY2snIG9mIHNvcnRzIHRvIGVuc3VyZSBvbmx5IG9uZSBmaXJlc1xuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFja19maXJlZCkgeyByZXR1cm47IH1cbiAgICAgICAgb3B0aW9ucy5jYWxsYmFja19maXJlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHVzZXJfY2FsbGJhY2sgJiYgdXNlcl9jYWxsYmFjayh0aW1lb3V0X29jY3VyZWQsIHByb3BzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIHVzZXIgY2FuIHByZXZlbnQgdGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBieVxuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlaXIgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuYWZ0ZXJfdHJhY2tfaGFuZGxlcihwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKTtcbiAgICB9O1xufTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKHR5cGVvZihwcm9wZXJ0aWVzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wcyA9IHByb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuLyoqXG4gKiBMaW5rVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgTGlua1RyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ2NsaWNrJztcbn07XG5fLmluaGVyaXQoTGlua1RyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzID0gTGlua1RyYWNrZXIuc3VwZXJjbGFzcy5jcmVhdGVfcHJvcGVydGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKGVsZW1lbnQuaHJlZikgeyBwcm9wc1sndXJsJ10gPSBlbGVtZW50LmhyZWY7IH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5uZXdfdGFiID0gKFxuICAgICAgICBldnQud2hpY2ggPT09IDIgfHxcbiAgICAgICAgZXZ0Lm1ldGFLZXkgfHxcbiAgICAgICAgZXZ0LmN0cmxLZXkgfHxcbiAgICAgICAgZWxlbWVudC50YXJnZXQgPT09ICdfYmxhbmsnXG4gICAgKTtcbiAgICBvcHRpb25zLmhyZWYgPSBlbGVtZW50LmhyZWY7XG5cbiAgICBpZiAoIW9wdGlvbnMubmV3X3RhYikge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubmV3X3RhYikgeyByZXR1cm47IH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IG9wdGlvbnMuaHJlZjtcbiAgICB9LCAwKTtcbn07XG5cbi8qKlxuICogRm9ybVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIEZvcm1UcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdzdWJtaXQnO1xufTtcbl8uaW5oZXJpdChGb3JtVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcHRpb25zLmVsZW1lbnQuc3VibWl0KCk7XG4gICAgfSwgMCk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG52YXIgbG9nZ2VyJDIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdsb2NrJyk7XG5cbi8qKlxuICogU2hhcmVkTG9jazogYSBtdXRleCBidWlsdCBvbiBIVE1MNSBsb2NhbFN0b3JhZ2UsIHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGJyb3dzZXJcbiAqIHdpbmRvdy90YWIgYXQgYSB0aW1lIHdpbGwgYmUgYWJsZSB0byBhY2Nlc3Mgc2hhcmVkIHJlc291cmNlcy5cbiAqXG4gKiBCYXNlZCBvbiB0aGUgQWx1ciBhbmQgVGF1YmVuZmVsZCBmYXN0IGxvY2tcbiAqIChodHRwOi8vd3d3LmNzLnJvY2hlc3Rlci5lZHUvcmVzZWFyY2gvc3luY2hyb25pemF0aW9uL3BzZXVkb2NvZGUvZmFzdGxvY2suaHRtbClcbiAqIHdpdGggYW4gYWRkZWQgdGltZW91dCB0byBlbnN1cmUgdGhlcmUgd2lsbCBiZSBldmVudHVhbCBwcm9ncmVzcyBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSB3aW5kb3cgaXMgY2xvc2VkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIGJ5IERhdmlkIFdvbGV2ZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS93b2xldmVyKVxuICogYXQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vd29sZXZlci81ZmQ3NTczZDFlZjYxNjZlOGY4YzRhZjI4NmE2OTQzMi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXlMb2NrID0gbmV3IFNoYXJlZExvY2soJ3NvbWUta2V5Jyk7XG4gKiBteUxvY2sud2l0aExvY2soZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdJIGhvbGQgdGhlIG11dGV4IScpO1xuICogfSk7XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaGFyZWRMb2NrID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBrZXk7XG4gICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgdGhpcy5wb2xsSW50ZXJ2YWxNUyA9IG9wdGlvbnMucG9sbEludGVydmFsTVMgfHwgMTAwO1xuICAgIHRoaXMudGltZW91dE1TID0gb3B0aW9ucy50aW1lb3V0TVMgfHwgMjAwMDtcbn07XG5cbi8vIHBhc3MgaW4gYSBzcGVjaWZpYyBwaWQgdG8gdGVzdCBjb250ZW50aW9uIHNjZW5hcmlvczsgb3RoZXJ3aXNlXG4vLyBpdCBpcyBjaG9zZW4gcmFuZG9tbHkgZm9yIGVhY2ggYWNxdWlzaXRpb24gYXR0ZW1wdFxuU2hhcmVkTG9jay5wcm90b3R5cGUud2l0aExvY2sgPSBmdW5jdGlvbihsb2NrZWRDQiwgZXJyb3JDQiwgcGlkKSB7XG4gICAgaWYgKCFwaWQgJiYgdHlwZW9mIGVycm9yQ0IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGlkID0gZXJyb3JDQjtcbiAgICAgICAgZXJyb3JDQiA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBwaWQgfHwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJ3wnICsgTWF0aC5yYW5kb20oKSk7XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgdmFyIGtleSA9IHRoaXMuc3RvcmFnZUtleTtcbiAgICB2YXIgcG9sbEludGVydmFsTVMgPSB0aGlzLnBvbGxJbnRlcnZhbE1TO1xuICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLnRpbWVvdXRNUztcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuc3RvcmFnZTtcblxuICAgIHZhciBrZXlYID0ga2V5ICsgJzpYJztcbiAgICB2YXIga2V5WSA9IGtleSArICc6WSc7XG4gICAgdmFyIGtleVogPSBrZXkgKyAnOlonO1xuXG4gICAgdmFyIHJlcG9ydEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGVycm9yQ0IgJiYgZXJyb3JDQihlcnIpO1xuICAgIH07XG5cbiAgICB2YXIgZGVsYXkgPSBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0TVMpIHtcbiAgICAgICAgICAgIGxvZ2dlciQyLmVycm9yKCdUaW1lb3V0IHdhaXRpbmcgZm9yIG11dGV4IG9uICcgKyBrZXkgKyAnOyBjbGVhcmluZyBsb2NrLiBbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydEVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHBvbGxJbnRlcnZhbE1TICogKE1hdGgucmFuZG9tKCkgKyAwLjEpKTtcbiAgICB9O1xuXG4gICAgdmFyIHdhaXRGb3IgPSBmdW5jdGlvbihwcmVkaWNhdGUsIGNiKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdhaXRGb3IocHJlZGljYXRlLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0U2V0WSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsWSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXlZKTtcbiAgICAgICAgaWYgKHZhbFkgJiYgdmFsWSAhPT0gaSkgeyAvLyBpZiBZID09IGkgdGhlbiB0aGlzIHByb2Nlc3MgYWxyZWFkeSBoYXMgdGhlIGxvY2sgKHVzZWZ1bCBmb3IgdGVzdCBjYXNlcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlZLCBpKTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQoc3RvcmFnZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBkcm9wcGVkIHdoaWxlIGFjcXVpcmluZyBsb2NrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WCwgaSk7XG5cbiAgICAgICAgd2FpdEZvcihnZXRTZXRZLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBjcml0aWNhbFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhaXRGb3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RvcmFnZS5nZXRJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIH0sIGNyaXRpY2FsU2VjdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcml0aWNhbFNlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVosICcxJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NrZWRDQigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJlcG9ydEVycm9yKGVycik7XG4gICAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0UXVldWU6IHF1ZXVlIGZvciBiYXRjaGluZyBBUEkgcmVxdWVzdHMgd2l0aCBsb2NhbFN0b3JhZ2UgYmFja3VwIGZvciByZXRyaWVzLlxuICogTWFpbnRhaW5zIGFuIGluLW1lbW9yeSBxdWV1ZSB3aGljaCByZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50XG4gKiBwYWdlLCBidXQgYWxzbyB3cml0ZXMgYWxsIGl0ZW1zIG91dCB0byBhIGNvcHkgaW4gdGhlIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UsIHdoaWNoXG4gKiBjYW4gYmUgcmVhZCBvbiBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBhbmQgcmV0cmllZC4gRm9yIGJhdGNoYWJpbGl0eSwgYWxsIHRoZSByZXF1ZXN0XG4gKiBpdGVtcyBpbiB0aGUgcXVldWUgc2hvdWxkIGJlIG9mIHRoZSBzYW1lIHR5cGUgKGV2ZW50cywgcGVvcGxlIHVwZGF0ZXMsIGdyb3VwIHVwZGF0ZXMpXG4gKiBzbyB0aGV5IGNhbiBiZSBzZW50IGluIGEgc2luZ2xlIHJlcXVlc3QgdG8gdGhlIHNhbWUgQVBJIGVuZHBvaW50LlxuICpcbiAqIExvY2FsU3RvcmFnZSBrZXlpbmcgYW5kIGxvY2tpbmc6IEluIG9yZGVyIGZvciByZWxvYWRzIGFuZCBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBvZlxuICogdGhlIHNhbWUgc2l0ZSB0byBhY2Nlc3MgdGhlIHNhbWUgcGVyc2lzdGVkIGRhdGEsIHRoZXkgbXVzdCBzaGFyZSB0aGUgc2FtZSBsb2NhbFN0b3JhZ2VcbiAqIGtleSAoZm9yIGluc3RhbmNlIGJhc2VkIG9uIHByb2plY3QgdG9rZW4gYW5kIHF1ZXVlIHR5cGUpLiBUaGVyZWZvcmUgYWNjZXNzIHRvIHRoZVxuICogbG9jYWxTdG9yYWdlIGVudHJ5IGlzIGd1YXJkZWQgYnkgYW4gYXN5bmNocm9ub3VzIG11dGV4IChTaGFyZWRMb2NrKSB0byBwcmV2ZW50XG4gKiBzaW11bHRhbmVvdXNseSBvcGVuIHdpbmRvd3MvdGFicyBmcm9tIG92ZXJ3cml0aW5nIGVhY2ggb3RoZXIncyBkYXRhICh3aGljaCB3b3VsZCBsZWFkXG4gKiB0byBkYXRhIGxvc3MgaW4gc29tZSBzaXR1YXRpb25zKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdFF1ZXVlID0gZnVuY3Rpb24oc3RvcmFnZUtleSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgdGhpcy5sb2NrID0gbmV3IFNoYXJlZExvY2soc3RvcmFnZUtleSwge3N0b3JhZ2U6IHRoaXMuc3RvcmFnZX0pO1xuXG4gICAgdGhpcy5waWQgPSBvcHRpb25zLnBpZCB8fCBudWxsOyAvLyBwYXNzIHBpZCB0byB0ZXN0IG91dCBzdG9yYWdlIGxvY2sgY29udGVudGlvbiBzY2VuYXJpb3NcblxuICAgIHRoaXMubWVtUXVldWUgPSBbXTtcbn07XG5cbi8qKlxuICogQWRkIG9uZSBpdGVtIHRvIHF1ZXVlcyAobWVtb3J5IGFuZCBsb2NhbFN0b3JhZ2UpLiBUaGUgcXVldWVkIGVudHJ5IGluY2x1ZGVzXG4gKiB0aGUgZ2l2ZW4gaXRlbSBhbG9uZyB3aXRoIGFuIGF1dG8tZ2VuZXJhdGVkIElEIGFuZCBhIFwiZmx1c2gtYWZ0ZXJcIiB0aW1lc3RhbXAuXG4gKiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBpdGVtIHdpbGwgYmUgc2VudCBvdmVyIHRoZSBuZXR3b3JrIGFuZCBkZXF1ZXVlZFxuICogYmVmb3JlIHRoZSBmbHVzaC1hZnRlciB0aW1lOyBpZiB0aGlzIGRvZXNuJ3QgaGFwcGVuIGl0IGlzIGNvbnNpZGVyZWQgb3JwaGFuZWRcbiAqIChlLmcuLCB0aGUgb3JpZ2luYWwgdGFiIHdoZXJlIGl0IHdhcyBlbnF1ZXVlZCBnb3QgY2xvc2VkIGJlZm9yZSBpdCBjb3VsZCBiZVxuICogc2VudCkgYW5kIHRoZSBpdGVtIGNhbiBiZSBzZW50IGJ5IGFueSB0YWIgdGhhdCBmaW5kcyBpdCBpbiBsb2NhbFN0b3JhZ2UuXG4gKlxuICogVGhlIGZpbmFsIGNhbGxiYWNrIHBhcmFtIGlzIGNhbGxlZCB3aXRoIGEgcGFyYW0gaW5kaWNhdGluZyBzdWNjZXNzIG9yXG4gKiBmYWlsdXJlIG9mIHRoZSBlbnF1ZXVlIG9wZXJhdGlvbjsgaXQgaXMgYXN5bmNocm9ub3VzIGJlY2F1c2UgdGhlIGxvY2FsU3RvcmFnZVxuICogbG9jayBpcyBhc3luY2hyb25vdXMuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW0sIGZsdXNoSW50ZXJ2YWwsIGNiKSB7XG4gICAgdmFyIHF1ZXVlRW50cnkgPSB7XG4gICAgICAgICdpZCc6IGNoZWFwX2d1aWQoKSxcbiAgICAgICAgJ2ZsdXNoQWZ0ZXInOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGZsdXNoSW50ZXJ2YWwgKiAyLFxuICAgICAgICAncGF5bG9hZCc6IGl0ZW1cbiAgICB9O1xuXG4gICAgdGhpcy5sb2NrLndpdGhMb2NrKF8uYmluZChmdW5jdGlvbiBsb2NrQWNxdWlyZWQoKSB7XG4gICAgICAgIHZhciBzdWNjZWVkZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVkUXVldWUgPSB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgc3RvcmVkUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdG8gaW4tbWVtb3J5IHF1ZXVlIHdoZW4gc3RvcmFnZSBzdWNjZWVkc1xuICAgICAgICAgICAgICAgIHRoaXMubWVtUXVldWUucHVzaChxdWV1ZUVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmVycm9yKCdFcnJvciBlbnF1ZXVlaW5nIGl0ZW0nLCBpdGVtKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2Ioc3VjY2VlZGVkKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpLCBmdW5jdGlvbiBsb2NrRmFpbHVyZShlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMucGlkKTtcbn07XG5cbi8qKlxuICogUmVhZCBvdXQgdGhlIGdpdmVuIG51bWJlciBvZiBxdWV1ZSBlbnRyaWVzLiBJZiB0aGlzLm1lbVF1ZXVlXG4gKiBoYXMgZmV3ZXIgdGhhbiBiYXRjaFNpemUgaXRlbXMsIHRoZW4gbG9vayBmb3IgXCJvcnBoYW5lZFwiIGl0ZW1zXG4gKiBpbiB0aGUgcGVyc2lzdGVkIHF1ZXVlIChpdGVtcyB3aGVyZSB0aGUgJ2ZsdXNoQWZ0ZXInIHRpbWUgaGFzXG4gKiBhbHJlYWR5IHBhc3NlZCkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZmlsbEJhdGNoID0gZnVuY3Rpb24oYmF0Y2hTaXplKSB7XG4gICAgdmFyIGJhdGNoID0gdGhpcy5tZW1RdWV1ZS5zbGljZSgwLCBiYXRjaFNpemUpO1xuICAgIGlmIChiYXRjaC5sZW5ndGggPCBiYXRjaFNpemUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCBsb2NrIGp1c3QgdG8gcmVhZCBldmVudHM7IGxvY2FsU3RvcmFnZSBpcyB0aHJlYWQtc2FmZVxuICAgICAgICAvLyBhbmQgdGhlIHdvcnN0IHRoYXQgY291bGQgaGFwcGVuIGlzIGEgZHVwbGljYXRlIHNlbmQgb2Ygc29tZVxuICAgICAgICAvLyBvcnBoYW5lZCBldmVudHMsIHdoaWNoIHdpbGwgYmUgZGVkdXBsaWNhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICB2YXIgc3RvcmVkUXVldWUgPSB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICBpZiAoc3RvcmVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgIHZhciBpZHNJbkJhdGNoID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uKGl0ZW0pIHsgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7IH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3JlZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5vcnBoYW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmF0Y2g7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nICdpZCcgZnJvbSBhcnJheSAoaW1tdXRhYmx5KVxuICogYWxzbyByZW1vdmUgYW55IGl0ZW0gd2l0aG91dCBhIHZhbGlkIGlkIChlLmcuLCBtYWxmb3JtZWRcbiAqIHN0b3JhZ2UgZW50cmllcykuXG4gKi9cbnZhciBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkID0gZnVuY3Rpb24oaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW1bJ2lkJ10gJiYgIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRJdGVtcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgSURzIGZyb20gYm90aCBpbi1tZW1vcnkgcXVldWVcbiAqIGFuZCBwZXJzaXN0ZWQgcXVldWVcbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVJdGVtc0J5SUQgPSBmdW5jdGlvbihpZHMsIGNiKSB7XG4gICAgdmFyIGlkU2V0ID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgXy5lYWNoKGlkcywgZnVuY3Rpb24oaWQpIHsgaWRTZXRbaWRdID0gdHJ1ZTsgfSk7XG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gZmlsdGVyT3V0SURzQW5kSW52YWxpZCh0aGlzLm1lbVF1ZXVlLCBpZFNldCk7XG4gICAgdGhpcy5sb2NrLndpdGhMb2NrKF8uYmluZChmdW5jdGlvbiBsb2NrQWNxdWlyZWQoKSB7XG4gICAgICAgIHZhciBzdWNjZWVkZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVkUXVldWUgPSB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGl0ZW1zJywgaWRzKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2Ioc3VjY2VlZGVkKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpLCBmdW5jdGlvbiBsb2NrRmFpbHVyZShlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMucGlkKTtcbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbihleGlzdGluZ0l0ZW1zLCBpdGVtc1RvVXBkYXRlKSB7XG4gICAgdmFyIG5ld0l0ZW1zID0gW107XG4gICAgXy5lYWNoKGV4aXN0aW5nSXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbVsnaWQnXTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXlsb2FkID0gaXRlbXNUb1VwZGF0ZVtpZF07XG4gICAgICAgICAgICBpZiAobmV3UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bJ3BheWxvYWQnXSA9IG5ld1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXdJdGVtcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHBheWxvYWRzIG9mIGdpdmVuIGl0ZW1zIGluIGJvdGggaW4tbWVtb3J5IHF1ZXVlIGFuZFxuICogcGVyc2lzdGVkIHF1ZXVlLiBJdGVtcyBzZXQgdG8gbnVsbCBhcmUgcmVtb3ZlZCBmcm9tIHF1ZXVlcy5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS51cGRhdGVQYXlsb2FkcyA9IGZ1bmN0aW9uKGl0ZW1zVG9VcGRhdGUsIGNiKSB7XG4gICAgdGhpcy5tZW1RdWV1ZSA9IHVwZGF0ZVBheWxvYWRzKHRoaXMubWVtUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgIHRoaXMubG9jay53aXRoTG9jayhfLmJpbmQoZnVuY3Rpb24gbG9ja0FjcXVpcmVkKCkge1xuICAgICAgICB2YXIgc3VjY2VlZGVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHN0b3JlZFF1ZXVlID0gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIHN0b3JlZFF1ZXVlID0gdXBkYXRlUGF5bG9hZHMoc3RvcmVkUXVldWUsIGl0ZW1zVG9VcGRhdGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmVycm9yKCdFcnJvciB1cGRhdGluZyBpdGVtcycsIGl0ZW1zVG9VcGRhdGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihzdWNjZWVkZWQpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyksIGZ1bmN0aW9uIGxvY2tGYWlsdXJlKGVycikge1xuICAgICAgICBsb2dnZXIkMS5lcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcy5waWQpO1xufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdG9yYWdlRW50cnk7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZUVudHJ5ID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgc3RvcmFnZUVudHJ5ID0gSlNPTlBhcnNlKHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShzdG9yYWdlRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ0ludmFsaWQgc3RvcmFnZSBlbnRyeTonLCBzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyJDEuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICBzdG9yYWdlRW50cnkgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmFnZUVudHJ5IHx8IFtdO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGl0ZW1zIGFycmF5IHRvIGxvY2FsU3RvcmFnZS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5zYXZlVG9TdG9yYWdlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXksIEpTT05TdHJpbmdpZnkocXVldWUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlciQxLmVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWVzIChtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZSkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbi8vIG1heGltdW0gaW50ZXJ2YWwgYmV0d2VlbiByZXF1ZXN0IHJldHJpZXMgYWZ0ZXIgZXhwb25lbnRpYWwgYmFja29mZlxudmFyIE1BWF9SRVRSWV9JTlRFUlZBTF9NUyA9IDEwICogNjAgKiAxMDAwOyAvLyAxMCBtaW51dGVzXG5cbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLnF1ZXVlID0gbmV3IFJlcXVlc3RRdWV1ZShzdG9yYWdlS2V5LCB7c3RvcmFnZTogb3B0aW9ucy5zdG9yYWdlfSk7XG5cbiAgICB0aGlzLmxpYkNvbmZpZyA9IG9wdGlvbnMubGliQ29uZmlnO1xuICAgIHRoaXMuc2VuZFJlcXVlc3QgPSBvcHRpb25zLnNlbmRSZXF1ZXN0RnVuYztcbiAgICB0aGlzLmJlZm9yZVNlbmRIb29rID0gb3B0aW9ucy5iZWZvcmVTZW5kSG9vaztcblxuICAgIC8vIHNlZWQgdmFyaWFibGUgYmF0Y2ggc2l6ZSArIGZsdXNoIGludGVydmFsIHdpdGggY29uZmlndXJlZCB2YWx1ZXNcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJ107XG5cbiAgICB0aGlzLnN0b3BwZWQgPSAhdGhpcy5saWJDb25maWdbJ2JhdGNoX2F1dG9zdGFydCddO1xufTtcblxuLyoqXG4gKiBBZGQgb25lIGl0ZW0gdG8gcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24oaXRlbSwgY2IpIHtcbiAgICB0aGlzLnF1ZXVlLmVucXVldWUoaXRlbSwgdGhpcy5mbHVzaEludGVydmFsLCBjYik7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGZsdXNoaW5nIGJhdGNoZXMgYXQgdGhlIGNvbmZpZ3VyZWQgdGltZSBpbnRlcnZhbC4gTXVzdCBjYWxsXG4gKiB0aGlzIG1ldGhvZCB1cG9uIFNESyBpbml0IGluIG9yZGVyIHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yay5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIGZsdXNoaW5nIGJhdGNoZXMuIENhbiBiZSByZXN0YXJ0ZWQgYnkgY2FsbGluZyBzdGFydCgpLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMudGltZW91dElEID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5xdWV1ZS5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGJhdGNoIHNpemUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRCYXRjaFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgZmx1c2ggaW50ZXJ2YWwgdGltZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2hlZHVsZUZsdXNoKHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddKTtcbn07XG5cbi8qKlxuICogU2NoZWR1bGUgdGhlIG5leHQgZmx1c2ggaW4gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zY2hlZHVsZUZsdXNoID0gZnVuY3Rpb24oZmx1c2hNUykge1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IGZsdXNoTVM7XG4gICAgaWYgKCF0aGlzLnN0b3BwZWQpIHsgLy8gZG9uJ3Qgc2NoZWR1bGUgYW55bW9yZSBpZiBiYXRjaGluZyBoYXMgYmVlbiBzdG9wcGVkXG4gICAgICAgIHRoaXMudGltZW91dElEID0gc2V0VGltZW91dChfLmJpbmQodGhpcy5mbHVzaCwgdGhpcyksIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCBvbmUgYmF0Y2ggdG8gbmV0d29yay4gRGVwZW5kaW5nIG9uIHN1Y2Nlc3MvZmFpbHVyZSBtb2RlcywgaXQgd2lsbCBlaXRoZXJcbiAqIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgcXVldWUgb3IgbGVhdmUgaXQgaW4gZm9yIHJldHJ5LCBhbmQgc2NoZWR1bGUgdGhlIG5leHRcbiAqIGZsdXNoLiBJbiBjYXNlcyBvZiBtb3N0IG5ldHdvcmsgb3IgQVBJIGZhaWx1cmVzLCBpdCB3aWxsIGJhY2sgb2ZmIGV4cG9uZW50aWFsbHlcbiAqIHdoZW4gcmV0cnlpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRCZWFjb25dIC0gd2hldGhlciB0byBzZW5kIGJhdGNoIHdpdGhcbiAqIG5hdmlnYXRvci5zZW5kQmVhY29uIChvbmx5IHVzZWZ1bCBmb3Igc2VuZGluZyBiYXRjaGVzIGJlZm9yZSBwYWdlIHVubG9hZHMsIGFzXG4gKiBzZW5kQmVhY29uIG9mZmVycyBubyBjYWxsYmFja3Mgb3Igc3RhdHVzIGluZGljYXRpb25zKVxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdHJ5IHtcblxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnRmx1c2g6IFJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJ107XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRCYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5xdWV1ZS5maWxsQmF0Y2goY3VycmVudEJhdGNoU2l6ZSk7XG4gICAgICAgIHZhciBkYXRhRm9yUmVxdWVzdCA9IFtdO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRJdGVtcyA9IHt9O1xuICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gaXRlbVsncGF5bG9hZCddO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmVmb3JlU2VuZEhvb2sgJiYgIWl0ZW0ub3JwaGFuZWQpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gdGhpcy5iZWZvcmVTZW5kSG9vayhwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgZGF0YUZvclJlcXVlc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybWVkSXRlbXNbaXRlbVsnaWQnXV0gPSBwYXlsb2FkO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKGRhdGFGb3JSZXF1ZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYmF0Y2hTZW5kQ2FsbGJhY2sgPSBfLmJpbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgQVBJIHJlc3BvbnNlIGluIGEgdHJ5LWNhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBjYW4gcmVzZXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmx1c2ggb3BlcmF0aW9uIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlSXRlbXNGcm9tUXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBlcnNpc3RlZCBkYXRhIHRvIGluY2x1ZGUgaG9vayB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS51cGRhdGVQYXlsb2Fkcyh0cmFuc2Zvcm1lZEl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVycm9yID09PSAndGltZW91dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPj0gdGltZW91dE1TXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignTmV0d29yayB0aW1lb3V0OyByZXRyeWluZycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgIHJlcy54aHJfcmVxICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXMueGhyX3JlcVsnc3RhdHVzJ10gPj0gNTAwIHx8IHJlcy54aHJfcmVxWydzdGF0dXMnXSA8PSAwKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIG9yIEFQSSBlcnJvciwgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHJ5TVMgPSB0aGlzLmZsdXNoSW50ZXJ2YWwgKiAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlcy54aHJfcmVxWydyZXNwb25zZUhlYWRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeUFmdGVyID0gaGVhZGVyc1snUmV0cnktQWZ0ZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IChwYXJzZUludChyZXRyeUFmdGVyLCAxMCkgKiAxMDAwKSB8fCByZXRyeU1TO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSBNYXRoLm1pbihNQVhfUkVUUllfSU5URVJWQUxfTVMsIHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yOyByZXRyeSBpbiAnICsgcmV0cnlNUyArICcgbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUZsdXNoKHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXMpICYmIHJlcy54aHJfcmVxICYmIHJlcy54aHJfcmVxWydzdGF0dXMnXSA9PT0gNDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQxMyBQYXlsb2FkIFRvbyBMYXJnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbHZlZEJhdGNoU2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoY3VycmVudEJhdGNoU2l6ZSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5iYXRjaFNpemUsIGhhbHZlZEJhdGNoU2l6ZSwgYmF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJzQxMyByZXNwb25zZTsgcmVkdWNpbmcgYmF0Y2ggc2l6ZSB0byAnICsgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1NpbmdsZS1ldmVudCByZXF1ZXN0IHRvbyBsYXJnZTsgZHJvcHBpbmcnLCBiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVJdGVtc0Zyb21RdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG5ldHdvcmsgcmVxdWVzdCtyZXNwb25zZTsgcmVtb3ZlIGVhY2ggaXRlbSBpbiBiYXRjaCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC8vIChldmVuIGlmIGl0IHdhcyBlLmcuIGEgNDAwLCBpbiB3aGljaCBjYXNlIHJldHJ5aW5nIHdvbid0IGhlbHApXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlSXRlbXNGcm9tUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmVJdGVtc0J5SUQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChiYXRjaCwgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbVsnaWQnXTsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5mbHVzaCwgdGhpcykgLy8gaGFuZGxlIG5leHQgYmF0Y2ggaWYgdGhlIHF1ZXVlIGlzbid0IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgaGFuZGxpbmcgQVBJIHJlc3BvbnNlJywgZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdmVyYm9zZTogdHJ1ZSxcbiAgICAgICAgICAgIGlnbm9yZV9qc29uX2Vycm9yczogdHJ1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgIHRpbWVvdXRfbXM6IHRpbWVvdXRNUyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnRyYW5zcG9ydCA9ICdzZW5kQmVhY29uJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicsIGRhdGFGb3JSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChkYXRhRm9yUmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMsIGJhdGNoU2VuZENhbGxiYWNrKTtcblxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZmx1c2hpbmcgcmVxdWVzdCBxdWV1ZScsIGVycik7XG4gICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGEgTWl4cGFuZWwgZXZlbnQgKGUuZy4gTWl4cGFuZWxMaWIudHJhY2spXG4gKiBAY2FsbGJhY2sgdHJhY2tGdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cblxuLyoqIFB1YmxpYyAqKi9cblxudmFyIEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVggPSAnX19tcF9vcHRfaW5fb3V0Xyc7XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dCh0cnVlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtb3V0IGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dChmYWxzZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMSc7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGhhcyBcIkRvIE5vdCBUcmFja1wiIGVuYWJsZWQuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLiBUbyBpZ25vcmUgdGhlIFwiRG8gTm90IFRyYWNrXCIgYnJvd3NlciBzZXR0aW5nLCBpbml0aWFsaXplIHRoZSBNaXhwYW5lbCBpbnN0YW5jZSB3aXRoIHRoZSBjb25maWcgXCJpZ25vcmVfZG50OiB0cnVlXCInKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvcHRlZE91dCA9IF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMCc7XG4gICAgaWYgKG9wdGVkT3V0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignWW91IGFyZSBvcHRlZCBvdXQgb2YgTWl4cGFuZWwgdHJhY2tpbmcuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0ZWRPdXQ7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsTGliIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbFBlb3BsZSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsR3JvdXAgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsZWFyT3B0SW5PdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5yZW1vdmUoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSwgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLCBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG59XG5cbi8qKiBQcml2YXRlICoqL1xuXG4vKipcbiAqIEdldCBzdG9yYWdlIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlaXRoZXIgXy5jb29raWUgb3IgXy5sb2NhbHN0b3JhZ2VcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnBlcnNpc3RlbmNlVHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgPyBfLmxvY2FsU3RvcmFnZSA6IF8uY29va2llO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIChvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4IHx8IEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVgpICsgdG9rZW47XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlKG9wdGlvbnMpLmdldChfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHNldCB0aGUgRE5UL2RvTm90VHJhY2sgc2V0dGluZyB0byB0cnVlIGluIHRoZWlyIGJyb3dzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53aW5kb3ddIC0gYWx0ZXJuYXRlIHdpbmRvdyBvYmplY3QgdG8gY2hlY2s7IHVzZWQgdG8gZm9yY2UgdmFyaW91cyBETlQgc2V0dGluZ3MgaW4gYnJvd3NlciB0ZXN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBETlQgc2V0dGluZyBpcyB0cnVlXG4gKi9cbmZ1bmN0aW9uIF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZURudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB3aW4gPSAob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvdykgfHwgd2luZG93JDE7XG4gICAgdmFyIG5hdiA9IHdpblsnbmF2aWdhdG9yJ10gfHwge307XG4gICAgdmFyIGhhc0RudE9uID0gZmFsc2U7XG5cbiAgICBfLmVhY2goW1xuICAgICAgICBuYXZbJ2RvTm90VHJhY2snXSwgLy8gc3RhbmRhcmRcbiAgICAgICAgbmF2Wydtc0RvTm90VHJhY2snXSxcbiAgICAgICAgd2luWydkb05vdFRyYWNrJ11cbiAgICBdLCBmdW5jdGlvbihkbnRWYWx1ZSkge1xuICAgICAgICBpZiAoXy5pbmNsdWRlcyhbdHJ1ZSwgMSwgJzEnLCAneWVzJ10sIGRudFZhbHVlKSkge1xuICAgICAgICAgICAgaGFzRG50T24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGFzRG50T247XG59XG5cbi8qKlxuICogU2V0IGNvb2tpZS9sb2NhbHN0b3JhZ2UgZm9yIHRoZSB1c2VyIGluZGljYXRpbmcgdGhhdCB0aGV5IGFyZSBvcHRlZCBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRWYWx1ZSAtIHdoZXRoZXIgdG8gb3B0IHRoZSB1c2VyIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3RyYWNrRnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSAtIGZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tFdmVudE5hbWVdIC0gZXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrUHJvcGVydGllc10gLSBzZXQgb2YgcHJvcGVydGllcyB0byBiZSB0cmFja2VkIGFsb25nIHdpdGggdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIF9vcHRJbk91dChvcHRWYWx1ZSwgdG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcodG9rZW4pIHx8ICF0b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2Rwci4nICsgKG9wdFZhbHVlID8gJ29wdEluJyA6ICdvcHRPdXQnKSArICcgY2FsbGVkIHdpdGggYW4gaW52YWxpZCB0b2tlbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5zZXQoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSxcbiAgICAgICAgb3B0VmFsdWUgPyAxIDogMCxcbiAgICAgICAgXy5pc051bWJlcihvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24pID8gb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uIDogbnVsbCxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTaXRlQ29va2llLFxuICAgICAgICBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy50cmFjayAmJiBvcHRWYWx1ZSkgeyAvLyBvbmx5IHRyYWNrIGV2ZW50IGlmIG9wdGluZyBpbiAob3B0VmFsdWU9dHJ1ZSlcbiAgICAgICAgb3B0aW9ucy50cmFjayhvcHRpb25zLnRyYWNrRXZlbnROYW1lIHx8ICckb3B0X2luJywgb3B0aW9ucy50cmFja1Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdzZW5kX2ltbWVkaWF0ZWx5JzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldENvbmZpZ1ZhbHVlIC0gZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgTWl4cGFuZWwgQVBJIHRva2VuIGFuZCBvdGhlciBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBvcHQtb3V0IGNoZWNrXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGdldENvbmZpZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0ZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVEbnQgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdpZ25vcmVfZG50Jyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VUeXBlID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VQcmVmaXggPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd3aW5kb3cnKTsgLy8gdXNlZCB0byBvdmVycmlkZSB3aW5kb3cgZHVyaW5nIGJyb3dzZXIgdGVzdHNcblxuICAgICAgICAgICAgaWYgKHRva2VuKSB7IC8vIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBnZXR0aW5nIHRoZSB0b2tlbiwgY29udGludWUgbWV0aG9kIGV4ZWN1dGlvbiBhcyBub3JtYWxcbiAgICAgICAgICAgICAgICBvcHRlZE91dCA9IGhhc09wdGVkT3V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZURudDogaWdub3JlRG50LFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IHBlcnNpc3RlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IHBlcnNpc3RlbmNlUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIGNoZWNraW5nIHRyYWNraW5nIG9wdC1vdXQgc3RhdHVzOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0ZWRPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG4vKiogQGNvbnN0ICovIHZhciBTRVRfQUNUSU9OICAgICAgPSAnJHNldCc7XG4vKiogQGNvbnN0ICovIHZhciBTRVRfT05DRV9BQ1RJT04gPSAnJHNldF9vbmNlJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX0FDVElPTiAgICA9ICckdW5zZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX0FDVElPTiAgICAgID0gJyRhZGQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX0FDVElPTiAgID0gJyRhcHBlbmQnO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5JT05fQUNUSU9OICAgID0gJyR1bmlvbic7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfQUNUSU9OICAgPSAnJHJlbW92ZSc7XG4vKiogQGNvbnN0ICovIHZhciBERUxFVEVfQUNUSU9OICAgPSAnJGRlbGV0ZSc7XG5cbi8vIENvbW1vbiBpbnRlcm5hbCBtZXRob2RzIGZvciBtaXhwYW5lbC5wZW9wbGUgYW5kIG1peHBhbmVsLmdyb3VwIEFQSXMuXG4vLyBUaGVzZSBtZXRob2RzIHNob3VsZG4ndCBpbnZvbHZlIG5ldHdvcmsgSS9PLlxudmFyIGFwaUFjdGlvbnMgPSB7XG4gICAgc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCwgdG8pIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRzZXQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0W2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRbcHJvcF0gPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl0gPSAkc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5zZXRfYWN0aW9uOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkdW5zZXQgPSBbXTtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgIHByb3AgPSBbcHJvcF07XG4gICAgICAgIH1cblxuICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICR1bnNldC5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBkYXRhW1VOU0VUX0FDVElPTl0gPSAkdW5zZXQ7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBzZXRfb25jZV9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0X29uY2UgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkc2V0X29uY2Vba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNldF9vbmNlW3Byb3BdID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtTRVRfT05DRV9BQ1RJT05dID0gJHNldF9vbmNlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgdW5pb25fYWN0aW9uOiBmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuaW9uID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgICAgIF8uZWFjaChsaXN0X25hbWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgICR1bmlvbltrXSA9IF8uaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdW5pb25bbGlzdF9uYW1lXSA9IF8uaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogW3ZhbHVlc107XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtVTklPTl9BQ1RJT05dID0gJHVuaW9uO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgYXBwZW5kX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJGFwcGVuZCA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhcHBlbmRbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbQVBQRU5EX0FDVElPTl0gPSAkYXBwZW5kO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHJlbW92ZSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkcmVtb3ZlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyZW1vdmVbbGlzdF9uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbUkVNT1ZFX0FDVElPTl0gPSAkcmVtb3ZlO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgZGVsZXRlX2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGRhdGFbREVMRVRFX0FDVElPTl0gPSAnJztcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNaXhwYW5lbCBHcm91cCBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxHcm91cCA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsR3JvdXAucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSwgZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgdGhpcy5fZ3JvdXBfa2V5ID0gZ3JvdXBfa2V5O1xuICAgIHRoaXMuX2dyb3VwX2lkID0gZ3JvdXBfaWQ7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBncm91cCBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuICogZ3JvdXAuc2V0KCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2Uoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgbGlzdHMgb3IgZGF0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFVuc2V0IHByb3BlcnRpZXMgb24gYSBncm91cCBwZXJtYW5lbnRseS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuc2V0KCdGb3VuZGVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIGdyb3VwIHByb3BlcnR5LCBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bmlvbignTG9jYXRpb24nLCBbJ1NhbiBGcmFuY2lzY28nLCAnTG9uZG9uJ10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUGVybWFuZW50bHkgZGVsZXRlIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLmRlbGV0ZSgpO1xuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGVsZXRlX2FjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgZnJvbSBhIGdyb3VwLiBUaGUgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGlmIGRvZXNuJ3QgZXhpc3QuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5yZW1vdmUoJ0xvY2F0aW9uJywgJ0xvbmRvbicpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gcmVtb3ZlIGZyb20gdGhlIGdpdmVuIGdyb3VwIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyRncm91cF9rZXknXSA9IHRoaXMuX2dyb3VwX2tleTtcbiAgICBkYXRhWyckZ3JvdXBfaWQnXSA9IHRoaXMuX2dyb3VwX2lkO1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdncm91cHMnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX2dldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnL2dyb3Vwcy8nLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLmdyb3Vwc1xuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRncm91cF9rZXknIHx8IHByb3AgPT09ICckZ3JvdXBfaWQnO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZik7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5ncm91cC4nICsgdGhpcy5fZ3JvdXBfa2V5ICsgJy4nICsgdGhpcy5fZ3JvdXBfaWQ7XG59O1xuXG4vLyBNaXhwYW5lbEdyb3VwIEV4cG9ydHNcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydyZW1vdmUnXSAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldCddICAgICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0X29uY2UnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3VuaW9uJ10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bnNldCddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndG9TdHJpbmcnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcHMnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfUVVFVUVfS0VZICAgICA9ICdfX21wc28nO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfUVVFVUVfS0VZICAgICAgICA9ICdfX21wdXMnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX1FVRVVFX0tFWSAgICAgICAgICA9ICdfX21wYSc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfUVVFVUVfS0VZICAgICAgID0gJ19fbXBhcCc7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfUVVFVUVfS0VZICAgICAgID0gJ19fbXByJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHUnO1xuLy8gVGhpcyBrZXkgaXMgZGVwcmVjYXRlZCwgYnV0IHdlIHdhbnQgdG8gY2hlY2sgZm9yIGl0IHRvIHNlZSB3aGV0aGVyIGFsaWFzaW5nIGlzIGFsbG93ZWQuXG4vKiogQGNvbnN0ICovIHZhciBQRU9QTEVfRElTVElOQ1RfSURfS0VZID0gJyRwZW9wbGVfZGlzdGluY3RfaWQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUxJQVNfSURfS0VZICAgICAgICAgICA9ICdfX2FsaWFzJztcbi8qKiBAY29uc3QgKi8gdmFyIENBTVBBSUdOX0lEU19LRVkgICAgICAgPSAnX19jbXBucyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBDQU1QQUlHTl9JRFNfS0VZLFxuICAgIEVWRU5UX1RJTUVSU19LRVlcbl07XG5cbi8qKlxuICogTWl4cGFuZWwgUGVyc2lzdGVuY2UgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsUGVyc2lzdGVuY2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG4gICAgdGhpcy5jYW1wYWlnbl9wYXJhbXNfc2F2ZWQgPSBmYWxzZTtcblxuICAgIGlmIChjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXSkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sncGVyc2lzdGVuY2VfbmFtZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdtcF8nICsgY29uZmlnWyd0b2tlbiddICsgJ19taXhwYW5lbCc7XG4gICAgfVxuXG4gICAgdmFyIHN0b3JhZ2VfdHlwZSA9IGNvbmZpZ1sncGVyc2lzdGVuY2UnXTtcbiAgICBpZiAoc3RvcmFnZV90eXBlICE9PSAnY29va2llJyAmJiBzdG9yYWdlX3R5cGUgIT09ICdsb2NhbFN0b3JhZ2UnKSB7XG4gICAgICAgIGNvbnNvbGUuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoY29uZmlnKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuICAgIC8vIEZpbHRlciBvdXQgcmVzZXJ2ZWQgcHJvcGVydGllc1xuICAgIF8uZWFjaCh0aGlzWydwcm9wcyddLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICghXy5pbmNsdWRlKFJFU0VSVkVEX1BST1BFUlRJRVMsIGspKSB7XG4gICAgICAgICAgICBwW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdGhpc1sncHJvcHMnXSA9IF8uZXh0ZW5kKHt9LCBlbnRyeSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciB1cGdyYWRlX2Zyb21fb2xkX2xpYiA9IGNvbmZpZ1sndXBncmFkZSddLFxuICAgICAgICBvbGRfY29va2llX25hbWUsXG4gICAgICAgIG9sZF9jb29raWU7XG5cbiAgICBpZiAodXBncmFkZV9mcm9tX29sZF9saWIpIHtcbiAgICAgICAgb2xkX2Nvb2tpZV9uYW1lID0gJ21wX3N1cGVyX3Byb3BlcnRpZXMnO1xuICAgICAgICAvLyBDYXNlIHdoZXJlIHRoZXkgaGFkIGEgY3VzdG9tIGNvb2tpZSBuYW1lIGJlZm9yZS5cbiAgICAgICAgaWYgKHR5cGVvZih1cGdyYWRlX2Zyb21fb2xkX2xpYikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvbGRfY29va2llX25hbWUgPSB1cGdyYWRlX2Zyb21fb2xkX2xpYjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZF9jb29raWUgPSB0aGlzLnN0b3JhZ2UucGFyc2Uob2xkX2Nvb2tpZV9uYW1lKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGNvb2tpZVxuICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKG9sZF9jb29raWVfbmFtZSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUob2xkX2Nvb2tpZV9uYW1lLCB0cnVlKTtcblxuICAgICAgICBpZiAob2xkX2Nvb2tpZSkge1xuICAgICAgICAgICAgdGhpc1sncHJvcHMnXSA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgIHRoaXNbJ3Byb3BzJ10sXG4gICAgICAgICAgICAgICAgb2xkX2Nvb2tpZVsnYWxsJ10sXG4gICAgICAgICAgICAgICAgb2xkX2Nvb2tpZVsnZXZlbnRzJ11cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZ1snY29va2llX25hbWUnXSAmJiBjb25maWdbJ25hbWUnXSAhPT0gJ21peHBhbmVsJykge1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gaGFuZGxlIHBlb3BsZSB3aXRoIGNvb2tpZXMgb2YgdGhlIGZvcm1cbiAgICAgICAgLy8gbXBfVE9LRU5fSU5TVEFOQ0VOQU1FIGZyb20gdGhlIGZpcnN0IHJlbGVhc2Ugb2YgdGhpcyBsaWJyYXJ5XG4gICAgICAgIG9sZF9jb29raWVfbmFtZSA9ICdtcF8nICsgY29uZmlnWyd0b2tlbiddICsgJ18nICsgY29uZmlnWyduYW1lJ107XG4gICAgICAgIG9sZF9jb29raWUgPSB0aGlzLnN0b3JhZ2UucGFyc2Uob2xkX2Nvb2tpZV9uYW1lKTtcblxuICAgICAgICBpZiAob2xkX2Nvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShvbGRfY29va2llX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZShvbGRfY29va2llX25hbWUsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBwcm9wIHZhbHVlcyB0aGF0IHdlcmUgaW4gdGhlIGNvb2tpZSBmcm9tIGJlZm9yZSAtXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBvbmNlIGFzIHdlIGRlbGV0ZSB0aGUgb2xkIG9uZS5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfY29va2llKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0b3JhZ2UgPT09IF8ubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIG9sZF9jb29raWUgPSBfLmNvb2tpZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgICAgICBfLmNvb2tpZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlKTtcblxuICAgICAgICBpZiAob2xkX2Nvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKG9sZF9jb29raWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX2V4cGlyZV9ub3RpZmljYXRpb25fY2FtcGFpZ25zKCk7XG4gICAgdGhpcy5zdG9yYWdlLnNldChcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICBfLkpTT05FbmNvZGUodGhpc1sncHJvcHMnXSksXG4gICAgICAgIHRoaXMuZXhwaXJlX2RheXMsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluLFxuICAgICAgICB0aGlzLnNlY3VyZSxcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlLFxuICAgICAgICB0aGlzLmNvb2tpZV9kb21haW5cbiAgICApO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcmVtb3ZlIGJvdGggZG9tYWluIGFuZCBzdWJkb21haW4gY29va2llc1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCBmYWxzZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSwgdGhpcy5jb29raWVfZG9tYWluKTtcbn07XG5cbi8vIHJlbW92ZXMgdGhlIHN0b3JhZ2UgZW50cnkgYW5kIGRlbGV0ZXMgYWxsIGxvYWRlZCBkYXRhXG4vLyBmb3JjZWQgbmFtZSBmb3IgdGVzdHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7Kj19IGRlZmF1bHRfdmFsdWVcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXJfb25jZSA9IGZ1bmN0aW9uKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBkYXlzKSB7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7IGRlZmF1bHRfdmFsdWUgPSAnTm9uZSc7IH1cbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXNbJ3Byb3BzJ10uaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpc1sncHJvcHMnXVtwcm9wXSA9PT0gZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3Byb3BzJ11bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4qIEBwYXJhbSB7bnVtYmVyPX0gZGF5c1xuKi9cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgdGhpcy5leHBpcmVfZGF5cyA9ICh0eXBlb2YoZGF5cykgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMuZGVmYXVsdF9leHBpcnkgOiBkYXlzO1xuXG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ3Byb3BzJ10sIHByb3BzKTtcblxuICAgICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiB0aGlzWydwcm9wcyddKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydwcm9wcyddW3Byb3BdO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZXhwaXJlX25vdGlmaWNhdGlvbl9jYW1wYWlnbnMgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW1wYWlnbnNfc2hvd24gPSB0aGlzWydwcm9wcyddW0NBTVBBSUdOX0lEU19LRVldLFxuICAgICAgICBFWFBJUllfVElNRSA9IENvbmZpZy5ERUJVRyA/IDYwICogMTAwMCA6IDYwICogNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZSAoQ29uZmlnLkRFQlVHKSAvIDEgaG91ciAoUERYTilcbiAgICBpZiAoIWNhbXBhaWduc19zaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGNhbXBhaWduX2lkIGluIGNhbXBhaWduc19zaG93bikge1xuICAgICAgICBpZiAoMSAqIG5ldyBEYXRlKCkgLSBjYW1wYWlnbnNfc2hvd25bY2FtcGFpZ25faWRdID4gRVhQSVJZX1RJTUUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYW1wYWlnbnNfc2hvd25bY2FtcGFpZ25faWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHlPYmplY3QoY2FtcGFpZ25zX3Nob3duKSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtDQU1QQUlHTl9JRFNfS0VZXTtcbiAgICB9XG59KTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NhbXBhaWduX3BhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jYW1wYWlnbl9wYXJhbXNfc2F2ZWQpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKF8uaW5mby5jYW1wYWlnblBhcmFtcygpKTtcbiAgICAgICAgdGhpcy5jYW1wYWlnbl9wYXJhbXNfc2F2ZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9zZWFyY2hfa2V5d29yZCA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgdGhpcy5yZWdpc3RlcihfLmluZm8uc2VhcmNoSW5mbyhyZWZlcnJlcikpO1xufTtcblxuLy8gRVhQT1JURUQgTUVUSE9ELCB3ZSB0ZXN0IHRoaXMgZGlyZWN0bHkuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgLy8gSWYgcmVmZXJyZXIgZG9lc24ndCBleGlzdCwgd2Ugd2FudCB0byBub3RlIHRoZSBmYWN0IHRoYXQgaXQgd2FzIHR5cGUtaW4gdHJhZmZpYy5cbiAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiByZWZlcnJlciB8fCAnJGRpcmVjdCcsXG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihyZWZlcnJlcikgfHwgJyRkaXJlY3QnXG4gICAgfSwgJycpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuZ2V0X3JlZmVycmVyX2luZm8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKHtcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmVyJzogdGhpc1sncHJvcHMnXVsnJGluaXRpYWxfcmVmZXJyZXInXSxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJpbmdfZG9tYWluJ11cbiAgICB9KTtcbn07XG5cbi8vIHNhZmVseSBmaWxscyB0aGUgcGFzc2VkIGluIG9iamVjdCB3aXRoIHN0b3JlZCBwcm9wZXJ0aWVzLFxuLy8gZG9lcyBub3Qgb3ZlcnJpZGUgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBpbiBib3RoXG4vLyByZXR1cm5zIHRoZSBwYXNzZWQgaW4gb2JqZWN0XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zYWZlX21lcmdlID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdF9leHBpcnkgPSB0aGlzLmV4cGlyZV9kYXlzID0gY29uZmlnWydjb29raWVfZXhwaXJhdGlvbiddO1xuICAgIHRoaXMuc2V0X2Rpc2FibGVkKGNvbmZpZ1snZGlzYWJsZV9wZXJzaXN0ZW5jZSddKTtcbiAgICB0aGlzLnNldF9jb29raWVfZG9tYWluKGNvbmZpZ1snY29va2llX2RvbWFpbiddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zaXRlKGNvbmZpZ1snY3Jvc3Nfc2l0ZV9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc3ViZG9tYWluKGNvbmZpZ1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9zZWN1cmUoY29uZmlnWydzZWN1cmVfY29va2llJ10pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Rpc2FibGVkID0gZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY29va2llX2RvbWFpbiA9IGZ1bmN0aW9uKGNvb2tpZV9kb21haW4pIHtcbiAgICBpZiAoY29va2llX2RvbWFpbiAhPT0gdGhpcy5jb29raWVfZG9tYWluKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpbiA9IGNvb2tpZV9kb21haW47XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zaXRlID0gZnVuY3Rpb24oY3Jvc3Nfc2l0ZSkge1xuICAgIGlmIChjcm9zc19zaXRlICE9PSB0aGlzLmNyb3NzX3NpdGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlID0gY3Jvc3Nfc2l0ZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKGNyb3NzX3N1YmRvbWFpbikge1xuICAgIGlmIChjcm9zc19zdWJkb21haW4gIT09IHRoaXMuY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluID0gY3Jvc3Nfc3ViZG9tYWluO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3Nfc3ViZG9tYWluO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X3NlY3VyZSA9IGZ1bmN0aW9uKHNlY3VyZSkge1xuICAgIGlmIChzZWN1cmUgIT09IHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fYWRkX3RvX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHFfa2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSksXG4gICAgICAgIHFfZGF0YSA9IGRhdGFbcXVldWVdLFxuICAgICAgICBzZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX0FDVElPTiksXG4gICAgICAgIHNldF9vbmNlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiksXG4gICAgICAgIHVuc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOU0VUX0FDVElPTiksXG4gICAgICAgIGFkZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBRERfQUNUSU9OKSxcbiAgICAgICAgdW5pb25fcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5JT05fQUNUSU9OKSxcbiAgICAgICAgcmVtb3ZlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIFtdKSxcbiAgICAgICAgYXBwZW5kX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIFtdKTtcblxuICAgIGlmIChxX2tleSA9PT0gU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldCBxdWV1ZSAtIHdlIGNhbiBvdmVycmlkZSBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgIF8uZXh0ZW5kKHNldF9xLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGluY3JlbWVudCwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyB1bmlvbiwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFNFVF9PTkNFX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBvbmx5IHF1ZXVlIHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc2V0X29uY2UgY2FsbCBmb3IgaXQuXG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghKGsgaW4gc2V0X29uY2VfcSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfb25jZV9xW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5TRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHByb3ApIHtcblxuICAgICAgICAgICAgLy8gdW5kbyBwcmV2aW91c2x5LXF1ZXVlZCBhY3Rpb25zIG9uIHRoaXMga2V5XG4gICAgICAgICAgICBfLmVhY2goW3NldF9xLCBzZXRfb25jZV9xLCBhZGRfcSwgdW5pb25fcV0sIGZ1bmN0aW9uKGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5xdWV1ZWRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKGFwcGVuZF9xLCBmdW5jdGlvbihhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwZW5kX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdW5zZXRfcVtwcm9wXSA9IHRydWU7XG5cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQUREX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBleGlzdHMgaW4gdGhlIHNldCBxdWV1ZSwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChrIGluIHNldF9xKSB7XG4gICAgICAgICAgICAgICAgc2V0X3Fba10gKz0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdXBkYXRlIHRoZSBhZGRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZVxuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gYWRkX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9xW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkX3Fba10gKz0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5JT05fUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIHVuaW9uX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHNlbmQgZHVwbGljYXRlcywgdGhlIHNlcnZlciB3aWxsIGRlZHVwIHRoZW0uXG4gICAgICAgICAgICAgICAgdW5pb25fcVtrXSA9IHVuaW9uX3Fba10uY29uY2F0KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBSRU1PVkVfUVVFVUVfS0VZKSB7XG4gICAgICAgIHJlbW92ZV9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQVBQRU5EX1FVRVVFX0tFWSkge1xuICAgICAgICBhcHBlbmRfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ01JWFBBTkVMIFBFT1BMRSBSRVFVRVNUIChRVUVVRUQsIFBFTkRJTkcgSURFTlRJRlkpOicpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuXG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRhdGEpIHtcbiAgICB2YXIgcSA9IHRoaXMuX2dldF9xdWV1ZShxdWV1ZSk7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHEpKSB7XG4gICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAocXVldWUgPT09IEFQUEVORF9BQ1RJT04gfHwgcXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnM6IG9ubHkgcmVtb3ZlIGlmIGJvdGggayt2IG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gZS5nLiByZW1vdmUgc2hvdWxkIG5vdCBvdmVycmlkZSBhcHBlbmQgaW4gYSBjYXNlIGxpa2VcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQoe2ZvbzogJ2Jhcid9KTsgcmVtb3ZlKHtmb286ICdxdXgnfSlcbiAgICAgICAgICAgICAgICBfLmVhY2gocSwgZnVuY3Rpb24ocXVldWVkX2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVkX2FjdGlvbltrXSA9PT0gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlZF9hY3Rpb25ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHFba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfcXVldWVfa2V5ID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICBpZiAocXVldWUgPT09IFNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gU0VUX09OQ0VfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfT05DRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5TRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTlNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQUREX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQUREX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBUFBFTkRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFJFTU9WRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5JT05fQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTklPTl9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBxdWV1ZTonLCBxdWV1ZSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX2dldF9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11bdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSldO1xufTtcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfb3JfY3JlYXRlX3F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGRlZmF1bHRfdmFsKSB7XG4gICAgdmFyIGtleSA9IHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpO1xuICAgIGRlZmF1bHRfdmFsID0gXy5pc1VuZGVmaW5lZChkZWZhdWx0X3ZhbCkgPyB7fSA6IGRlZmF1bHRfdmFsO1xuXG4gICAgcmV0dXJuIHRoaXNbJ3Byb3BzJ11ba2V5XSB8fCAodGhpc1sncHJvcHMnXVtrZXldID0gZGVmYXVsdF92YWwpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2V2ZW50X3RpbWVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZSwgdGltZXN0YW1wKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gfHwge307XG4gICAgdGltZXJzW2V2ZW50X25hbWVdID0gdGltZXN0YW1wO1xuICAgIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gPSB0aW1lcnM7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmVfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gfHwge307XG4gICAgdmFyIHRpbWVzdGFtcCA9IHRpbWVyc1tldmVudF9uYW1lXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGltZXN0YW1wKSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtFVkVOVF9USU1FUlNfS0VZXVtldmVudF9uYW1lXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXA7XG59O1xuXG4vKlxuICogVGhpcyBmaWxlIGlzIGEganMgaW1wbGVtZW50YXRpb24gZm9yIGEgc3Vic2V0IGluIGV2YWxfbm9kZS5jXG4gKi9cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vLyBNZXRhZGF0YSBrZXlzXG4vKiogQGNvbnN0ICovICAgdmFyIE9QRVJBVE9SX0tFWSAgICAgICAgICAgICAgICAgID0gJ29wZXJhdG9yJztcbi8qKiBAY29uc3QgKi8gICB2YXIgUFJPUEVSVFlfS0VZICAgICAgICAgICAgICAgICAgPSAncHJvcGVydHknO1xuLyoqIEBjb25zdCAqLyAgIHZhciBXSU5ET1dfS0VZICAgICAgICAgICAgICAgICAgICA9ICd3aW5kb3cnO1xuLyoqIEBjb25zdCAqLyAgIHZhciBVTklUX0tFWSAgICAgICAgICAgICAgICAgICAgICA9ICd1bml0Jztcbi8qKiBAY29uc3QgKi8gICB2YXIgVkFMVUVfS0VZICAgICAgICAgICAgICAgICAgICAgPSAndmFsdWUnO1xuLyoqIEBjb25zdCAqLyAgIHZhciBIT1VSX0tFWSAgICAgICAgICAgICAgICAgICAgICA9ICdob3VyJztcbi8qKiBAY29uc3QgKi8gICB2YXIgREFZX0tFWSAgICAgICAgICAgICAgICAgICAgICAgPSAnZGF5Jztcbi8qKiBAY29uc3QgKi8gICB2YXIgV0VFS19LRVkgICAgICAgICAgICAgICAgICAgICAgPSAnd2Vlayc7XG4vKiogQGNvbnN0ICovICAgdmFyIE1PTlRIX0tFWSAgICAgICAgICAgICAgICAgICAgID0gJ21vbnRoJztcblxuLy8gT3BlcmFuZHNcbi8qKiBAY29uc3QgKi8gICB2YXIgRVZFTlRfUFJPUEVSVFkgICAgICAgICA9ICdldmVudCc7XG4vKiogQGNvbnN0ICovICAgdmFyIExJVEVSQUxfUFJPUEVSVFkgICAgICAgPSAnbGl0ZXJhbCc7XG5cbi8vIEJpbmFyeSBPcGVyYXRvcnNcbi8qKiBAY29uc3QgKi8gICB2YXIgQU5EX09QRVJBVE9SICAgICAgICAgICA9ICdhbmQnO1xuLyoqIEBjb25zdCAqLyAgIHZhciBPUl9PUEVSQVRPUiAgICAgICAgICAgID0gJ29yJztcbi8qKiBAY29uc3QgKi8gICB2YXIgSU5fT1BFUkFUT1IgICAgICAgICAgICA9ICdpbic7XG4vKiogQGNvbnN0ICovICAgdmFyIE5PVF9JTl9PUEVSQVRPUiAgICAgICAgPSAnbm90IGluJztcbi8qKiBAY29uc3QgKi8gICB2YXIgUExVU19PUEVSQVRPUiAgICAgICAgICA9ICcrJztcbi8qKiBAY29uc3QgKi8gICB2YXIgTUlOVVNfT1BFUkFUT1IgICAgICAgICA9ICctJztcbi8qKiBAY29uc3QgKi8gICB2YXIgTVVMX09QRVJBVE9SICAgICAgICAgICA9ICcqJztcbi8qKiBAY29uc3QgKi8gICB2YXIgRElWX09QRVJBVE9SICAgICAgICAgICA9ICcvJztcbi8qKiBAY29uc3QgKi8gICB2YXIgTU9EX09QRVJBVE9SICAgICAgICAgICA9ICclJztcbi8qKiBAY29uc3QgKi8gICB2YXIgRVFVQUxTX09QRVJBVE9SICAgICAgICA9ICc9PSc7XG4vKiogQGNvbnN0ICovICAgdmFyIE5PVF9FUVVBTFNfT1BFUkFUT1IgICAgPSAnIT0nO1xuLyoqIEBjb25zdCAqLyAgIHZhciBHUkVBVEVSX09QRVJBVE9SICAgICAgID0gJz4nO1xuLyoqIEBjb25zdCAqLyAgIHZhciBMRVNTX09QRVJBVE9SICAgICAgICAgID0gJzwnO1xuLyoqIEBjb25zdCAqLyAgIHZhciBHUkVBVEVSX0VRVUFMX09QRVJBVE9SID0gJz49Jztcbi8qKiBAY29uc3QgKi8gICB2YXIgTEVTU19FUVVBTF9PUEVSQVRPUiAgICA9ICc8PSc7XG5cbi8vIFR5cGVjYXN0IE9wZXJhdG9yc1xuLyoqIEBjb25zdCAqLyAgIHZhciBCT09MRUFOX09QRVJBVE9SICAgICAgID0gJ2Jvb2xlYW4nO1xuLyoqIEBjb25zdCAqLyAgIHZhciBEQVRFVElNRV9PUEVSQVRPUiAgICAgID0gJ2RhdGV0aW1lJztcbi8qKiBAY29uc3QgKi8gICB2YXIgTElTVF9PUEVSQVRPUiAgICAgICAgICA9ICdsaXN0Jztcbi8qKiBAY29uc3QgKi8gICB2YXIgTlVNQkVSX09QRVJBVE9SICAgICAgICA9ICdudW1iZXInO1xuLyoqIEBjb25zdCAqLyAgIHZhciBTVFJJTkdfT1BFUkFUT1IgICAgICAgID0gJ3N0cmluZyc7XG5cbi8vIFVuYXJ5IE9wZXJhdG9yc1xuLyoqIEBjb25zdCAqLyAgIHZhciBOT1RfT1BFUkFUT1IgICAgICAgICAgID0gJ25vdCc7XG4vKiogQGNvbnN0ICovICAgdmFyIERFRklORURfT1BFUkFUT1IgICAgICAgPSAnZGVmaW5lZCc7XG4vKiogQGNvbnN0ICovICAgdmFyIE5PVF9ERUZJTkVEX09QRVJBVE9SICAgPSAnbm90IGRlZmluZWQnO1xuXG4vLyBTcGVjaWFsIGxpdGVyYWxzXG4vKiogQGNvbnN0ICovICAgdmFyIE5PV19MSVRFUkFMICAgICAgICAgICAgPSAnbm93JztcblxuLy8gVHlwZSBjYXN0IGZ1bmN0aW9uc1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoXy5pc0RhdGUodmFsdWUpICYmIHZhbHVlLmdldFRpbWUoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlTnVtYmVyKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsnb3BlcmF0b3InXSB8fCBvcFsnb3BlcmF0b3InXSAhPT0gTlVNQkVSX09QRVJBVE9SIHx8ICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgKCdJbnZhbGlkIGNhc3Qgb3BlcmF0b3I6IG51bWJlciAnICsgb3ApO1xuICAgIH1cblxuICAgIHJldHVybiB0b051bWJlcihldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKSk7XG59XG5cbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAuMDtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uaXNEYXRlKHZhbHVlKSAmJiB2YWx1ZS5nZXRUaW1lKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiYgIV8uaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUJvb2xlYW4ob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IG9wWydvcGVyYXRvciddICE9PSBCT09MRUFOX09QRVJBVE9SIHx8ICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgKCdJbnZhbGlkIGNhc3Qgb3BlcmF0b3I6IGJvb2xlYW4gJyArIG9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Cb29sZWFuKGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMF0sIHByb3BlcnRpZXMpKTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVEYXRlVGltZShvcCwgcHJvcGVydGllcykge1xuICAgIGlmICghb3BbJ29wZXJhdG9yJ10gfHwgb3BbJ29wZXJhdG9yJ10gIT09IERBVEVUSU1FX09QRVJBVE9SIHx8ICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgKCdJbnZhbGlkIGNhc3Qgb3BlcmF0b3I6IGRhdGV0aW1lICcgKyBvcCk7XG4gICAgfVxuXG4gICAgdmFyIHYgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZih2KSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSh2KTtcbiAgICAgICAgICAgIGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKF8uaXNEYXRlKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlTGlzdChvcCwgcHJvcGVydGllcykge1xuICAgIGlmICghb3BbJ29wZXJhdG9yJ10gfHwgb3BbJ29wZXJhdG9yJ10gIT09IExJU1RfT1BFUkFUT1IgfHwgIW9wWydjaGlsZHJlbiddIHx8IG9wWydjaGlsZHJlbiddLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgY2FzdCBvcGVyYXRvcjogbGlzdCAnICsgb3ApO1xuICAgIH1cblxuICAgIHZhciB2ID0gZXZhbHVhdGVTZWxlY3RvcihvcFsnY2hpbGRyZW4nXVswXSwgcHJvcGVydGllcyk7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVTdHJpbmcob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IG9wWydvcGVyYXRvciddICE9PSBTVFJJTkdfT1BFUkFUT1IgfHwgIW9wWydjaGlsZHJlbiddIHx8IG9wWydjaGlsZHJlbiddLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgY2FzdCBvcGVyYXRvcjogc3RyaW5nICcgKyBvcCk7XG4gICAgfVxuXG4gICAgdmFyIHYgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICBzd2l0Y2ggKHR5cGVvZih2KSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKF8uaXNEYXRlKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9KU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcodik7XG59XG5cbi8vIE9wZXJhdG9yc1xuZnVuY3Rpb24gZXZhbHVhdGVBbmQob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IG9wWydvcGVyYXRvciddICE9PSBBTkRfT1BFUkFUT1IgfHwgIW9wWydjaGlsZHJlbiddIHx8IG9wWydjaGlsZHJlbiddLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgb3BlcmF0b3I6IEFORCAnICsgb3ApO1xuICAgIH1cblxuICAgIHJldHVybiB0b0Jvb2xlYW4oZXZhbHVhdGVTZWxlY3RvcihvcFsnY2hpbGRyZW4nXVswXSwgcHJvcGVydGllcykpICYmIHRvQm9vbGVhbihldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzFdLCBwcm9wZXJ0aWVzKSk7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlT3Iob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IG9wWydvcGVyYXRvciddICE9PSBPUl9PUEVSQVRPUiB8fCAhb3BbJ2NoaWxkcmVuJ10gfHwgb3BbJ2NoaWxkcmVuJ10ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93ICgnSW52YWxpZCBvcGVyYXRvcjogT1IgJyArIG9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Cb29sZWFuKGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMF0sIHByb3BlcnRpZXMpKSB8fCB0b0Jvb2xlYW4oZXZhbHVhdGVTZWxlY3RvcihvcFsnY2hpbGRyZW4nXVsxXSwgcHJvcGVydGllcykpO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUluKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsnb3BlcmF0b3InXSB8fCBbSU5fT1BFUkFUT1IsIE5PVF9JTl9PUEVSQVRPUl0uaW5kZXhPZihvcFsnb3BlcmF0b3InXSkgPT09IC0xIHx8ICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgKCdJbnZhbGlkIG9wZXJhdG9yOiBJTi9OT1QgSU4gJyArIG9wKTtcbiAgICB9XG4gICAgdmFyIGxlZnRWYWx1ZSA9IGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMF0sIHByb3BlcnRpZXMpO1xuICAgIHZhciByaWdodFZhbHVlID0gZXZhbHVhdGVTZWxlY3RvcihvcFsnY2hpbGRyZW4nXVsxXSwgcHJvcGVydGllcyk7XG5cbiAgICBpZiAoIV8uaXNBcnJheShyaWdodFZhbHVlKSAmJiAhXy5pc1N0cmluZyhyaWdodFZhbHVlKSkge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgb3BlcmFuZCBmb3Igb3BlcmF0b3IgSU46IGludmFsaWQgdHlwZScgKyByaWdodFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgdiA9IHJpZ2h0VmFsdWUuaW5kZXhPZihsZWZ0VmFsdWUpID4gLTE7XG4gICAgaWYgKG9wWydvcGVyYXRvciddID09PSBOT1RfSU5fT1BFUkFUT1IpIHtcbiAgICAgICAgcmV0dXJuICF2O1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVQbHVzKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsnb3BlcmF0b3InXSB8fCBvcFsnb3BlcmF0b3InXSAhPT0gUExVU19PUEVSQVRPUiB8fCAhb3BbJ2NoaWxkcmVuJ10gfHwgb3BbJ2NoaWxkcmVuJ10ubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgb3BlcmF0b3I6IFBMVVMgJyArIG9wKTtcbiAgICB9XG4gICAgdmFyIGwgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB2YXIgciA9IGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMV0sIHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHR5cGVvZiBsID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGwgKyByO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGwgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbCArIHI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUFyaXRobWV0aWMob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IFtNSU5VU19PUEVSQVRPUiwgTVVMX09QRVJBVE9SLCBESVZfT1BFUkFUT1IsIE1PRF9PUEVSQVRPUl0uaW5kZXhPZihvcFsnb3BlcmF0b3InXSkgPT09IC0xIHx8XG4gICAgICAgICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93ICgnSW52YWxpZCBhcml0aG1ldGljIG9wZXJhdG9yICcgKyBvcCk7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB2YXIgciA9IGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMV0sIHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHR5cGVvZiBsID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3dpdGNoIChvcFsnb3BlcmF0b3InXSkge1xuICAgICAgICAgICAgY2FzZSBNSU5VU19PUEVSQVRPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbCAtIHI7XG4gICAgICAgICAgICBjYXNlIE1VTF9PUEVSQVRPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbCAqIHI7XG4gICAgICAgICAgICBjYXNlIERJVl9PUEVSQVRPUjpcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCAvIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBNT0RfT1BFUkFUT1I6XG4gICAgICAgICAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGwgPCAwICYmIHIgPiAwKSB8fCAobCA+IDAgJiYgciA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIE1pbWljIHB5dGhvbiBtb2R1bG8gLSByZXN1bHQgdGFrZXMgc2lnbiBvZiB0aGUgZGl2aXNvclxuICAgICAgICAgICAgICAgICAgICAgKiBpZiBvbmUgb3BlcmFuZCBpcyBuZWdhdGl2ZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0oTWF0aC5mbG9vcihsIC8gcikgKiByIC0gbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsICUgcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3coJ1Vua25vd24gb3BlcmF0b3I6ICcgKyBvcFsnb3BlcmF0b3InXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gX2lzQXJyYXlFcXVhbChsLCByKSB7XG4gICAgaWYgKGwgPT09IHIpIHJldHVybiB0cnVlO1xuICAgIGlmIChsID09PSBudWxsIHx8IHIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobC5sZW5ndGggIT09IHIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxbaV0gIT09IHJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfaXNFcXVhbChsLCByKSB7XG4gICAgaWYgKCBsID09PSBudWxsICYmIGwgPT09IHIgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGwgPT09IHR5cGVvZiByKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGwpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwgPT09IHI7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkobCkgJiYgXy5pc0FycmF5KHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaXNBcnJheUVxdWFsKGwsIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0RhdGUobCkgJiYgXy5pc0RhdGUocikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuZ2V0VGltZSgpID09PSByLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QobCkgJiYgXy5pc09iamVjdChyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobCkgPT09IEpTT04uc3RyaW5naWZ5KHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRXF1YWxpdHkob3AsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9wWydvcGVyYXRvciddIHx8IFtFUVVBTFNfT1BFUkFUT1IsIE5PVF9FUVVBTFNfT1BFUkFUT1JdLmluZGV4T2Yob3BbJ29wZXJhdG9yJ10pID09PSAtMSB8fCAhb3BbJ2NoaWxkcmVuJ10gfHwgb3BbJ2NoaWxkcmVuJ10ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93ICgnSW52YWxpZCBlcXVhbGl0eSBvcGVyYXRvciAnICsgb3ApO1xuICAgIH1cblxuICAgIHZhciB2ID0gX2lzRXF1YWwoZXZhbHVhdGVTZWxlY3RvcihvcFsnY2hpbGRyZW4nXVswXSwgcHJvcGVydGllcyksIGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMV0sIHByb3BlcnRpZXMpKTtcblxuICAgIHN3aXRjaCAob3BbJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgY2FzZSBFUVVBTFNfT1BFUkFUT1I6XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSBOT1RfRVFVQUxTX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuICF2O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVDb21wYXJpc29uKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsnb3BlcmF0b3InXSB8fFxuICAgICAgICBbR1JFQVRFUl9PUEVSQVRPUiwgR1JFQVRFUl9FUVVBTF9PUEVSQVRPUiwgTEVTU19PUEVSQVRPUiwgTEVTU19FUVVBTF9PUEVSQVRPUl0uaW5kZXhPZihvcFsnb3BlcmF0b3InXSkgPT09IC0xIHx8XG4gICAgICAgICFvcFsnY2hpbGRyZW4nXSB8fCBvcFsnY2hpbGRyZW4nXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgKCdJbnZhbGlkIGNvbXBhcmlzb24gb3BlcmF0b3IgJyArIG9wKTtcbiAgICB9XG4gICAgdmFyIGwgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB2YXIgciA9IGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMV0sIHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHR5cGVvZihsKSA9PT0gdHlwZW9mKHIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YocikgPT09ICdudW1iZXInIHx8IF8uaXNEYXRlKHIpKSB7XG4gICAgICAgICAgICBsID0gdG9OdW1iZXIobCk7XG4gICAgICAgICAgICByID0gdG9OdW1iZXIocik7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBHUkVBVEVSX09QRVJBVE9SOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCA+IHI7XG4gICAgICAgICAgICAgICAgY2FzZSBHUkVBVEVSX0VRVUFMX09QRVJBVE9SOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCA+PSByO1xuICAgICAgICAgICAgICAgIGNhc2UgTEVTU19PUEVSQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgPCByO1xuICAgICAgICAgICAgICAgIGNhc2UgTEVTU19FUVVBTF9PUEVSQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgPD0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YocikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZSA9IGwubG9jYWxlQ29tcGFyZShyKTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEdSRUFURVJfT1BFUkFUT1I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlID4gMDtcbiAgICAgICAgICAgICAgICBjYXNlIEdSRUFURVJfRVFVQUxfT1BFUkFUT1I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlID49IDA7XG4gICAgICAgICAgICAgICAgY2FzZSBMRVNTX09QRVJBVE9SOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZSA8IDA7XG4gICAgICAgICAgICAgICAgY2FzZSBMRVNTX0VRVUFMX09QRVJBVE9SOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZSA8PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRGVmaW5lZChvcCwgcHJvcGVydGllcykge1xuICAgIGlmICghb3BbJ29wZXJhdG9yJ10gfHwgW0RFRklORURfT1BFUkFUT1IsIE5PVF9ERUZJTkVEX09QRVJBVE9SXS5pbmRleE9mKG9wWydvcGVyYXRvciddKSA9PT0gLTEgfHxcbiAgICAgICAgIW9wWydjaGlsZHJlbiddIHx8IG9wWydjaGlsZHJlbiddLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgZGVmaW5lZC9ub3QgZGVmaW5lZCBvcGVyYXRvcjogJyArIG9wKTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGV2YWx1YXRlU2VsZWN0b3Iob3BbJ2NoaWxkcmVuJ11bMF0sIHByb3BlcnRpZXMpICE9PSBudWxsO1xuICAgIGlmIChvcFsnb3BlcmF0b3InXSA9PT0gTk9UX0RFRklORURfT1BFUkFUT1IpIHtcbiAgICAgICAgcmV0dXJuICFiO1xuICAgIH1cblxuICAgIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZU5vdChvcCwgcHJvcGVydGllcykge1xuICAgIGlmICghb3BbJ29wZXJhdG9yJ10gfHwgb3BbJ29wZXJhdG9yJ10gIT09IE5PVF9PUEVSQVRPUiB8fCAhb3BbJ2NoaWxkcmVuJ10gfHwgb3BbJ2NoaWxkcmVuJ10ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93ICgnSW52YWxpZCBub3Qgb3BlcmF0b3I6ICcgKyBvcCk7XG4gICAgfVxuXG4gICAgdmFyIHYgPSBldmFsdWF0ZVNlbGVjdG9yKG9wWydjaGlsZHJlbiddWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKHYpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICF2O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZU9wZXJhdG9yKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsnb3BlcmF0b3InXSkge1xuICAgICAgICB0aHJvdyAoJ0ludmFsaWQgb3BlcmF0b3I6IG9wZXJhdG9yIGtleSBtaXNzaW5nICcgKyBvcCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcFsnb3BlcmF0b3InXSkge1xuICAgICAgICBjYXNlIEFORF9PUEVSQVRPUjpcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUFuZChvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgT1JfT1BFUkFUT1I6XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVPcihvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgSU5fT1BFUkFUT1I6XG4gICAgICAgIGNhc2UgTk9UX0lOX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlSW4ob3AsIHByb3BlcnRpZXMpO1xuICAgICAgICBjYXNlIFBMVVNfT1BFUkFUT1I6XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVQbHVzKG9wLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgY2FzZSBNSU5VU19PUEVSQVRPUjpcbiAgICAgICAgY2FzZSBNVUxfT1BFUkFUT1I6XG4gICAgICAgIGNhc2UgRElWX09QRVJBVE9SOlxuICAgICAgICBjYXNlIE1PRF9PUEVSQVRPUjpcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUFyaXRobWV0aWMob3AsIHByb3BlcnRpZXMpO1xuICAgICAgICBjYXNlIEVRVUFMU19PUEVSQVRPUjpcbiAgICAgICAgY2FzZSBOT1RfRVFVQUxTX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXF1YWxpdHkob3AsIHByb3BlcnRpZXMpO1xuICAgICAgICBjYXNlIEdSRUFURVJfT1BFUkFUT1I6XG4gICAgICAgIGNhc2UgTEVTU19PUEVSQVRPUjpcbiAgICAgICAgY2FzZSBHUkVBVEVSX0VRVUFMX09QRVJBVE9SOlxuICAgICAgICBjYXNlIExFU1NfRVFVQUxfT1BFUkFUT1I6XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVDb21wYXJpc29uKG9wLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgY2FzZSBCT09MRUFOX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlQm9vbGVhbihvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgREFURVRJTUVfT1BFUkFUT1I6XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVEYXRlVGltZShvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgTElTVF9PUEVSQVRPUjpcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUxpc3Qob3AsIHByb3BlcnRpZXMpO1xuICAgICAgICBjYXNlIE5VTUJFUl9PUEVSQVRPUjpcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZU51bWJlcihvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgU1RSSU5HX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlU3RyaW5nKG9wLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgY2FzZSBERUZJTkVEX09QRVJBVE9SOlxuICAgICAgICBjYXNlIE5PVF9ERUZJTkVEX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlRGVmaW5lZChvcCwgcHJvcGVydGllcyk7XG4gICAgICAgIGNhc2UgTk9UX09QRVJBVE9SOlxuICAgICAgICAgICAgcmV0dXJuIGV2YWx1YXRlTm90KG9wLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlV2luZG93KHZhbHVlKSB7XG4gICAgdmFyIHdpbiA9IHZhbHVlW1dJTkRPV19LRVldO1xuICAgIGlmICghd2luIHx8ICF3aW5bVU5JVF9LRVldIHx8ICF3aW5bVkFMVUVfS0VZXSkge1xuICAgICAgICB0aHJvdygnSW52YWxpZCB3aW5kb3c6IG1pc3NpbmcgcmVxdWlyZWQga2V5cyAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gICAgdmFyIG91dCA9IG5ldyBEYXRlKCk7XG4gICAgc3dpdGNoICh3aW5bVU5JVF9LRVldKSB7XG4gICAgICAgIGNhc2UgSE9VUl9LRVk6XG4gICAgICAgICAgICBvdXQuc2V0VGltZShvdXQuZ2V0VGltZSgpICsgKHdpbltWQUxVRV9LRVldKi0xKjYwKjYwKjEwMDApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERBWV9LRVk6XG4gICAgICAgICAgICBvdXQuc2V0VGltZShvdXQuZ2V0VGltZSgpICsgKHdpbltWQUxVRV9LRVldKi0xKjI0KjYwKjYwKjEwMDApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdFRUtfS0VZOlxuICAgICAgICAgICAgb3V0LnNldFRpbWUob3V0LmdldFRpbWUoKSArICh3aW5bVkFMVUVfS0VZXSotMSo3KjI0KjYwKjYwKjEwMDApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1PTlRIX0tFWTpcbiAgICAgICAgICAgIG91dC5zZXRUaW1lKG91dC5nZXRUaW1lKCkgKyAod2luW1ZBTFVFX0tFWV0qLTEqMzAqMjQqNjAqNjAqMTAwMCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdygnSW52YWxpZCB1bml0OiAnICsgd2luW1VOSVRfS0VZXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVPcGVyYW5kKG9wLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvcFsncHJvcGVydHknXSB8fCAhb3BbJ3ZhbHVlJ10pIHtcbiAgICAgICAgdGhyb3coJ0ludmFsaWQgb3BlcmFuZDogbWlzc2luZyByZXF1aXJlZCBrZXlzICcgKyBvcCk7XG4gICAgfVxuICAgIHN3aXRjaCAob3BbJ3Byb3BlcnR5J10pIHtcbiAgICAgICAgY2FzZSBFVkVOVF9QUk9QRVJUWTpcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW29wWyd2YWx1ZSddXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXNbb3BbJ3ZhbHVlJ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgTElURVJBTF9QUk9QRVJUWTpcbiAgICAgICAgICAgIGlmIChvcFsndmFsdWUnXSA9PT0gTk9XX0xJVEVSQUwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Yob3BbJ3ZhbHVlJ10pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZVdpbmRvdyhvcFsndmFsdWUnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BbJ3ZhbHVlJ107XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdygnSW52YWxpZCBvcGVyYW5kOiBJbnZhbGlkIHByb3BlcnR5IHR5cGUgJyArIG9wWydwcm9wZXJ0eSddKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlU2VsZWN0b3IoZmlsdGVycywgcHJvcGVydGllcykge1xuICAgIGlmIChmaWx0ZXJzW1BST1BFUlRZX0tFWV0pIHtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlT3BlcmFuZChmaWx0ZXJzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnNbT1BFUkFUT1JfS0VZXSkge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVPcGVyYXRvcihmaWx0ZXJzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG59XG5cbi8vIEludGVybmFsIGNsYXNzIGZvciBub3RpZmljYXRpb24gZGlzcGxheVxuXG52YXIgTWl4cGFuZWxOb3RpZmljYXRpb24gPSBmdW5jdGlvbihub3RpZl9kYXRhLCBtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIF8uYmluZF9pbnN0YW5jZV9tZXRob2RzKHRoaXMpO1xuXG4gICAgdGhpcy5taXhwYW5lbCAgICAgICAgICA9IG1peHBhbmVsX2luc3RhbmNlO1xuICAgIHRoaXMucGVyc2lzdGVuY2UgICAgICAgPSB0aGlzLm1peHBhbmVsWydwZXJzaXN0ZW5jZSddO1xuICAgIHRoaXMucmVzb3VyY2VfcHJvdG9jb2wgPSB0aGlzLm1peHBhbmVsLmdldF9jb25maWcoJ2luYXBwX3Byb3RvY29sJyk7XG4gICAgdGhpcy5jZG5faG9zdCAgICAgICAgICA9IHRoaXMubWl4cGFuZWwuZ2V0X2NvbmZpZygnY2RuJyk7XG5cbiAgICB0aGlzLmNhbXBhaWduX2lkID0gXy5lc2NhcGVIVE1MKG5vdGlmX2RhdGFbJ2lkJ10pO1xuICAgIHRoaXMubWVzc2FnZV9pZCAgPSBfLmVzY2FwZUhUTUwobm90aWZfZGF0YVsnbWVzc2FnZV9pZCddKTtcblxuICAgIHRoaXMuYm9keSAgICAgICAgICAgID0gKF8uZXNjYXBlSFRNTChub3RpZl9kYXRhWydib2R5J10pIHx8ICcnKS5yZXBsYWNlKC9cXG4vZywgJzxici8+Jyk7XG4gICAgdGhpcy5jdGEgICAgICAgICAgICAgPSBfLmVzY2FwZUhUTUwobm90aWZfZGF0YVsnY3RhJ10pIHx8ICdDbG9zZSc7XG4gICAgdGhpcy5ub3RpZl90eXBlICAgICAgPSBfLmVzY2FwZUhUTUwobm90aWZfZGF0YVsndHlwZSddKSB8fCAndGFrZW92ZXInO1xuICAgIHRoaXMuc3R5bGUgICAgICAgICAgID0gXy5lc2NhcGVIVE1MKG5vdGlmX2RhdGFbJ3N0eWxlJ10pIHx8ICdsaWdodCc7XG4gICAgdGhpcy50aXRsZSAgICAgICAgICAgPSBfLmVzY2FwZUhUTUwobm90aWZfZGF0YVsndGl0bGUnXSkgfHwgJyc7XG4gICAgdGhpcy52aWRlb193aWR0aCAgICAgPSBNaXhwYW5lbE5vdGlmaWNhdGlvbi5WSURFT19XSURUSDtcbiAgICB0aGlzLnZpZGVvX2hlaWdodCAgICA9IE1peHBhbmVsTm90aWZpY2F0aW9uLlZJREVPX0hFSUdIVDtcblxuICAgIHRoaXMuZGlzcGxheV90cmlnZ2VycyA9IG5vdGlmX2RhdGFbJ2Rpc3BsYXlfdHJpZ2dlcnMnXSB8fCBbXTtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgdXJsLXNhbml0aXplZCBpbiB0aGUgYmFja2VuZCBhbHJlYWR5LlxuICAgIHRoaXMuZGVzdF91cmwgICAgICAgID0gbm90aWZfZGF0YVsnY3RhX3VybCddIHx8IG51bGw7XG4gICAgdGhpcy5pbWFnZV91cmwgICAgICAgPSBub3RpZl9kYXRhWydpbWFnZV91cmwnXSB8fCBudWxsO1xuICAgIHRoaXMudGh1bWJfaW1hZ2VfdXJsID0gbm90aWZfZGF0YVsndGh1bWJfaW1hZ2VfdXJsJ10gfHwgbnVsbDtcbiAgICB0aGlzLnZpZGVvX3VybCAgICAgICA9IG5vdGlmX2RhdGFbJ3ZpZGVvX3VybCddIHx8IG51bGw7XG5cbiAgICBpZiAodGhpcy50aHVtYl9pbWFnZV91cmwgJiYgdGhpcy50aHVtYl9pbWFnZV91cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLnRodW1iX2ltYWdlX3VybCA9IHRoaXMudGh1bWJfaW1hZ2VfdXJsLnJlcGxhY2UoJy8vJywgdGhpcy5yZXNvdXJjZV9wcm90b2NvbCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGlja3Rocm91Z2ggPSB0cnVlO1xuICAgIGlmICghdGhpcy5kZXN0X3VybCkge1xuICAgICAgICB0aGlzLmRlc3RfdXJsID0gJyNkaXNtaXNzJztcbiAgICAgICAgdGhpcy5jbGlja3Rocm91Z2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbmkgPSB0aGlzLm5vdGlmX3R5cGUgPT09ICdtaW5pJztcbiAgICBpZiAoIXRoaXMubWluaSkge1xuICAgICAgICB0aGlzLm5vdGlmX3R5cGUgPSAndGFrZW92ZXInO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmX3dpZHRoID0gIXRoaXMubWluaSA/IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1dJRFRIIDogTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEhfTUlOSTtcblxuICAgIHRoaXMuX3NldF9jbGllbnRfY29uZmlnKCk7XG4gICAgdGhpcy5pbWdzX3RvX3ByZWxvYWQgPSB0aGlzLl9pbml0X2ltYWdlX2h0bWwoKTtcbiAgICB0aGlzLl9pbml0X3ZpZGVvKCk7XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5BTklNX1RJTUUgICAgICAgICA9IDIwMDtcbk1peHBhbmVsTm90aWZpY2F0aW9uLk1BUktVUF9QUkVGSVggICAgID0gJ21peHBhbmVsLW5vdGlmaWNhdGlvbic7XG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5CR19PUEFDSVRZICAgICAgICA9IDAuNjtcbk1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1RPUCAgICAgICAgID0gMjU7XG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9TVEFSVF9UT1AgICA9IDIwMDtcbk1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1dJRFRIICAgICAgID0gMzg4O1xuTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEhfTUlOSSAgPSA0MjA7XG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9IRUlHSFRfTUlOSSA9IDg1O1xuTWl4cGFuZWxOb3RpZmljYXRpb24uVEhVTUJfQk9SREVSX1NJWkUgPSA1O1xuTWl4cGFuZWxOb3RpZmljYXRpb24uVEhVTUJfSU1HX1NJWkUgICAgPSA2MDtcbk1peHBhbmVsTm90aWZpY2F0aW9uLlRIVU1CX09GRlNFVCAgICAgID0gTWF0aC5yb3VuZChNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9JTUdfU0laRSAvIDIpO1xuTWl4cGFuZWxOb3RpZmljYXRpb24uVklERU9fV0lEVEggICAgICAgPSA1OTU7XG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5WSURFT19IRUlHSFQgICAgICA9IDMzNDtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fc2V0X2NsaWVudF9jb25maWcoKTtcblxuICAgIC8vIGRvbid0IGRpc3BsYXkgdW50aWwgSFRNTCBib2R5IGV4aXN0c1xuICAgIGlmICghdGhpcy5ib2R5X2VsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuc2hvdygpOyB9LCAzMDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdF9zdHlsZXMoKTtcbiAgICB0aGlzLl9pbml0X25vdGlmaWNhdGlvbl9lbCgpO1xuXG4gICAgLy8gd2FpdCBmb3IgYW55IGltYWdlcyB0byBsb2FkIGJlZm9yZSBzaG93aW5nIG5vdGlmaWNhdGlvblxuICAgIHRoaXMuX3ByZWxvYWRfaW1hZ2VzKHRoaXMuX2F0dGFjaF9hbmRfYW5pbWF0ZSk7XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuZGlzbWlzcyA9IF8uc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hcmtlZF9hc19zaG93bikge1xuICAgICAgICAvLyB1bmV4cGVjdGVkIGNvbmRpdGlvbjogdXNlciBpbnRlcmFjdGVkIHdpdGggbm90aWYgZXZlbiB0aG91Z2ggd2UgZGlkbid0IGNvbnNpZGVyIGl0XG4gICAgICAgIC8vIHZpc2libGUgKHNlZSBfbWFya19hc19zaG93bigpKTsgc2VuZCB0cmFja2luZyBzaWduYWxzIHRvIG1hcmsgZGVsaXZlcnlcbiAgICAgICAgdGhpcy5fbWFya19kZWxpdmVyeSh7J2ludmlzaWJsZSc6IHRydWV9KTtcbiAgICB9XG5cbiAgICB2YXIgZXhpdGluZ19lbCA9IHRoaXMuc2hvd2luZ192aWRlbyA/IHRoaXMuX2dldF9lbCgndmlkZW8nKSA6IHRoaXMuX2dldF9ub3RpZmljYXRpb25fZGlzcGxheV9lbCgpO1xuICAgIGlmICh0aGlzLnVzZV90cmFuc2l0aW9ucykge1xuICAgICAgICB0aGlzLl9yZW1vdmVfY2xhc3MoJ2JnJywgJ3Zpc2libGUnKTtcbiAgICAgICAgdGhpcy5fYWRkX2NsYXNzKGV4aXRpbmdfZWwsICdleGl0aW5nJyk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fcmVtb3ZlX25vdGlmaWNhdGlvbl9lbCwgTWl4cGFuZWxOb3RpZmljYXRpb24uQU5JTV9USU1FKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm90aWZfYXR0ciwgbm90aWZfc3RhcnQsIG5vdGlmX2dvYWw7XG4gICAgICAgIGlmICh0aGlzLm1pbmkpIHtcbiAgICAgICAgICAgIG5vdGlmX2F0dHIgID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIG5vdGlmX3N0YXJ0ID0gMjA7XG4gICAgICAgICAgICBub3RpZl9nb2FsICA9IC0xMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3RpZl9hdHRyICA9ICd0b3AnO1xuICAgICAgICAgICAgbm90aWZfc3RhcnQgPSBNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9UT1A7XG4gICAgICAgICAgICBub3RpZl9nb2FsICA9IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1NUQVJUX1RPUCArIE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1RPUDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRlX2VscyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWw6ICAgIHRoaXMuX2dldF9lbCgnYmcnKSxcbiAgICAgICAgICAgICAgICBhdHRyOiAgJ29wYWNpdHknLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5CR19PUEFDSVRZLFxuICAgICAgICAgICAgICAgIGdvYWw6ICAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWw6ICAgIGV4aXRpbmdfZWwsXG4gICAgICAgICAgICAgICAgYXR0cjogICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICBzdGFydDogMS4wLFxuICAgICAgICAgICAgICAgIGdvYWw6ICAwLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWw6ICAgIGV4aXRpbmdfZWwsXG4gICAgICAgICAgICAgICAgYXR0cjogIG5vdGlmX2F0dHIsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vdGlmX3N0YXJ0LFxuICAgICAgICAgICAgICAgIGdvYWw6ICBub3RpZl9nb2FsXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIE1peHBhbmVsTm90aWZpY2F0aW9uLkFOSU1fVElNRSwgdGhpcy5fcmVtb3ZlX25vdGlmaWNhdGlvbl9lbCk7XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYWRkX2NsYXNzID0gXy5zYWZld3JhcChmdW5jdGlvbihlbCwgY2xhc3NfbmFtZSkge1xuICAgIGNsYXNzX25hbWUgPSBNaXhwYW5lbE5vdGlmaWNhdGlvbi5NQVJLVVBfUFJFRklYICsgJy0nICsgY2xhc3NfbmFtZTtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbCA9IHRoaXMuX2dldF9lbChlbCk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzX25hbWU7XG4gICAgfSBlbHNlIGlmICghfignICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NfbmFtZSArICcgJykpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzX25hbWU7XG4gICAgfVxufSk7XG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX3JlbW92ZV9jbGFzcyA9IF8uc2FmZXdyYXAoZnVuY3Rpb24oZWwsIGNsYXNzX25hbWUpIHtcbiAgICBjbGFzc19uYW1lID0gTWl4cGFuZWxOb3RpZmljYXRpb24uTUFSS1VQX1BSRUZJWCArICctJyArIGNsYXNzX25hbWU7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWwgPSB0aGlzLl9nZXRfZWwoZWwpO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgnICcgKyBjbGFzc19uYW1lICsgJyAnLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eW1xcc1xceEEwXSsvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxzXFx4QTBdKyQvLCAnJyk7XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fYW5pbWF0ZV9lbHMgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKGFuaW1zLCBtc3MsIGRvbmVfY2IsIHN0YXJ0X3RpbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGluX3Byb2dyZXNzID0gZmFsc2UsXG4gICAgICAgIGFpLCBhbmltLFxuICAgICAgICBjdXJfdGltZSA9IDEgKiBuZXcgRGF0ZSgpLCB0aW1lX2RpZmY7XG5cbiAgICBzdGFydF90aW1lID0gc3RhcnRfdGltZSB8fCBjdXJfdGltZTtcbiAgICB0aW1lX2RpZmYgPSBjdXJfdGltZSAtIHN0YXJ0X3RpbWU7XG5cbiAgICBmb3IgKGFpID0gMDsgYWkgPCBhbmltcy5sZW5ndGg7IGFpKyspIHtcbiAgICAgICAgYW5pbSA9IGFuaW1zW2FpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmltLnZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFuaW0udmFsID0gYW5pbS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbS52YWwgIT09IGFuaW0uZ29hbCkge1xuICAgICAgICAgICAgaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGFuaW1fZGlmZiA9IGFuaW0uZ29hbCAtIGFuaW0uc3RhcnQsXG4gICAgICAgICAgICAgICAgYW5pbV9kaXIgPSBhbmltLmdvYWwgPj0gYW5pbS5zdGFydCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGFuaW0udmFsID0gYW5pbS5zdGFydCArIGFuaW1fZGlmZiAqIHRpbWVfZGlmZiAvIG1zcztcbiAgICAgICAgICAgIGlmIChhbmltLmF0dHIgIT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgICAgICAgIGFuaW0udmFsID0gTWF0aC5yb3VuZChhbmltLnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGFuaW1fZGlyID4gMCAmJiBhbmltLnZhbCA+PSBhbmltLmdvYWwpIHx8IChhbmltX2RpciA8IDAgJiYgYW5pbS52YWwgPD0gYW5pbS5nb2FsKSkge1xuICAgICAgICAgICAgICAgIGFuaW0udmFsID0gYW5pbS5nb2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5fcHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKGRvbmVfY2IpIHtcbiAgICAgICAgICAgIGRvbmVfY2IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChhaSA9IDA7IGFpIDwgYW5pbXMubGVuZ3RoOyBhaSsrKSB7XG4gICAgICAgIGFuaW0gPSBhbmltc1thaV07XG4gICAgICAgIGlmIChhbmltLmVsKSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gYW5pbS5hdHRyID09PSAnb3BhY2l0eScgPyAnJyA6ICdweCc7XG4gICAgICAgICAgICBhbmltLmVsLnN0eWxlW2FuaW0uYXR0cl0gPSBTdHJpbmcoYW5pbS52YWwpICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuX2FuaW1hdGVfZWxzKGFuaW1zLCBtc3MsIGRvbmVfY2IsIHN0YXJ0X3RpbWUpOyB9LCAxMCk7XG59KTtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLl9hdHRhY2hfYW5kX2FuaW1hdGUgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIG5vIHBvc3NpYmlsaXR5IHRvIGRvdWJsZS1kaXNwbGF5XG4gICAgaWYgKHRoaXMuc2hvd24gfHwgdGhpcy5fZ2V0X3Nob3duX2NhbXBhaWducygpW3RoaXMuY2FtcGFpZ25faWRdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zaG93biA9IHRydWU7XG5cbiAgICB0aGlzLmJvZHlfZWwuYXBwZW5kQ2hpbGQodGhpcy5ub3RpZmljYXRpb25fZWwpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3RpZl9lbCA9IHNlbGYuX2dldF9ub3RpZmljYXRpb25fZGlzcGxheV9lbCgpO1xuICAgICAgICBpZiAoc2VsZi51c2VfdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5taW5pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYWRkX2NsYXNzKCdiZycsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9hZGRfY2xhc3Mobm90aWZfZWwsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBzZWxmLl9tYXJrX2FzX3Nob3duKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm90aWZfYXR0ciwgbm90aWZfc3RhcnQsIG5vdGlmX2dvYWw7XG4gICAgICAgICAgICBpZiAoc2VsZi5taW5pKSB7XG4gICAgICAgICAgICAgICAgbm90aWZfYXR0ciAgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIG5vdGlmX3N0YXJ0ID0gLTEwMDtcbiAgICAgICAgICAgICAgICBub3RpZl9nb2FsICA9IDIwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3RpZl9hdHRyICA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIG5vdGlmX3N0YXJ0ID0gTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfU1RBUlRfVE9QICsgTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfVE9QO1xuICAgICAgICAgICAgICAgIG5vdGlmX2dvYWwgID0gTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfVE9QO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fYW5pbWF0ZV9lbHMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6ICAgIHNlbGYuX2dldF9lbCgnYmcnKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cjogICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgZ29hbDogIE1peHBhbmVsTm90aWZpY2F0aW9uLkJHX09QQUNJVFlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6ICAgIG5vdGlmX2VsLFxuICAgICAgICAgICAgICAgICAgICBhdHRyOiAgJ29wYWNpdHknLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgICAgICAgICBnb2FsOiAgMS4wXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiAgICBub3RpZl9lbCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cjogIG5vdGlmX2F0dHIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub3RpZl9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZ29hbDogIG5vdGlmX2dvYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLCBNaXhwYW5lbE5vdGlmaWNhdGlvbi5BTklNX1RJTUUsIHNlbGYuX21hcmtfYXNfc2hvd24pO1xuICAgICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICBfLnJlZ2lzdGVyX2V2ZW50KHNlbGYuX2dldF9lbCgnY2FuY2VsJyksICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZWxmLmRpc21pc3MoKTtcbiAgICB9KTtcbiAgICB2YXIgY2xpY2tfZWwgPSBzZWxmLl9nZXRfZWwoJ2J1dHRvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9nZXRfZWwoJ21pbmktY29udGVudCcpO1xuICAgIF8ucmVnaXN0ZXJfZXZlbnQoY2xpY2tfZWwsICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc2VsZi5zaG93X3ZpZGVvKSB7XG4gICAgICAgICAgICBzZWxmLl90cmFja19ldmVudCgnJGNhbXBhaWduX29wZW4nLCB7JyRyZXNvdXJjZV90eXBlJzogJ3ZpZGVvJ30pO1xuICAgICAgICAgICAgc2VsZi5fc3dpdGNoX3RvX3ZpZGVvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmRpc21pc3MoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNsaWNrdGhyb3VnaCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2luZ19jYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubWl4cGFuZWwuZ2V0X2NvbmZpZygnaW5hcHBfbGlua19uZXdfd2luZG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oc2VsZi5kZXN0X3VybCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdfY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gc2VsZi5kZXN0X3VybDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5fdHJhY2tfZXZlbnQoJyRjYW1wYWlnbl9vcGVuJywgeyckcmVzb3VyY2VfdHlwZSc6ICdsaW5rJ30sIHRyYWNraW5nX2NiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fZ2V0X2VsID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoTWl4cGFuZWxOb3RpZmljYXRpb24uTUFSS1VQX1BSRUZJWCArICctJyArIGlkKTtcbn07XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fZ2V0X25vdGlmaWNhdGlvbl9kaXNwbGF5X2VsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldF9lbCh0aGlzLm5vdGlmX3R5cGUpO1xufTtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLl9nZXRfc2hvd25fY2FtcGFpZ25zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VbJ3Byb3BzJ11bQ0FNUEFJR05fSURTX0tFWV0gfHwgKHRoaXMucGVyc2lzdGVuY2VbJ3Byb3BzJ11bQ0FNUEFJR05fSURTX0tFWV0gPSB7fSk7XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX21hdGNoZXNfZXZlbnRfZGF0YSA9IF8uc2FmZXdyYXAoZnVuY3Rpb24oZXZlbnRfZGF0YSkge1xuICAgIHZhciBldmVudF9uYW1lID0gZXZlbnRfZGF0YVsnZXZlbnQnXSB8fCAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlzcGxheV90cmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlzcGxheV90cmlnZ2VyID0gdGhpcy5kaXNwbGF5X3RyaWdnZXJzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hfZXZlbnQgPSBkaXNwbGF5X3RyaWdnZXJbJ2V2ZW50J10gfHwgJyc7XG4gICAgICAgIGlmIChtYXRjaF9ldmVudCA9PT0gJyRhbnlfZXZlbnQnIHx8IGV2ZW50X25hbWUgPT09IGRpc3BsYXlfdHJpZ2dlclsnZXZlbnQnXSkge1xuICAgICAgICAgICAgaWYgKGRpc3BsYXlfdHJpZ2dlclsnc2VsZWN0b3InXSAmJiAhXy5pc0VtcHR5T2JqZWN0KGRpc3BsYXlfdHJpZ2dlclsnc2VsZWN0b3InXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVTZWxlY3RvcihkaXNwbGF5X3RyaWdnZXJbJ3NlbGVjdG9yJ10sIGV2ZW50X2RhdGFbJ3Byb3BlcnRpZXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59KTtcblxuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2Jyb3dzZXJfbHRlID0gZnVuY3Rpb24oYnJvd3NlciwgdmVyc2lvbikge1xuICAgIHJldHVybiB0aGlzLmJyb3dzZXJfdmVyc2lvbnNbYnJvd3Nlcl0gJiYgdGhpcy5icm93c2VyX3ZlcnNpb25zW2Jyb3dzZXJdIDw9IHZlcnNpb247XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2luaXRfaW1hZ2VfaHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbWdzX3RvX3ByZWxvYWQgPSBbXTtcblxuICAgIGlmICghdGhpcy5taW5pKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlX3VybCkge1xuICAgICAgICAgICAgaW1nc190b19wcmVsb2FkLnB1c2godGhpcy5pbWFnZV91cmwpO1xuICAgICAgICAgICAgdGhpcy5pbWdfaHRtbCA9ICc8aW1nIGlkPVwiaW1nXCIgc3JjPVwiJyArIHRoaXMuaW1hZ2VfdXJsICsgJ1wiLz4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbWdfaHRtbCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRodW1iX2ltYWdlX3VybCkge1xuICAgICAgICAgICAgaW1nc190b19wcmVsb2FkLnB1c2godGhpcy50aHVtYl9pbWFnZV91cmwpO1xuICAgICAgICAgICAgdGhpcy50aHVtYl9pbWdfaHRtbCA9XG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwidGh1bWJib3JkZXItd3JhcHBlclwiPjxkaXYgaWQ9XCJ0aHVtYmJvcmRlclwiPjwvZGl2PjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPGltZyBpZD1cInRodW1ibmFpbFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHNyYz1cIicgKyB0aGlzLnRodW1iX2ltYWdlX3VybCArICdcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9JTUdfU0laRSArICdcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBoZWlnaHQ9XCInICsgTWl4cGFuZWxOb3RpZmljYXRpb24uVEhVTUJfSU1HX1NJWkUgKyAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgJy8+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwidGh1bWJzcGFjZXJcIj48L2Rpdj4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aHVtYl9pbWdfaHRtbCA9ICcnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHVtYl9pbWFnZV91cmwgPSB0aGlzLnRodW1iX2ltYWdlX3VybCB8fCAodGhpcy5jZG5faG9zdCArICcvc2l0ZV9tZWRpYS9pbWFnZXMvaWNvbnMvbm90aWZpY2F0aW9ucy9taW5pLW5ld3MtZGFyay5wbmcnKTtcbiAgICAgICAgaW1nc190b19wcmVsb2FkLnB1c2godGhpcy50aHVtYl9pbWFnZV91cmwpO1xuICAgIH1cblxuICAgIHJldHVybiBpbWdzX3RvX3ByZWxvYWQ7XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2luaXRfbm90aWZpY2F0aW9uX2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vdGlmaWNhdGlvbl9odG1sID0gJyc7XG4gICAgdmFyIHZpZGVvX3NyYyAgICAgICAgID0gJyc7XG4gICAgdmFyIHZpZGVvX2h0bWwgICAgICAgID0gJyc7XG4gICAgdmFyIGNhbmNlbF9odG1sICAgICAgID0gJzxkaXYgaWQ9XCJjYW5jZWxcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiY2FuY2VsLWljb25cIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2Pic7XG5cbiAgICB0aGlzLm5vdGlmaWNhdGlvbl9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMubm90aWZpY2F0aW9uX2VsLmlkID0gTWl4cGFuZWxOb3RpZmljYXRpb24uTUFSS1VQX1BSRUZJWCArICctd3JhcHBlcic7XG4gICAgaWYgKCF0aGlzLm1pbmkpIHtcbiAgICAgICAgLy8gVEFLRU9WRVIgbm90aWZpY2F0aW9uXG4gICAgICAgIHZhciBjbG9zZV9odG1sICA9ICh0aGlzLmNsaWNrdGhyb3VnaCB8fCB0aGlzLnNob3dfdmlkZW8pID8gJycgOiAnPGRpdiBpZD1cImJ1dHRvbi1jbG9zZVwiPjwvZGl2PicsXG4gICAgICAgICAgICBwbGF5X2h0bWwgICA9IHRoaXMuc2hvd192aWRlbyA/ICc8ZGl2IGlkPVwiYnV0dG9uLXBsYXlcIj48L2Rpdj4nIDogJyc7XG4gICAgICAgIGlmICh0aGlzLl9icm93c2VyX2x0ZSgnaWUnLCA3KSkge1xuICAgICAgICAgICAgY2xvc2VfaHRtbCA9ICcnO1xuICAgICAgICAgICAgcGxheV9odG1sID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgbm90aWZpY2F0aW9uX2h0bWwgPVxuICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwidGFrZW92ZXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYl9pbWdfaHRtbCArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibWFpbmJveFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsX2h0bWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJjb250ZW50XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdfaHRtbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ0aXRsZVwiPicgKyB0aGlzLnRpdGxlICsgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiYm9keVwiPicgKyB0aGlzLmJvZHkgKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ0YWdsaW5lXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiaHR0cDovL21peHBhbmVsLmNvbT9mcm9tPWluYXBwXCIgdGFyZ2V0PVwiX2JsYW5rXCI+UE9XRVJFRCBCWSBNSVhQQU5FTDwvYT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImJ1dHRvblwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlX2h0bWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YSBpZD1cImJ1dHRvbi1saW5rXCIgaHJlZj1cIicgKyB0aGlzLmRlc3RfdXJsICsgJ1wiPicgKyB0aGlzLmN0YSArICc8L2E+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheV9odG1sICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1JTkkgbm90aWZpY2F0aW9uXG4gICAgICAgIG5vdGlmaWNhdGlvbl9odG1sID1cbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cIm1pbmlcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJtYWluYm94XCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxfaHRtbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cIm1pbmktY29udGVudFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibWluaS1pY29uXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibWluaS1pY29uLWltZ1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImJvZHlcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJib2R5LXRleHRcIj48ZGl2PicgKyB0aGlzLmJvZHkgKyAnPC9kaXY+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwibWluaS1ib3JkZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICB9XG4gICAgaWYgKHRoaXMueW91dHViZV92aWRlbykge1xuICAgICAgICB2aWRlb19zcmMgPSB0aGlzLnJlc291cmNlX3Byb3RvY29sICsgJ3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICsgdGhpcy55b3V0dWJlX3ZpZGVvICtcbiAgICAgICAgICAgICAgICAnP3dtb2RlPXRyYW5zcGFyZW50JnNob3dpbmZvPTAmbW9kZXN0YnJhbmRpbmc9MCZyZWw9MCZhdXRvcGxheT0xJmxvb3A9MCZ2cT1oZDEwODAnO1xuICAgICAgICBpZiAodGhpcy55dF9jdXN0b20pIHtcbiAgICAgICAgICAgIHZpZGVvX3NyYyArPSAnJmVuYWJsZWpzYXBpPTEmaHRtbDU9MSZjb250cm9scz0wJztcbiAgICAgICAgICAgIHZpZGVvX2h0bWwgPVxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cInZpZGVvLWNvbnRyb2xzXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cInZpZGVvLXByb2dyZXNzXCIgY2xhc3M9XCJ2aWRlby1wcm9ncmVzcy1lbFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwidmlkZW8tcHJvZ3Jlc3MtdG90YWxcIiBjbGFzcz1cInZpZGVvLXByb2dyZXNzLWVsXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ2aWRlby1lbGFwc2VkXCIgY2xhc3M9XCJ2aWRlby1wcm9ncmVzcy1lbFwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ2aWRlby10aW1lXCIgY2xhc3M9XCJ2aWRlby1wcm9ncmVzcy1lbFwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy52aW1lb192aWRlbykge1xuICAgICAgICB2aWRlb19zcmMgPSB0aGlzLnJlc291cmNlX3Byb3RvY29sICsgJ3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIHRoaXMudmltZW9fdmlkZW8gKyAnP2F1dG9wbGF5PTEmdGl0bGU9MCZieWxpbmU9MCZwb3J0cmFpdD0wJztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvd192aWRlbykge1xuICAgICAgICB0aGlzLnZpZGVvX2lmcmFtZSA9XG4gICAgICAgICAgICAgICAgJzxpZnJhbWUgaWQ9XCInICsgTWl4cGFuZWxOb3RpZmljYXRpb24uTUFSS1VQX1BSRUZJWCArICctdmlkZW8tZnJhbWVcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoPVwiJyArIHRoaXMudmlkZW9fd2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMudmlkZW9faGVpZ2h0ICsgJ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnIHNyYz1cIicgKyB2aWRlb19zcmMgKyAnXCInICtcbiAgICAgICAgICAgICAgICAgICAgJyBmcmFtZWJvcmRlcj1cIjBcIiB3ZWJraXRhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIGFsbG93ZnVsbHNjcmVlbj1cIjFcIiBzY3JvbGxpbmc9XCJub1wiJyArXG4gICAgICAgICAgICAgICAgJz48L2lmcmFtZT4nO1xuICAgICAgICB2aWRlb19odG1sID1cbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cInZpZGVvLScgKyAodGhpcy5mbGlwX2FuaW1hdGUgPyAnJyA6ICdubycpICsgJ2ZsaXBcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ2aWRlb1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJ2aWRlby1ob2xkZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvX2h0bWwgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgfVxuICAgIHZhciBtYWluX2h0bWwgPSB2aWRlb19odG1sICsgbm90aWZpY2F0aW9uX2h0bWw7XG4gICAgaWYgKHRoaXMuZmxpcF9hbmltYXRlKSB7XG4gICAgICAgIG1haW5faHRtbCA9XG4gICAgICAgICAgICAgICAgKHRoaXMubWluaSA/IG5vdGlmaWNhdGlvbl9odG1sIDogJycpICtcbiAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImZsaXBjb250YWluZXJcIj48ZGl2IGlkPVwiZmxpcHBlclwiPicgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5taW5pID8gdmlkZW9faHRtbCA6IG1haW5faHRtbCkgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZpY2F0aW9uX2VsLmlubmVySFRNTCA9XG4gICAgICAgICgnPGRpdiBpZD1cIm92ZXJsYXlcIiBjbGFzcz1cIicgKyB0aGlzLm5vdGlmX3R5cGUgKyAnXCI+JyArXG4gICAgICAgICAgICAnPGRpdiBpZD1cImNhbXBhaWduaWQtJyArIHRoaXMuY2FtcGFpZ25faWQgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJiZ3dyYXBwZXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJiZ1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICBtYWluX2h0bWwgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2PicpXG4gICAgICAgICAgICAucmVwbGFjZSgvY2xhc3M9XCIvZywgJ2NsYXNzPVwiJyArIE1peHBhbmVsTm90aWZpY2F0aW9uLk1BUktVUF9QUkVGSVggKyAnLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvaWQ9XCIvZywgJ2lkPVwiJyArIE1peHBhbmVsTm90aWZpY2F0aW9uLk1BUktVUF9QUkVGSVggKyAnLScpO1xufTtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLl9pbml0X3N0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0eWxlID09PSAnZGFyaycpIHtcbiAgICAgICAgdGhpcy5zdHlsZV92YWxzID0ge1xuICAgICAgICAgICAgYmc6ICAgICAgICAgICAgICcjMWQxZjI1JyxcbiAgICAgICAgICAgIGJnX2FjdGlvbnM6ICAgICAnIzI4MmIzMicsXG4gICAgICAgICAgICBiZ19ob3ZlcjogICAgICAgJyMzYTQxNDcnLFxuICAgICAgICAgICAgYmdfbGlnaHQ6ICAgICAgICcjNGE1MTU3JyxcbiAgICAgICAgICAgIGJvcmRlcl9ncmF5OiAgICAnIzMyMzUzYycsXG4gICAgICAgICAgICBjYW5jZWxfb3BhY2l0eTogJzAuNCcsXG4gICAgICAgICAgICBtaW5pX2hvdmVyOiAgICAgJyMyYTMxMzcnLFxuICAgICAgICAgICAgdGV4dF90aXRsZTogICAgICcjZmZmJyxcbiAgICAgICAgICAgIHRleHRfbWFpbjogICAgICAnIzk0OThhMycsXG4gICAgICAgICAgICB0ZXh0X3RhZ2xpbmU6ICAgJyM0NjQ4NTEnLFxuICAgICAgICAgICAgdGV4dF9ob3ZlcjogICAgICcjZGRkJ1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3R5bGVfdmFscyA9IHtcbiAgICAgICAgICAgIGJnOiAgICAgICAgICAgICAnI2ZmZicsXG4gICAgICAgICAgICBiZ19hY3Rpb25zOiAgICAgJyNlN2VhZWUnLFxuICAgICAgICAgICAgYmdfaG92ZXI6ICAgICAgICcjZWNlZmYzJyxcbiAgICAgICAgICAgIGJnX2xpZ2h0OiAgICAgICAnI2Y1ZjVmNScsXG4gICAgICAgICAgICBib3JkZXJfZ3JheTogICAgJyNlNGVjZjInLFxuICAgICAgICAgICAgY2FuY2VsX29wYWNpdHk6ICcxLjAnLFxuICAgICAgICAgICAgbWluaV9ob3ZlcjogICAgICcjZmFmYWZhJyxcbiAgICAgICAgICAgIHRleHRfdGl0bGU6ICAgICAnIzVjNjU3OCcsXG4gICAgICAgICAgICB0ZXh0X21haW46ICAgICAgJyM4Yjk0OWInLFxuICAgICAgICAgICAgdGV4dF90YWdsaW5lOiAgICcjY2VkOWU2JyxcbiAgICAgICAgICAgIHRleHRfaG92ZXI6ICAgICAnIzdjODU5OCdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHNoYWRvdyA9ICcwcHggMHB4IDM1cHggMHB4IHJnYmEoNDUsIDQ5LCA1NiwgMC43KScsXG4gICAgICAgIHZpZGVvX3NoYWRvdyA9IHNoYWRvdyxcbiAgICAgICAgbWluaV9zaGFkb3cgPSBzaGFkb3csXG4gICAgICAgIHRodW1iX3RvdGFsX3NpemUgPSBNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9JTUdfU0laRSArIE1peHBhbmVsTm90aWZpY2F0aW9uLlRIVU1CX0JPUkRFUl9TSVpFICogMixcbiAgICAgICAgYW5pbV9zZWNvbmRzID0gKE1peHBhbmVsTm90aWZpY2F0aW9uLkFOSU1fVElNRSAvIDEwMDApICsgJ3MnO1xuICAgIGlmICh0aGlzLm1pbmkpIHtcbiAgICAgICAgc2hhZG93ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIGRvbid0IGRpc3BsYXkgb24gc21hbGwgdmlld3BvcnRzXG4gICAgdmFyIG5vdGlmX21lZGlhX3F1ZXJpZXMgPSB7fSxcbiAgICAgICAgbWluX3dpZHRoID0gTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEhfTUlOSSArIDIwO1xuICAgIG5vdGlmX21lZGlhX3F1ZXJpZXNbJ0BtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogJyArIChtaW5fd2lkdGggLSAxKSArICdweCknXSA9IHtcbiAgICAgICAgJyNvdmVybGF5Jzoge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG5vdGlmX3N0eWxlcyA9IHtcbiAgICAgICAgJy5mbGlwcGVkJzoge1xuICAgICAgICAgICAgJ3RyYW5zZm9ybSc6ICdyb3RhdGVZKDE4MGRlZyknXG4gICAgICAgIH0sXG4gICAgICAgICcjb3ZlcmxheSc6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdmaXhlZCcsXG4gICAgICAgICAgICAndG9wJzogJzAnLFxuICAgICAgICAgICAgJ2xlZnQnOiAnMCcsXG4gICAgICAgICAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ2F1dG8nLFxuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAgICd6LWluZGV4JzogJzEwMDAwJyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdcIkhlbHZldGljYVwiLCBcIkFyaWFsXCIsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgICAgJy13ZWJraXQtZm9udC1zbW9vdGhpbmcnOiAnYW50aWFsaWFzZWQnLFxuICAgICAgICAgICAgJy1tb3otb3N4LWZvbnQtc21vb3RoaW5nJzogJ2dyYXlzY2FsZSdcbiAgICAgICAgfSxcbiAgICAgICAgJyNvdmVybGF5Lm1pbmknOiB7XG4gICAgICAgICAgICAnaGVpZ2h0JzogJzAnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ3Zpc2libGUnXG4gICAgICAgIH0sXG4gICAgICAgICcjb3ZlcmxheSBhJzoge1xuICAgICAgICAgICAgJ3dpZHRoJzogJ2luaXRpYWwnLFxuICAgICAgICAgICAgJ3BhZGRpbmcnOiAnMCcsXG4gICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2NvbG9yJzogJ2luaGVyaXQnXG4gICAgICAgIH0sXG4gICAgICAgICcjYmd3cmFwcGVyJzoge1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICd3aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJyNiZyc6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdmaXhlZCcsXG4gICAgICAgICAgICAndG9wJzogJzAnLFxuICAgICAgICAgICAgJ2xlZnQnOiAnMCcsXG4gICAgICAgICAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICAgJ21pbi13aWR0aCc6IHRoaXMuZG9jX3dpZHRoICogNCArICdweCcsXG4gICAgICAgICAgICAnbWluLWhlaWdodCc6IHRoaXMuZG9jX2hlaWdodCAqIDQgKyAncHgnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICAgJ29wYWNpdHknOiAnMC4wJyxcbiAgICAgICAgICAgICctbXMtZmlsdGVyJzogJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTYwKScsIC8vIElFOFxuICAgICAgICAgICAgJ2ZpbHRlcic6ICdhbHBoYShvcGFjaXR5PTYwKScsIC8vIElFNS03XG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdvcGFjaXR5ICcgKyBhbmltX3NlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgJyNiZy52aXNpYmxlJzoge1xuICAgICAgICAgICAgJ29wYWNpdHknOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5CR19PUEFDSVRZXG4gICAgICAgIH0sXG4gICAgICAgICcubWluaSAjYmcnOiB7XG4gICAgICAgICAgICAnd2lkdGgnOiAnMCcsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzAnLFxuICAgICAgICAgICAgJ21pbi13aWR0aCc6ICcwJ1xuICAgICAgICB9LFxuICAgICAgICAnI2ZsaXBjb250YWluZXInOiB7XG4gICAgICAgICAgICAncGVyc3BlY3RpdmUnOiAnMTAwMHB4JyxcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAnd2lkdGgnOiAnMTAwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJyNmbGlwcGVyJzoge1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tc3R5bGUnOiAncHJlc2VydmUtM2QnLFxuICAgICAgICAgICAgJ3RyYW5zaXRpb24nOiAnMC4zcydcbiAgICAgICAgfSxcbiAgICAgICAgJyN0YWtlb3Zlcic6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAnbGVmdCc6ICc1MCUnLFxuICAgICAgICAgICAgJ3dpZHRoJzogTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEggKyAncHgnLFxuICAgICAgICAgICAgJ21hcmdpbi1sZWZ0JzogTWF0aC5yb3VuZCgtTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEggLyAyKSArICdweCcsXG4gICAgICAgICAgICAnYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybSc6ICdyb3RhdGVZKDBkZWcpJyxcbiAgICAgICAgICAgICdvcGFjaXR5JzogJzAuMCcsXG4gICAgICAgICAgICAndG9wJzogTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfU1RBUlRfVE9QICsgJ3B4JyxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ29wYWNpdHkgJyArIGFuaW1fc2Vjb25kcyArICcsIHRvcCAnICsgYW5pbV9zZWNvbmRzXG4gICAgICAgIH0sXG4gICAgICAgICcjdGFrZW92ZXIudmlzaWJsZSc6IHtcbiAgICAgICAgICAgICdvcGFjaXR5JzogJzEuMCcsXG4gICAgICAgICAgICAndG9wJzogTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfVE9QICsgJ3B4J1xuICAgICAgICB9LFxuICAgICAgICAnI3Rha2VvdmVyLmV4aXRpbmcnOiB7XG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcwLjAnLFxuICAgICAgICAgICAgJ3RvcCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1NUQVJUX1RPUCArICdweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyN0aHVtYnNwYWNlcic6IHtcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9PRkZTRVQgKyAncHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjdGh1bWJib3JkZXItd3JhcHBlcic6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAndG9wJzogKC1NaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9CT1JERVJfU0laRSkgKyAncHgnLFxuICAgICAgICAgICAgJ2xlZnQnOiAoTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEggLyAyIC0gTWl4cGFuZWxOb3RpZmljYXRpb24uVEhVTUJfT0ZGU0VUIC0gTWl4cGFuZWxOb3RpZmljYXRpb24uVEhVTUJfQk9SREVSX1NJWkUpICsgJ3B4JyxcbiAgICAgICAgICAgICd3aWR0aCc6IHRodW1iX3RvdGFsX3NpemUgKyAncHgnLFxuICAgICAgICAgICAgJ2hlaWdodCc6ICh0aHVtYl90b3RhbF9zaXplIC8gMikgKyAncHgnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbidcbiAgICAgICAgfSxcbiAgICAgICAgJyN0aHVtYmJvcmRlcic6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAnd2lkdGgnOiB0aHVtYl90b3RhbF9zaXplICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiB0aHVtYl90b3RhbF9zaXplICsgJ3B4JyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogdGh1bWJfdG90YWxfc2l6ZSArICdweCcsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuc3R5bGVfdmFscy5iZ19hY3Rpb25zLFxuICAgICAgICAgICAgJ29wYWNpdHknOiAnMC41J1xuICAgICAgICB9LFxuICAgICAgICAnI3RodW1ibmFpbCc6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAndG9wJzogJzBweCcsXG4gICAgICAgICAgICAnbGVmdCc6IChNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9XSURUSCAvIDIgLSBNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9PRkZTRVQpICsgJ3B4JyxcbiAgICAgICAgICAgICd3aWR0aCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLlRIVU1CX0lNR19TSVpFICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5USFVNQl9JTUdfU0laRSArICdweCcsXG4gICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICd6LWluZGV4JzogJzEwMCcsXG4gICAgICAgICAgICAnYm9yZGVyLXJhZGl1cyc6IE1peHBhbmVsTm90aWZpY2F0aW9uLlRIVU1CX0lNR19TSVpFICsgJ3B4J1xuICAgICAgICB9LFxuICAgICAgICAnI21pbmknOiB7XG4gICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgJ3JpZ2h0JzogJzIwcHgnLFxuICAgICAgICAgICAgJ3RvcCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1RPUCArICdweCcsXG4gICAgICAgICAgICAnd2lkdGgnOiB0aGlzLm5vdGlmX3dpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9IRUlHSFRfTUlOSSAqIDIgKyAncHgnLFxuICAgICAgICAgICAgJ21hcmdpbi10b3AnOiAyMCAtIE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX0hFSUdIVF9NSU5JICsgJ3B4JyxcbiAgICAgICAgICAgICdiYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcwLjAnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybSc6ICdyb3RhdGVYKDkwZGVnKScsXG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdvcGFjaXR5IDAuM3MsIHRyYW5zZm9ybSAwLjNzLCByaWdodCAwLjNzJ1xuICAgICAgICB9LFxuICAgICAgICAnI21pbmkudmlzaWJsZSc6IHtcbiAgICAgICAgICAgICdvcGFjaXR5JzogJzEuMCcsXG4gICAgICAgICAgICAndHJhbnNmb3JtJzogJ3JvdGF0ZVgoMGRlZyknXG4gICAgICAgIH0sXG4gICAgICAgICcjbWluaS5leGl0aW5nJzoge1xuICAgICAgICAgICAgJ29wYWNpdHknOiAnMC4wJyxcbiAgICAgICAgICAgICdyaWdodCc6ICctMTUwcHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjbWFpbmJveCc6IHtcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzRweCcsXG4gICAgICAgICAgICAnYm94LXNoYWRvdyc6IHNoYWRvdyxcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuc3R5bGVfdmFscy5iZyxcbiAgICAgICAgICAgICdmb250LXNpemUnOiAnMTRweCcsXG4gICAgICAgICAgICAnY29sb3InOiB0aGlzLnN0eWxlX3ZhbHMudGV4dF9tYWluXG4gICAgICAgIH0sXG4gICAgICAgICcjbWluaSAjbWFpbmJveCc6IHtcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9IRUlHSFRfTUlOSSArICdweCcsXG4gICAgICAgICAgICAnbWFyZ2luLXRvcCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX0hFSUdIVF9NSU5JICsgJ3B4JyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzNweCcsXG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdiYWNrZ3JvdW5kLWNvbG9yICcgKyBhbmltX3NlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgJyNtaW5pLWJvcmRlcic6IHtcbiAgICAgICAgICAgICdoZWlnaHQnOiAoTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfSEVJR0hUX01JTkkgKyA2KSArICdweCcsXG4gICAgICAgICAgICAnd2lkdGgnOiAoTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfV0lEVEhfTUlOSSArIDYpICsgJ3B4JyxcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAndG9wJzogJy0zcHgnLFxuICAgICAgICAgICAgJ2xlZnQnOiAnLTNweCcsXG4gICAgICAgICAgICAnbWFyZ2luLXRvcCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX0hFSUdIVF9NSU5JICsgJ3B4JyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzZweCcsXG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcwLjI1JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNmZmYnLFxuICAgICAgICAgICAgJ3otaW5kZXgnOiAnLTEnLFxuICAgICAgICAgICAgJ2JveC1zaGFkb3cnOiBtaW5pX3NoYWRvd1xuICAgICAgICB9LFxuICAgICAgICAnI21pbmktaWNvbic6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgJ3dpZHRoJzogJzc1cHgnLFxuICAgICAgICAgICAgJ2hlaWdodCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX0hFSUdIVF9NSU5JICsgJ3B4JyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzNweCAwIDAgM3B4JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5zdHlsZV92YWxzLmJnX2FjdGlvbnMsXG4gICAgICAgICAgICAnYmFja2dyb3VuZCc6ICdsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAnICsgdGhpcy5zdHlsZV92YWxzLmJnX2xpZ2h0ICsgJyAwJSwgJyArIHRoaXMuc3R5bGVfdmFscy5iZ19hY3Rpb25zICsgJyAxMDAlKScsXG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdiYWNrZ3JvdW5kLWNvbG9yICcgKyBhbmltX3NlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgJyNtaW5pOmhvdmVyICNtaW5pLWljb24nOiB7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuc3R5bGVfdmFscy5taW5pX2hvdmVyXG4gICAgICAgIH0sXG4gICAgICAgICcjbWluaTpob3ZlciAjbWFpbmJveCc6IHtcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5zdHlsZV92YWxzLm1pbmlfaG92ZXJcbiAgICAgICAgfSxcbiAgICAgICAgJyNtaW5pLWljb24taW1nJzoge1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdGhpcy50aHVtYl9pbWFnZV91cmwgKyAnKScsXG4gICAgICAgICAgICAnd2lkdGgnOiAnNDhweCcsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzQ4cHgnLFxuICAgICAgICAgICAgJ3RvcCc6ICcyMHB4JyxcbiAgICAgICAgICAgICdsZWZ0JzogJzEycHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjY29udGVudCc6IHtcbiAgICAgICAgICAgICdwYWRkaW5nJzogJzMwcHggMjBweCAwcHggMjBweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyNtaW5pLWNvbnRlbnQnOiB7XG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdsZWZ0JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9IRUlHSFRfTUlOSSArICdweCcsXG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH0sXG4gICAgICAgICcjaW1nJzoge1xuICAgICAgICAgICAgJ3dpZHRoJzogJzMyOHB4JyxcbiAgICAgICAgICAgICdtYXJnaW4tdG9wJzogJzMwcHgnLFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnNXB4J1xuICAgICAgICB9LFxuICAgICAgICAnI3RpdGxlJzoge1xuICAgICAgICAgICAgJ21heC1oZWlnaHQnOiAnNjAwcHgnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnd29yZC13cmFwJzogJ2JyZWFrLXdvcmQnLFxuICAgICAgICAgICAgJ3BhZGRpbmcnOiAnMjVweCAwcHggMjBweCAwcHgnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxOXB4JyxcbiAgICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcbiAgICAgICAgICAgICdjb2xvcic6IHRoaXMuc3R5bGVfdmFscy50ZXh0X3RpdGxlXG4gICAgICAgIH0sXG4gICAgICAgICcjYm9keSc6IHtcbiAgICAgICAgICAgICdtYXgtaGVpZ2h0JzogJzYwMHB4JyxcbiAgICAgICAgICAgICdtYXJnaW4tYm90dG9tJzogJzI1cHgnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnd29yZC13cmFwJzogJ2JyZWFrLXdvcmQnLFxuICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0JzogJzIxcHgnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxNXB4JyxcbiAgICAgICAgICAgICdmb250LXdlaWdodCc6ICdub3JtYWwnLFxuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgJyNtaW5pICNib2R5Jzoge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICdtYXgtd2lkdGgnOiAnMjUwcHgnLFxuICAgICAgICAgICAgJ21hcmdpbic6ICcwIDAgMCAzMHB4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiBNaXhwYW5lbE5vdGlmaWNhdGlvbi5OT1RJRl9IRUlHSFRfTUlOSSArICdweCcsXG4gICAgICAgICAgICAnZm9udC1zaXplJzogJzE2cHgnLFxuICAgICAgICAgICAgJ2xldHRlci1zcGFjaW5nJzogJzAuOHB4JyxcbiAgICAgICAgICAgICdjb2xvcic6IHRoaXMuc3R5bGVfdmFscy50ZXh0X3RpdGxlXG4gICAgICAgIH0sXG4gICAgICAgICcjbWluaSAjYm9keS10ZXh0Jzoge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAndGFibGUnLFxuICAgICAgICAgICAgJ2hlaWdodCc6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX0hFSUdIVF9NSU5JICsgJ3B4J1xuICAgICAgICB9LFxuICAgICAgICAnI21pbmkgI2JvZHktdGV4dCBkaXYnOiB7XG4gICAgICAgICAgICAnZGlzcGxheSc6ICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICdtaWRkbGUnXG4gICAgICAgIH0sXG4gICAgICAgICcjdGFnbGluZSc6IHtcbiAgICAgICAgICAgICdtYXJnaW4tYm90dG9tJzogJzE1cHgnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMHB4JyxcbiAgICAgICAgICAgICdmb250LXdlaWdodCc6ICc2MDAnLFxuICAgICAgICAgICAgJ2xldHRlci1zcGFjaW5nJzogJzAuOHB4JyxcbiAgICAgICAgICAgICdjb2xvcic6ICcjY2NkN2UwJyxcbiAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgICcjdGFnbGluZSBhJzoge1xuICAgICAgICAgICAgJ2NvbG9yJzogdGhpcy5zdHlsZV92YWxzLnRleHRfdGFnbGluZSxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2NvbG9yICcgKyBhbmltX3NlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgJyN0YWdsaW5lIGE6aG92ZXInOiB7XG4gICAgICAgICAgICAnY29sb3InOiB0aGlzLnN0eWxlX3ZhbHMudGV4dF9ob3ZlclxuICAgICAgICB9LFxuICAgICAgICAnI2NhbmNlbCc6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAncmlnaHQnOiAnMCcsXG4gICAgICAgICAgICAnd2lkdGgnOiAnOHB4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnOHB4JyxcbiAgICAgICAgICAgICdwYWRkaW5nJzogJzEwcHgnLFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnMjBweCcsXG4gICAgICAgICAgICAnbWFyZ2luJzogJzEycHggMTJweCAwIDAnLFxuICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2JhY2tncm91bmQtY29sb3IgJyArIGFuaW1fc2Vjb25kc1xuICAgICAgICB9LFxuICAgICAgICAnI21pbmkgI2NhbmNlbCc6IHtcbiAgICAgICAgICAgICdtYXJnaW4nOiAnN3B4IDdweCAwIDAnXG4gICAgICAgIH0sXG4gICAgICAgICcjY2FuY2VsLWljb24nOiB7XG4gICAgICAgICAgICAnd2lkdGgnOiAnOHB4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnOHB4JyxcbiAgICAgICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKCcgKyB0aGlzLmNkbl9ob3N0ICsgJy9zaXRlX21lZGlhL2ltYWdlcy9pY29ucy9ub3RpZmljYXRpb25zL2NhbmNlbC14LnBuZyknLFxuICAgICAgICAgICAgJ29wYWNpdHknOiB0aGlzLnN0eWxlX3ZhbHMuY2FuY2VsX29wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgJyNjYW5jZWw6aG92ZXInOiB7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuc3R5bGVfdmFscy5iZ19ob3ZlclxuICAgICAgICB9LFxuICAgICAgICAnI2J1dHRvbic6IHtcbiAgICAgICAgICAgICdkaXNwbGF5JzogJ2Jsb2NrJyxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnNjBweCcsXG4gICAgICAgICAgICAnbGluZS1oZWlnaHQnOiAnNjBweCcsXG4gICAgICAgICAgICAndGV4dC1hbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB0aGlzLnN0eWxlX3ZhbHMuYmdfYWN0aW9ucyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzAgMCA0cHggNHB4JyxcbiAgICAgICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2JhY2tncm91bmQtY29sb3IgJyArIGFuaW1fc2Vjb25kc1xuICAgICAgICB9LFxuICAgICAgICAnI2J1dHRvbi1jbG9zZSc6IHtcbiAgICAgICAgICAgICdkaXNwbGF5JzogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAnd2lkdGgnOiAnOXB4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnNjBweCcsXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogJzhweCcsXG4gICAgICAgICAgICAndmVydGljYWwtYWxpZ24nOiAndG9wJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdGhpcy5jZG5faG9zdCArICcvc2l0ZV9tZWRpYS9pbWFnZXMvaWNvbnMvbm90aWZpY2F0aW9ucy9jbG9zZS14LScgKyB0aGlzLnN0eWxlICsgJy5wbmcpJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnMHB4IDI1cHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjYnV0dG9uLXBsYXknOiB7XG4gICAgICAgICAgICAnZGlzcGxheSc6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgJ3dpZHRoJzogJzMwcHgnLFxuICAgICAgICAgICAgJ2hlaWdodCc6ICc2MHB4JyxcbiAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6ICcxNXB4JyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdGhpcy5jZG5faG9zdCArICcvc2l0ZV9tZWRpYS9pbWFnZXMvaWNvbnMvbm90aWZpY2F0aW9ucy9wbGF5LScgKyB0aGlzLnN0eWxlICsgJy1zbWFsbC5wbmcpJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnMHB4IDE1cHgnXG4gICAgICAgIH0sXG4gICAgICAgICdhI2J1dHRvbi1saW5rJzoge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnLFxuICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAgICdmb250LXNpemUnOiAnMTdweCcsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICd3b3JkLXdyYXAnOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICAnY29sb3InOiB0aGlzLnN0eWxlX3ZhbHMudGV4dF90aXRsZSxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ2NvbG9yICcgKyBhbmltX3NlY29uZHNcbiAgICAgICAgfSxcbiAgICAgICAgJyNidXR0b246aG92ZXInOiB7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuc3R5bGVfdmFscy5iZ19ob3ZlcixcbiAgICAgICAgICAgICdjb2xvcic6IHRoaXMuc3R5bGVfdmFscy50ZXh0X2hvdmVyXG4gICAgICAgIH0sXG4gICAgICAgICcjYnV0dG9uOmhvdmVyIGEnOiB7XG4gICAgICAgICAgICAnY29sb3InOiB0aGlzLnN0eWxlX3ZhbHMudGV4dF9ob3ZlclxuICAgICAgICB9LFxuXG4gICAgICAgICcjdmlkZW8tbm9mbGlwJzoge1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICd0b3AnOiAoLXRoaXMudmlkZW9faGVpZ2h0ICogMikgKyAncHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjdmlkZW8tZmxpcCc6IHtcbiAgICAgICAgICAgICdiYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAndHJhbnNmb3JtJzogJ3JvdGF0ZVkoMTgwZGVnKSdcbiAgICAgICAgfSxcbiAgICAgICAgJyN2aWRlbyc6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAnd2lkdGgnOiAodGhpcy52aWRlb193aWR0aCAtIDEpICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiB0aGlzLnZpZGVvX2hlaWdodCArICdweCcsXG4gICAgICAgICAgICAndG9wJzogTWl4cGFuZWxOb3RpZmljYXRpb24uTk9USUZfVE9QICsgJ3B4JyxcbiAgICAgICAgICAgICdtYXJnaW4tdG9wJzogJzEwMHB4JyxcbiAgICAgICAgICAgICdsZWZ0JzogJzUwJScsXG4gICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBNYXRoLnJvdW5kKC10aGlzLnZpZGVvX3dpZHRoIC8gMikgKyAncHgnLFxuICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnYm9yZGVyLXJhZGl1cyc6ICc1cHgnLFxuICAgICAgICAgICAgJ2JveC1zaGFkb3cnOiB2aWRlb19zaGFkb3csXG4gICAgICAgICAgICAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZVooMXB4KScsIC8vIHdlYmtpdCByZW5kZXJpbmcgYnVnIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxNjc5ODEvY2xpY2thYmxlLWxpbmstYXJlYS11bmV4cGVjdGVkbHktc21hbGxlci1hZnRlci1jc3MtdHJhbnNmb3JtXG4gICAgICAgICAgICAndHJhbnNpdGlvbic6ICdvcGFjaXR5ICcgKyBhbmltX3NlY29uZHMgKyAnLCB0b3AgJyArIGFuaW1fc2Vjb25kc1xuICAgICAgICB9LFxuICAgICAgICAnI3ZpZGVvLmV4aXRpbmcnOiB7XG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcwLjAnLFxuICAgICAgICAgICAgJ3RvcCc6IHRoaXMudmlkZW9faGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9LFxuICAgICAgICAnI3ZpZGVvLWhvbGRlcic6IHtcbiAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAnd2lkdGgnOiAodGhpcy52aWRlb193aWR0aCAtIDEpICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQnOiB0aGlzLnZpZGVvX2hlaWdodCArICdweCcsXG4gICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzVweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyN2aWRlby1mcmFtZSc6IHtcbiAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6ICctMXB4JyxcbiAgICAgICAgICAgICd3aWR0aCc6IHRoaXMudmlkZW9fd2lkdGggKyAncHgnXG4gICAgICAgIH0sXG4gICAgICAgICcjdmlkZW8tY29udHJvbHMnOiB7XG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcwJyxcbiAgICAgICAgICAgICd0cmFuc2l0aW9uJzogJ29wYWNpdHkgMC41cydcbiAgICAgICAgfSxcbiAgICAgICAgJyN2aWRlbzpob3ZlciAjdmlkZW8tY29udHJvbHMnOiB7XG4gICAgICAgICAgICAnb3BhY2l0eSc6ICcxLjAnXG4gICAgICAgIH0sXG4gICAgICAgICcjdmlkZW8gLnZpZGVvLXByb2dyZXNzLWVsJzoge1xuICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICdib3R0b20nOiAnMCcsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJzI1cHgnLFxuICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnMCAwIDAgNXB4J1xuICAgICAgICB9LFxuICAgICAgICAnI3ZpZGVvLXByb2dyZXNzJzoge1xuICAgICAgICAgICAgJ3dpZHRoJzogJzkwJSdcbiAgICAgICAgfSxcbiAgICAgICAgJyN2aWRlby1wcm9ncmVzcy10b3RhbCc6IHtcbiAgICAgICAgICAgICd3aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5zdHlsZV92YWxzLmJnLFxuICAgICAgICAgICAgJ29wYWNpdHknOiAnMC43J1xuICAgICAgICB9LFxuICAgICAgICAnI3ZpZGVvLWVsYXBzZWQnOiB7XG4gICAgICAgICAgICAnd2lkdGgnOiAnMCcsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjNmNiNmY1JyxcbiAgICAgICAgICAgICdvcGFjaXR5JzogJzAuOSdcbiAgICAgICAgfSxcbiAgICAgICAgJyN2aWRlbyAjdmlkZW8tdGltZSc6IHtcbiAgICAgICAgICAgICd3aWR0aCc6ICcxMCUnLFxuICAgICAgICAgICAgJ3JpZ2h0JzogJzAnLFxuICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMXB4JyxcbiAgICAgICAgICAgICdsaW5lLWhlaWdodCc6ICcyNXB4JyxcbiAgICAgICAgICAgICdjb2xvcic6IHRoaXMuc3R5bGVfdmFscy50ZXh0X21haW4sXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjNjY2JyxcbiAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogJzAgMCA1cHggMCdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJRSBoYWNrc1xuICAgIGlmICh0aGlzLl9icm93c2VyX2x0ZSgnaWUnLCA4KSkge1xuICAgICAgICBfLmV4dGVuZChub3RpZl9zdHlsZXMsIHtcbiAgICAgICAgICAgICcqIGh0bWwgI292ZXJsYXknOiB7XG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICcqIGh0bWwgI2JnJzoge1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnaHRtbCwgYm9keSc6IHtcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYnJvd3Nlcl9sdGUoJ2llJywgNykpIHtcbiAgICAgICAgXy5leHRlbmQobm90aWZfc3R5bGVzLCB7XG4gICAgICAgICAgICAnI21pbmkgI2JvZHknOiB7XG4gICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICAnem9vbSc6ICcxJyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyJzogJzFweCBzb2xpZCAnICsgdGhpcy5zdHlsZV92YWxzLmJnX2hvdmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyNtaW5pICNib2R5LXRleHQnOiB7XG4gICAgICAgICAgICAgICAgJ3BhZGRpbmcnOiAnMjBweCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnI21pbmkgI21pbmktaWNvbic6IHtcbiAgICAgICAgICAgICAgICAnZGlzcGxheSc6ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHJ1bGVzXG4gICAgdmFyIFZFTkRPUl9TVFlMRVMgPSBbXG4gICAgICAgICAgICAnYmFja2ZhY2UtdmlzaWJpbGl0eScsICdib3JkZXItcmFkaXVzJywgJ2JveC1zaGFkb3cnLCAnb3BhY2l0eScsXG4gICAgICAgICAgICAncGVyc3BlY3RpdmUnLCAndHJhbnNmb3JtJywgJ3RyYW5zZm9ybS1zdHlsZScsICd0cmFuc2l0aW9uJ1xuICAgICAgICBdLFxuICAgICAgICBWRU5ET1JfUFJFRklYRVMgPSBbJ2todG1sJywgJ21veicsICdtcycsICdvJywgJ3dlYmtpdCddO1xuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIG5vdGlmX3N0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgVkVORE9SX1NUWUxFUy5sZW5ndGg7IHNpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wID0gVkVORE9SX1NUWUxFU1tzaV07XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBub3RpZl9zdHlsZXNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG5vdGlmX3N0eWxlc1tzZWxlY3Rvcl1bcHJvcF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZfc3R5bGVzW3NlbGVjdG9yXVsnLScgKyBWRU5ET1JfUFJFRklYRVNbcGldICsgJy0nICsgcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluamVjdF9zdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMsIG1lZGlhX3F1ZXJpZXMpIHtcbiAgICAgICAgdmFyIGNyZWF0ZV9zdHlsZV90ZXh0ID0gZnVuY3Rpb24oc3R5bGVfZGVmcykge1xuICAgICAgICAgICAgdmFyIHN0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZV9kZWZzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1wX3NlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyMvZywgJyMnICsgTWl4cGFuZWxOb3RpZmljYXRpb24uTUFSS1VQX1BSRUZJWCArICctJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLi9nLCAnLicgKyBNaXhwYW5lbE5vdGlmaWNhdGlvbi5NQVJLVVBfUFJFRklYICsgJy0nKTtcbiAgICAgICAgICAgICAgICBzdCArPSAnXFxuJyArIG1wX3NlbGVjdG9yICsgJyB7JztcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBzdHlsZV9kZWZzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ICs9IGsgKyAnOicgKyBwcm9wc1trXSArICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3QgKz0gJ30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlX21lZGlhX3F1ZXJ5X3RleHQgPSBmdW5jdGlvbihtcV9kZWZzKSB7XG4gICAgICAgICAgICB2YXIgbXF0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBtcSBpbiBtcV9kZWZzKSB7XG4gICAgICAgICAgICAgICAgbXF0ICs9ICdcXG4nICsgbXEgKyAnIHsnICsgY3JlYXRlX3N0eWxlX3RleHQobXFfZGVmc1ttcV0pICsgJ1xcbn0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1xdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3R5bGVfdGV4dCA9IGNyZWF0ZV9zdHlsZV90ZXh0KHN0eWxlcykgKyBjcmVhdGVfbWVkaWFfcXVlcnlfdGV4dChtZWRpYV9xdWVyaWVzKSxcbiAgICAgICAgICAgIGhlYWRfZWwgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgc3R5bGVfZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBoZWFkX2VsLmFwcGVuZENoaWxkKHN0eWxlX2VsKTtcbiAgICAgICAgc3R5bGVfZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgIGlmIChzdHlsZV9lbC5zdHlsZVNoZWV0KSB7IC8vIElFXG4gICAgICAgICAgICBzdHlsZV9lbC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZV90ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVfZWwudGV4dENvbnRlbnQgPSBzdHlsZV90ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbmplY3Rfc3R5bGVzKG5vdGlmX3N0eWxlcywgbm90aWZfbWVkaWFfcXVlcmllcyk7XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX2luaXRfdmlkZW8gPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy52aWRlb191cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBZb3V0dWJlIGlmcmFtZSBBUEkgY29tcGF0aWJpbGl0eVxuICAgIHNlbGYueXRfY3VzdG9tID0gJ3Bvc3RNZXNzYWdlJyBpbiB3aW5kb3c7XG5cbiAgICBzZWxmLmRlc3RfdXJsID0gc2VsZi52aWRlb191cmw7XG4gICAgdmFyIHlvdXR1YmVfbWF0Y2ggPSBzZWxmLnZpZGVvX3VybC5tYXRjaChcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkzNjQ2Ny9wYXJzZS15b3V0dWJlLXZpZGVvLWlkLXVzaW5nLXByZWctbWF0Y2hcbiAgICAgICAgICAgIC8oPzp5b3V0dWJlKD86LW5vY29va2llKT9cXC5jb21cXC8oPzpbXi9dK1xcLy4rXFwvfCg/OnZ8ZSg/Om1iZWQpPylcXC98LipbPyZddj0pfHlvdXR1XFwuYmVcXC8pKFteXCImPy8gXXsxMX0pL2lcbiAgICAgICAgKSxcbiAgICAgICAgdmltZW9fbWF0Y2ggPSBzZWxmLnZpZGVvX3VybC5tYXRjaChcbiAgICAgICAgICAgIC92aW1lb1xcLmNvbVxcLy4qPyhcXGQrKS9pXG4gICAgICAgICk7XG4gICAgaWYgKHlvdXR1YmVfbWF0Y2gpIHtcbiAgICAgICAgc2VsZi5zaG93X3ZpZGVvID0gdHJ1ZTtcbiAgICAgICAgc2VsZi55b3V0dWJlX3ZpZGVvID0geW91dHViZV9tYXRjaFsxXTtcblxuICAgICAgICBpZiAoc2VsZi55dF9jdXN0b20pIHtcbiAgICAgICAgICAgIHdpbmRvd1snb25Zb3VUdWJlSWZyYW1lQVBJUmVhZHknXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9nZXRfZWwoJ3ZpZGVvLWZyYW1lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5feXRfdmlkZW9fcmVhZHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBsb2FkIFlvdXR1YmUgaWZyYW1lIEFQSTsgc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvaWZyYW1lX2FwaV9yZWZlcmVuY2VcbiAgICAgICAgICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHRhZy5zcmMgPSBzZWxmLnJlc291cmNlX3Byb3RvY29sICsgJ3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpJztcbiAgICAgICAgICAgIHZhciBmaXJzdFNjcmlwdFRhZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgICAgIGZpcnN0U2NyaXB0VGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhZywgZmlyc3RTY3JpcHRUYWcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh2aW1lb19tYXRjaCkge1xuICAgICAgICBzZWxmLnNob3dfdmlkZW8gPSB0cnVlO1xuICAgICAgICBzZWxmLnZpbWVvX3ZpZGVvID0gdmltZW9fbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgLy8gSUUgPD0gNywgRkYgPD0gMzogZmFsbCB0aHJvdWdoIHRvIHZpZGVvIGxpbmsgcmF0aGVyIHRoYW4gZW1iZWRkZWQgcGxheWVyXG4gICAgaWYgKHNlbGYuX2Jyb3dzZXJfbHRlKCdpZScsIDcpIHx8IHNlbGYuX2Jyb3dzZXJfbHRlKCdmaXJlZm94JywgMykpIHtcbiAgICAgICAgc2VsZi5zaG93X3ZpZGVvID0gZmFsc2U7XG4gICAgICAgIHNlbGYuY2xpY2t0aHJvdWdoID0gdHJ1ZTtcbiAgICB9XG59KTtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLl9tYXJrX2FzX3Nob3duID0gXy5zYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAvLyBjbGljayBvbiBiYWNrZ3JvdW5kIHRvIGRpc21pc3NcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5yZWdpc3Rlcl9ldmVudChzZWxmLl9nZXRfZWwoJ2JnJyksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmRpc21pc3MoKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXRfc3R5bGUgPSBmdW5jdGlvbihlbCwgc3R5bGVfbmFtZSkge1xuICAgICAgICB2YXIgc3R5bGVzID0ge307XG4gICAgICAgIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTsgLy8gRkYzIHJlcXVpcmVzIGJvdGggYXJnc1xuICAgICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkgeyAvLyBJRVxuICAgICAgICAgICAgc3R5bGVzID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXNbc3R5bGVfbmFtZV07XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNhbXBhaWduX2lkKSB7XG4gICAgICAgIHZhciBub3RpZl9lbCA9IHRoaXMuX2dldF9lbCgnb3ZlcmxheScpO1xuICAgICAgICBpZiAobm90aWZfZWwgJiYgZ2V0X3N0eWxlKG5vdGlmX2VsLCAndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJyAmJiBnZXRfc3R5bGUobm90aWZfZWwsICdkaXNwbGF5JykgIT09ICdub25lJykge1xuICAgICAgICAgICAgdGhpcy5fbWFya19kZWxpdmVyeSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fbWFya19kZWxpdmVyeSA9IF8uc2FmZXdyYXAoZnVuY3Rpb24oZXh0cmFfcHJvcHMpIHtcbiAgICBpZiAoIXRoaXMubWFya2VkX2FzX3Nob3duKSB7XG4gICAgICAgIHRoaXMubWFya2VkX2FzX3Nob3duID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jYW1wYWlnbl9pZCkge1xuICAgICAgICAgICAgLy8gbWFyayBub3RpZmljYXRpb24gc2hvd24gKGxvY2FsIGNhY2hlKVxuICAgICAgICAgICAgdGhpcy5fZ2V0X3Nob3duX2NhbXBhaWducygpW3RoaXMuY2FtcGFpZ25faWRdID0gMSAqIG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLnNhdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyYWNrIGRlbGl2ZXJ5XG4gICAgICAgIHRoaXMuX3RyYWNrX2V2ZW50KCckY2FtcGFpZ25fZGVsaXZlcnknLCBleHRyYV9wcm9wcyk7XG5cbiAgICAgICAgLy8gbWFyayBub3RpZmljYXRpb24gc2hvd24gKG1peHBhbmVsIHByb3BlcnR5KVxuICAgICAgICB0aGlzLm1peHBhbmVsWydwZW9wbGUnXVsnYXBwZW5kJ10oe1xuICAgICAgICAgICAgJyRjYW1wYWlnbnMnOiB0aGlzLmNhbXBhaWduX2lkLFxuICAgICAgICAgICAgJyRub3RpZmljYXRpb25zJzoge1xuICAgICAgICAgICAgICAgICdjYW1wYWlnbl9pZCc6IHRoaXMuY2FtcGFpZ25faWQsXG4gICAgICAgICAgICAgICAgJ21lc3NhZ2VfaWQnOiAgdGhpcy5tZXNzYWdlX2lkLFxuICAgICAgICAgICAgICAgICd0eXBlJzogICAgICAgICd3ZWInLFxuICAgICAgICAgICAgICAgICd0aW1lJzogICAgICAgIG5ldyBEYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fcHJlbG9hZF9pbWFnZXMgPSBmdW5jdGlvbihhbGxfbG9hZGVkX2NiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmltZ3NfdG9fcHJlbG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYWxsX2xvYWRlZF9jYigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZWxvYWRlZF9pbWdzID0gMDtcbiAgICB2YXIgaW1nX29ianMgPSBbXTtcbiAgICB2YXIgb25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZWxvYWRlZF9pbWdzKys7XG4gICAgICAgIGlmIChwcmVsb2FkZWRfaW1ncyA9PT0gc2VsZi5pbWdzX3RvX3ByZWxvYWQubGVuZ3RoICYmIGFsbF9sb2FkZWRfY2IpIHtcbiAgICAgICAgICAgIGFsbF9sb2FkZWRfY2IoKTtcbiAgICAgICAgICAgIGFsbF9sb2FkZWRfY2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW1nc190b19wcmVsb2FkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG9ubG9hZDtcbiAgICAgICAgaW1nLnNyYyA9IHRoaXMuaW1nc190b19wcmVsb2FkW2ldO1xuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBvbmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpbWdfb2Jqcy5wdXNoKGltZyk7XG4gICAgfVxuXG4gICAgLy8gSUU2LzcgZG9lc24ndCBmaXJlIG9ubG9hZCByZWxpYWJseVxuICAgIGlmICh0aGlzLl9icm93c2VyX2x0ZSgnaWUnLCA3KSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGltZ3NfbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbWdfb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghaW1nX29ianNbaV0uY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nc19sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1nc19sb2FkZWQgJiYgYWxsX2xvYWRlZF9jYikge1xuICAgICAgICAgICAgICAgIGFsbF9sb2FkZWRfY2IoKTtcbiAgICAgICAgICAgICAgICBhbGxfbG9hZGVkX2NiID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX3JlbW92ZV9ub3RpZmljYXRpb25fZWwgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX3ZpZGVvX3Byb2dyZXNzX2NoZWNrZXIpO1xuICAgIHRoaXMubm90aWZpY2F0aW9uX2VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB0aGlzLmJvZHlfZWwucmVtb3ZlQ2hpbGQodGhpcy5ub3RpZmljYXRpb25fZWwpO1xufSk7XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5fc2V0X2NsaWVudF9jb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2V0X2Jyb3dzZXJfdmVyc2lvbiA9IGZ1bmN0aW9uKGJyb3dzZXJfZXgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChicm93c2VyX2V4KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH07XG4gICAgdGhpcy5icm93c2VyX3ZlcnNpb25zID0ge307XG4gICAgdGhpcy5icm93c2VyX3ZlcnNpb25zWydjaHJvbWUnXSAgPSBnZXRfYnJvd3Nlcl92ZXJzaW9uKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICB0aGlzLmJyb3dzZXJfdmVyc2lvbnNbJ2ZpcmVmb3gnXSA9IGdldF9icm93c2VyX3ZlcnNpb24oL0ZpcmVmb3hcXC8oXFxkKykvKTtcbiAgICB0aGlzLmJyb3dzZXJfdmVyc2lvbnNbJ2llJ10gICAgICA9IGdldF9icm93c2VyX3ZlcnNpb24oL01TSUUgKFxcZCspLisvKTtcbiAgICBpZiAoIXRoaXMuYnJvd3Nlcl92ZXJzaW9uc1snaWUnXSAmJiAhKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSAmJiAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93KSB7XG4gICAgICAgIHRoaXMuYnJvd3Nlcl92ZXJzaW9uc1snaWUnXSA9IDExO1xuICAgIH1cblxuICAgIHRoaXMuYm9keV9lbCA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICBpZiAodGhpcy5ib2R5X2VsKSB7XG4gICAgICAgIHRoaXMuZG9jX3dpZHRoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzLmJvZHlfZWwuc2Nyb2xsV2lkdGgsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuYm9keV9lbC5vZmZzZXRXaWR0aCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgdGhpcy5ib2R5X2VsLmNsaWVudFdpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kb2NfaGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzLmJvZHlfZWwuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgdGhpcy5ib2R5X2VsLm9mZnNldEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHRoaXMuYm9keV9lbC5jbGllbnRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBkZXRlY3QgQ1NTIGNvbXBhdGliaWxpdHlcbiAgICB2YXIgaWVfdmVyID0gdGhpcy5icm93c2VyX3ZlcnNpb25zWydpZSddO1xuICAgIHZhciBzYW1wbGVfc3R5bGVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGUsXG4gICAgICAgIGlzX2Nzc19jb21wYXRpYmxlID0gZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgaW4gc2FtcGxlX3N0eWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpZV92ZXIpIHtcbiAgICAgICAgICAgICAgICBydWxlID0gcnVsZVswXS50b1VwcGVyQ2FzZSgpICsgcnVsZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBbJ08nICsgcnVsZSwgJ1dlYmtpdCcgKyBydWxlLCAnTW96JyArIHJ1bGVdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzW2ldIGluIHNhbXBsZV9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIHRoaXMudXNlX3RyYW5zaXRpb25zID0gdGhpcy5ib2R5X2VsICYmXG4gICAgICAgIGlzX2Nzc19jb21wYXRpYmxlKCd0cmFuc2l0aW9uJykgJiZcbiAgICAgICAgaXNfY3NzX2NvbXBhdGlibGUoJ3RyYW5zZm9ybScpO1xuICAgIHRoaXMuZmxpcF9hbmltYXRlID0gKHRoaXMuYnJvd3Nlcl92ZXJzaW9uc1snY2hyb21lJ10gPj0gMzMgfHwgdGhpcy5icm93c2VyX3ZlcnNpb25zWydmaXJlZm94J10gPj0gMTUpICYmXG4gICAgICAgIHRoaXMuYm9keV9lbCAmJlxuICAgICAgICBpc19jc3NfY29tcGF0aWJsZSgnYmFja2ZhY2VWaXNpYmlsaXR5JykgJiZcbiAgICAgICAgaXNfY3NzX2NvbXBhdGlibGUoJ3BlcnNwZWN0aXZlJykgJiZcbiAgICAgICAgaXNfY3NzX2NvbXBhdGlibGUoJ3RyYW5zZm9ybScpO1xufTtcblxuTWl4cGFuZWxOb3RpZmljYXRpb24ucHJvdG90eXBlLl9zd2l0Y2hfdG9fdmlkZW8gPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYW5pbXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWw6ICAgIHNlbGYuX2dldF9ub3RpZmljYXRpb25fZGlzcGxheV9lbCgpLFxuICAgICAgICAgICAgICAgIGF0dHI6ICAnb3BhY2l0eScsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDEuMCxcbiAgICAgICAgICAgICAgICBnb2FsOiAgMC4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsOiAgICBzZWxmLl9nZXRfbm90aWZpY2F0aW9uX2Rpc3BsYXlfZWwoKSxcbiAgICAgICAgICAgICAgICBhdHRyOiAgJ3RvcCcsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1peHBhbmVsTm90aWZpY2F0aW9uLk5PVElGX1RPUCxcbiAgICAgICAgICAgICAgICBnb2FsOiAgLTUwMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbDogICAgc2VsZi5fZ2V0X2VsKCd2aWRlby1ub2ZsaXAnKSxcbiAgICAgICAgICAgICAgICBhdHRyOiAgJ29wYWNpdHknLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLjAsXG4gICAgICAgICAgICAgICAgZ29hbDogIDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbDogICAgc2VsZi5fZ2V0X2VsKCd2aWRlby1ub2ZsaXAnKSxcbiAgICAgICAgICAgICAgICBhdHRyOiAgJ3RvcCcsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IC1zZWxmLnZpZGVvX2hlaWdodCAqIDIsXG4gICAgICAgICAgICAgICAgZ29hbDogIDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgIGlmIChzZWxmLm1pbmkpIHtcbiAgICAgICAgdmFyIGJnID0gc2VsZi5fZ2V0X2VsKCdiZycpLFxuICAgICAgICAgICAgb3ZlcmxheSA9IHNlbGYuX2dldF9lbCgnb3ZlcmxheScpO1xuICAgICAgICBiZy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgYmcuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBvdmVybGF5LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG4gICAgICAgIHNlbGYuX2FkZF9jbGFzcyhzZWxmLl9nZXRfbm90aWZpY2F0aW9uX2Rpc3BsYXlfZWwoKSwgJ2V4aXRpbmcnKTtcbiAgICAgICAgc2VsZi5fYWRkX2NsYXNzKGJnLCAndmlzaWJsZScpO1xuXG4gICAgICAgIGFuaW1zLnB1c2goe1xuICAgICAgICAgICAgZWw6ICAgIHNlbGYuX2dldF9lbCgnYmcnKSxcbiAgICAgICAgICAgIGF0dHI6ICAnb3BhY2l0eScsXG4gICAgICAgICAgICBzdGFydDogMC4wLFxuICAgICAgICAgICAgZ29hbDogIE1peHBhbmVsTm90aWZpY2F0aW9uLkJHX09QQUNJVFlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvX2VsID0gc2VsZi5fZ2V0X2VsKCd2aWRlby1ob2xkZXInKTtcbiAgICB2aWRlb19lbC5pbm5lckhUTUwgPSBzZWxmLnZpZGVvX2lmcmFtZTtcblxuICAgIHZhciB2aWRlb19yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93WydZVCddICYmIHdpbmRvd1snWVQnXVsnbG9hZGVkJ10pIHtcbiAgICAgICAgICAgIHNlbGYuX3l0X3ZpZGVvX3JlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zaG93aW5nX3ZpZGVvID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fZ2V0X25vdGlmaWNhdGlvbl9kaXNwbGF5X2VsKCkuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH07XG4gICAgaWYgKHNlbGYuZmxpcF9hbmltYXRlKSB7XG4gICAgICAgIHNlbGYuX2FkZF9jbGFzcygnZmxpcHBlcicsICdmbGlwcGVkJyk7XG4gICAgICAgIHNldFRpbWVvdXQodmlkZW9fcmVhZHksIE1peHBhbmVsTm90aWZpY2F0aW9uLkFOSU1fVElNRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fYW5pbWF0ZV9lbHMoYW5pbXMsIE1peHBhbmVsTm90aWZpY2F0aW9uLkFOSU1fVElNRSwgdmlkZW9fcmVhZHkpO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuX3RyYWNrX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgY2IpIHtcbiAgICBpZiAodGhpcy5jYW1wYWlnbl9pZCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdjYW1wYWlnbl9pZCc6ICAgICB0aGlzLmNhbXBhaWduX2lkLFxuICAgICAgICAgICAgJ21lc3NhZ2VfaWQnOiAgICAgIHRoaXMubWVzc2FnZV9pZCxcbiAgICAgICAgICAgICdtZXNzYWdlX3R5cGUnOiAgICAnd2ViX2luYXBwJyxcbiAgICAgICAgICAgICdtZXNzYWdlX3N1YnR5cGUnOiB0aGlzLm5vdGlmX3R5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWl4cGFuZWxbJ3RyYWNrJ10oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgY2IpO1xuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgY2IuY2FsbCgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTm90aWZpY2F0aW9uLnByb3RvdHlwZS5feXRfdmlkZW9fcmVhZHkgPSBfLnNhZmV3cmFwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi52aWRlb19pbml0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnZpZGVvX2luaXRlZCA9IHRydWU7XG5cbiAgICB2YXIgcHJvZ3Jlc3NfYmFyICA9IHNlbGYuX2dldF9lbCgndmlkZW8tZWxhcHNlZCcpLFxuICAgICAgICBwcm9ncmVzc190aW1lID0gc2VsZi5fZ2V0X2VsKCd2aWRlby10aW1lJyksXG4gICAgICAgIHByb2dyZXNzX2VsICAgPSBzZWxmLl9nZXRfZWwoJ3ZpZGVvLXByb2dyZXNzJyk7XG5cbiAgICBuZXcgd2luZG93WydZVCddWydQbGF5ZXInXShNaXhwYW5lbE5vdGlmaWNhdGlvbi5NQVJLVVBfUFJFRklYICsgJy12aWRlby1mcmFtZScsIHtcbiAgICAgICAgJ2V2ZW50cyc6IHtcbiAgICAgICAgICAgICdvblJlYWR5JzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeXRwbGF5ZXIgPSBldmVudFsndGFyZ2V0J10sXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvX2R1cmF0aW9uID0geXRwbGF5ZXJbJ2dldER1cmF0aW9uJ10oKSxcbiAgICAgICAgICAgICAgICAgICAgcGFkID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnMDAnICsgaSkuc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVfdmlkZW9fdGltZSA9IGZ1bmN0aW9uKGN1cnJlbnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY3MgPSBNYXRoLnJvdW5kKHZpZGVvX2R1cmF0aW9uIC0gY3VycmVudF90aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5zID0gTWF0aC5mbG9vcihzZWNzIC8gNjApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5mbG9vcihtaW5zIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VjcyAtPSBtaW5zICogNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5zIC09IGhvdXJzICogNjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc190aW1lLmlubmVySFRNTCA9ICctJyArIChob3VycyA/IGhvdXJzICsgJzonIDogJycpICsgcGFkKG1pbnMpICsgJzonICsgcGFkKHNlY3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHVwZGF0ZV92aWRlb190aW1lKDApO1xuICAgICAgICAgICAgICAgIHNlbGYuX3ZpZGVvX3Byb2dyZXNzX2NoZWNrZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X3RpbWUgPSB5dHBsYXllclsnZ2V0Q3VycmVudFRpbWUnXSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc19iYXIuc3R5bGUud2lkdGggPSAoY3VycmVudF90aW1lIC8gdmlkZW9fZHVyYXRpb24gKiAxMDApICsgJyUnO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVfdmlkZW9fdGltZShjdXJyZW50X3RpbWUpO1xuICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICAgICAgXy5yZWdpc3Rlcl9ldmVudChwcm9ncmVzc19lbCwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpY2t4ID0gTWF0aC5tYXgoMCwgZS5wYWdlWCAtIHByb2dyZXNzX2VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB5dHBsYXllclsnc2Vla1RvJ10odmlkZW9fZHVyYXRpb24gKiBjbGlja3ggLyBwcm9ncmVzc19lbC5jbGllbnRXaWR0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlb3BsZSBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxQZW9wbGUgPSBmdW5jdGlvbigpIHt9O1xuXG5fLmV4dGVuZChNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUsIGFwaUFjdGlvbnMpO1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG59O1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KCdnZW5kZXInLCAnbScpO1xuKlxuKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldCh7XG4qICAgICAgICAgJ0NvbXBhbnknOiAnQWNtZScsXG4qICAgICAgICAgJ1BsYW4nOiAnUHJlbWl1bScsXG4qICAgICAgICAgJ1VwZ3JhZGUgZGF0ZSc6IG5ldyBEYXRlKClcbiogICAgIH0pO1xuKiAgICAgLy8gcHJvcGVydGllcyBjYW4gYmUgc3RyaW5ncywgaW50ZWdlcnMsIGRhdGVzLCBvciBsaXN0c1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSByZWZlcnJlciBpbmZvIGhhcyBiZWVuIHVwZGF0ZWQgYW5kIHNhdmVkXG4gICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3NhdmVfcmVmZXJyZXInKSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudC5yZWZlcnJlcik7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlICRzZXQgb2JqZWN0IHdpdGggZGVmYXVsdCBwZW9wbGUgcHJvcGVydGllc1xuICAgIGRhdGFbU0VUX0FDVElPTl0gPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wZW9wbGVfcHJvcGVydGllcygpLFxuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5nZXRfcmVmZXJyZXJfaW5mbygpLFxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBTZXQgcHJvcGVydGllcyBvbiBhIHVzZXIgcmVjb3JkLCBvbmx5IGlmIHRoZXkgZG8gbm90IHlldCBleGlzdC5cbiogVGhpcyB3aWxsIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgcGVvcGxlIHByb3BlcnR5IHZhbHVlcywgdW5saWtlXG4qIHBlb3BsZS5zZXQoKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnNldF9vbmNlKCdGaXJzdCBMb2dpbiBEYXRlJywgbmV3IERhdGUoKSk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2Uoe1xuKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKSxcbiogICAgICAgICAnU3RhcnRpbmcgUGxhbic6ICdQcmVtaXVtJ1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycyBvciBkYXRlc1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdG9dIEEgdmFsdWUgdG8gc2V0IG9uIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBVbnNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQgKHBlcm1hbmVudGx5IHJlbW92ZXMgdGhlIHByb3BlcnRpZXMgYW5kIHRoZWlyIHZhbHVlcyBmcm9tIGEgcHJvZmlsZSkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldCgnZ2VuZGVyJyk7XG4qXG4qICAgICAvLyBvciB1bnNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bnNldChbJ2dlbmRlcicsICdDb21wYW55J10pO1xuKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIGFycmF5LCB0aGlzIGlzIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuc2V0X2FjdGlvbihwcm9wKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBJbmNyZW1lbnQvZGVjcmVtZW50IG51bWVyaWMgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0aWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJywgMSk7XG4qXG4qICAgICAvLyBvciwgZm9yIGNvbnZlbmllbmNlLCBpZiB5b3UncmUganVzdCBpbmNyZW1lbnRpbmcgYSBjb3VudGVyIGJ5XG4qICAgICAvLyAxLCB5b3UgY2FuIHNpbXBseSBkb1xuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncGFnZV92aWV3cycpO1xuKlxuKiAgICAgLy8gdG8gZGVjcmVtZW50IGEgY291bnRlciwgcGFzcyBhIG5lZ2F0aXZlIG51bWJlclxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgnY3JlZGl0c19sZWZ0JywgLTEpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gaW5jcmVtZW50IG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KHtcbiogICAgICAgICBjb3VudGVyMTogMSxcbiogICAgICAgICBjb3VudGVyMjogNlxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgbnVtZXJpYyB2YWx1ZXMuXG4qIEBwYXJhbSB7TnVtYmVyfSBbYnldIEFuIGFtb3VudCB0byBpbmNyZW1lbnQgdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgYnksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgJGFkZCA9IHt9O1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIF8uZWFjaChwcm9wLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzX3Jlc2VydmVkX3Byb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgaW5jcmVtZW50IHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50IC0gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGFkZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgPSBieTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb252ZW5pZW5jZTogbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgncHJvcGVydHknKTsgd2lsbFxuICAgICAgICAvLyBpbmNyZW1lbnQgJ3Byb3BlcnR5JyBieSAxXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGJ5KSkge1xuICAgICAgICAgICAgYnkgPSAxO1xuICAgICAgICB9XG4gICAgICAgICRhZGRbcHJvcF0gPSBieTtcbiAgICB9XG4gICAgZGF0YVtBRERfQUNUSU9OXSA9ICRhZGQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBBcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIGFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKCdwYWdlc192aXNpdGVkJywgJ2hvbWVwYWdlJyk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIHZhbHVlIEFuIGl0ZW0gdG8gYXBwZW5kIHRvIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5hcHBlbmRfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFJlbW92ZSBhIHZhbHVlIGZyb20gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUucmVtb3ZlKCdTY2hvb2wnLCAnVUNCJyk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBJdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWU7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5yZW1vdmVfYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIE1lcmdlIGEgZ2l2ZW4gbGlzdCB3aXRoIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eSxcbiogZXhjbHVkaW5nIGR1cGxpY2F0ZSB2YWx1ZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiogICAgIG1peHBhbmVsLnBlb3BsZS51bmlvbigncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiogICAgICAgICBsaXN0MjogMTIzXG4qICAgICB9KTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gdmFsdWVzIHRvIHRoZSBzYW1lIGxpc3Q6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oe1xuKiAgICAgICAgIGxpc3QxOiBbJ2JvYicsICdiaWxseSddXG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsaXN0X25hbWUgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiogQHBhcmFtIHsqfSBbdmFsdWVdIFZhbHVlIC8gdmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4qL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihsaXN0X25hbWUsIHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMudW5pb25fYWN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBSZWNvcmQgdGhhdCB5b3UgaGF2ZSBjaGFyZ2VkIHRoZSBjdXJyZW50IHVzZXIgYSBjZXJ0YWluIGFtb3VudFxuKiBvZiBtb25leS4gQ2hhcmdlcyByZWNvcmRlZCB3aXRoIHRyYWNrX2NoYXJnZSgpIHdpbGwgYXBwZWFyIGluIHRoZVxuKiBNaXhwYW5lbCByZXZlbnVlIHJlcG9ydC5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkNTBcbiogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoNTApO1xuKlxuKiAgICAgLy8gY2hhcmdlIGEgdXNlciAkMzAuNTAgb24gdGhlIDJuZCBvZiBqYW51YXJ5XG4qICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDMwLjUwLCB7XG4qICAgICAgICAgJyR0aW1lJzogbmV3IERhdGUoJ2phbiAxIDIwMTInKVxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiBtb25leSBjaGFyZ2VkIHRvIHRoZSBjdXJyZW50IHVzZXJcbiogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hhcmdlXG4qIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHNcbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihhbW91bnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKGFtb3VudCkpIHtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdChhbW91bnQpO1xuICAgICAgICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGVuZCgnJHRyYW5zYWN0aW9ucycsIF8uZXh0ZW5kKHtcbiAgICAgICAgJyRhbW91bnQnOiBhbW91bnRcbiAgICB9LCBwcm9wZXJ0aWVzKSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFBlcm1hbmVudGx5IGNsZWFyIGFsbCByZXZlbnVlIHJlcG9ydCB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcbiogY3VycmVudCB1c2VyJ3MgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuY2xlYXJfY2hhcmdlcygpO1xuKlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5jbGVhcl9jaGFyZ2VzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoJyR0cmFuc2FjdGlvbnMnLCBbXSwgY2FsbGJhY2spO1xufTtcblxuLypcbiogUGVybWFuZW50bHkgZGVsZXRlcyB0aGUgY3VycmVudCBwZW9wbGUgYW5hbHl0aWNzIHByb2ZpbGUgZnJvbVxuKiBNaXhwYW5lbCAodXNpbmcgdGhlIGN1cnJlbnQgZGlzdGluY3RfaWQpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyByZW1vdmUgdGhlIGFsbCBkYXRhIHlvdSBoYXZlIHN0b3JlZCBhYm91dCB0aGUgY3VycmVudCB1c2VyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKTtcbipcbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuZGVsZXRlX3VzZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ21peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpIHJlcXVpcmVzIHlvdSB0byBjYWxsIGlkZW50aWZ5KCkgZmlyc3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHsnJGRlbGV0ZSc6IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpfTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLnRvU3RyaW5nKCkgKyAnLnBlb3BsZSc7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuICAgIGRhdGFbJyRkaXN0aW5jdF9pZCddID0gdGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgdmFyIGRldmljZV9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpO1xuICAgIHZhciB1c2VyX2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckdXNlcl9pZCcpO1xuICAgIHZhciBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCcpO1xuICAgIGlmIChkZXZpY2VfaWQpIHtcbiAgICAgICAgZGF0YVsnJGRldmljZV9pZCddID0gZGV2aWNlX2lkO1xuICAgIH1cbiAgICBpZiAodXNlcl9pZCkge1xuICAgICAgICBkYXRhWyckdXNlcl9pZCddID0gdXNlcl9pZDtcbiAgICB9XG4gICAgaWYgKGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgZGF0YVsnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnXSA9IGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcblxuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldF9jb25maWcoJ3ZlcmJvc2UnKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtzdGF0dXM6IC0xLCBlcnJvcjogbnVsbH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8udHJ1bmNhdGUoZGF0ZV9lbmNvZGVkX2RhdGEsIDI1NSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdwZW9wbGUnLFxuICAgICAgICBkYXRhOiBkYXRlX2VuY29kZWRfZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuX2dldF9jb25maWcoJ2FwaV9ob3N0JykgKyAnL2VuZ2FnZS8nLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLnBlb3BsZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZfdmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZl92YXIpO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pZGVudGlmeV9jYWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9PT0gdHJ1ZTtcbn07XG5cbi8vIFF1ZXVlIHVwIGVuZ2FnZSBvcGVyYXRpb25zIGlmIGlkZW50aWZ5IGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2VucXVldWUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKFNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShTRVRfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFNFVF9PTkNFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTlNFVF9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQUREX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFERF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoQVBQRU5EX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoUkVNT1ZFX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoVU5JT05fQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gX2VucXVldWUoKTonLCBkYXRhKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoX29uZV9xdWV1ZSA9IGZ1bmN0aW9uKGFjdGlvbiwgYWN0aW9uX21ldGhvZCwgY2FsbGJhY2ssIHF1ZXVlX3RvX3BhcmFtc19mbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHF1ZXVlZF9kYXRhID0gXy5leHRlbmQoe30sIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9nZXRfcXVldWUoYWN0aW9uKSk7XG4gICAgdmFyIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZWRfZGF0YTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChxdWV1ZWRfZGF0YSkgJiYgXy5pc09iamVjdChxdWV1ZWRfZGF0YSkgJiYgIV8uaXNFbXB0eU9iamVjdChxdWV1ZWRfZGF0YSkpIHtcbiAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgIGlmIChxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICAgICAgICAgIGFjdGlvbl9wYXJhbXMgPSBxdWV1ZV90b19wYXJhbXNfZm4ocXVldWVkX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbl9tZXRob2QuY2FsbChfdGhpcywgYWN0aW9uX3BhcmFtcywgZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG9uIGJhZCByZXNwb25zZSwgd2Ugd2FudCB0byBhZGQgaXQgYmFjayB0byB0aGUgcXVldWVcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShhY3Rpb24sIHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8vIEZsdXNoIHF1ZXVlZCBlbmdhZ2Ugb3BlcmF0aW9ucyAtIG9yZGVyIGRvZXMgbm90IG1hdHRlcixcbi8vIGFuZCB0aGVyZSBhcmUgbmV0d29yayBsZXZlbCByYWNlIGNvbmRpdGlvbnMgYW55d2F5XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oXG4gICAgX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFja1xuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgJGFwcGVuZF9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9nZXRfcXVldWUoQVBQRU5EX0FDVElPTik7XG4gICAgdmFyICRyZW1vdmVfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fZ2V0X3F1ZXVlKFJFTU9WRV9BQ1RJT04pO1xuXG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFNFVF9BQ1RJT04sIHRoaXMuc2V0LCBfc2V0X2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCB0aGlzLnNldF9vbmNlLCBfc2V0X29uY2VfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHRoaXMudW5zZXQsIF91bnNldF9jYWxsYmFjaywgZnVuY3Rpb24ocXVldWUpIHsgcmV0dXJuIF8ua2V5cyhxdWV1ZSk7IH0pO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShBRERfQUNUSU9OLCB0aGlzLmluY3JlbWVudCwgX2FkZF9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOSU9OX0FDVElPTiwgdGhpcy51bmlvbiwgX3VuaW9uX2NhbGxiYWNrKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gZmlyZSBvZmYgZWFjaCAkYXBwZW5kIGluZGl2aWR1YWxseSBzaW5jZSB0aGVyZSBpc1xuICAgIC8vIG5vIGNvbmNhdCBtZXRob2Qgc2VydmVyIHNpZGVcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJGFwcGVuZF9xdWV1ZSkgJiYgXy5pc0FycmF5KCRhcHBlbmRfcXVldWUpICYmICRhcHBlbmRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkYXBwZW5kX2l0ZW07XG4gICAgICAgIHZhciBhcHBlbmRfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sICRhcHBlbmRfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX2FwcGVuZF9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfYXBwZW5kX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9ICRhcHBlbmRfcXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICRhcHBlbmRfaXRlbSA9ICRhcHBlbmRfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkYXBwZW5kX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwZW5kKCRhcHBlbmRfaXRlbSwgYXBwZW5kX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTYXZlIHRoZSBzaG9ydGVuZWQgYXBwZW5kIHF1ZXVlXG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgfVxuXG4gICAgLy8gc2FtZSBmb3IgJHJlbW92ZVxuICAgIGlmICghXy5pc1VuZGVmaW5lZCgkcmVtb3ZlX3F1ZXVlKSAmJiBfLmlzQXJyYXkoJHJlbW92ZV9xdWV1ZSkgJiYgJHJlbW92ZV9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRyZW1vdmVfaXRlbTtcbiAgICAgICAgdmFyIHJlbW92ZV9jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgJHJlbW92ZV9pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfcmVtb3ZlX2NhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVfY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBqID0gJHJlbW92ZV9xdWV1ZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgJHJlbW92ZV9pdGVtID0gJHJlbW92ZV9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIGlmICghXy5pc0VtcHR5T2JqZWN0KCRyZW1vdmVfaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUoJHJlbW92ZV9pdGVtLCByZW1vdmVfY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRkaXN0aW5jdF9pZCcgfHwgcHJvcCA9PT0gJyR0b2tlbicgfHwgcHJvcCA9PT0gJyRkZXZpY2VfaWQnIHx8IHByb3AgPT09ICckdXNlcl9pZCcgfHwgcHJvcCA9PT0gJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJztcbn07XG5cbi8vIE1peHBhbmVsUGVvcGxlIEV4cG9ydHNcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0J10gICAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnc2V0X29uY2UnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd1bnNldCddICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2luY3JlbWVudCddICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5pbmNyZW1lbnQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2FwcGVuZCddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQ7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3JlbW92ZSddICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmU7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3VuaW9uJ10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndHJhY2tfY2hhcmdlJ10gID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRyYWNrX2NoYXJnZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnY2xlYXJfY2hhcmdlcyddID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXM7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ2RlbGV0ZV91c2VyJ10gICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlcjtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndG9TdHJpbmcnXSAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKlxuICogTWl4cGFuZWwgSlMgTGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBNaXhwYW5lbCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiBodHRwOi8vbWl4cGFuZWwuY29tL1xuICpcbiAqIEluY2x1ZGVzIHBvcnRpb25zIG9mIFVuZGVyc2NvcmUuanNcbiAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAqIChjKSAyMDExIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIEFEVkFOQ0VEX09QVElNSVpBVElPTlNcbi8vIEBvdXRwdXRfZmlsZV9uYW1lIG1peHBhbmVsLTIuOC5taW4uanNcbi8vID09L0Nsb3N1cmVDb21waWxlcj09XG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG52YXIgbWl4cGFuZWxfbWFzdGVyOyAvLyBtYWluIG1peHBhbmVsIGluc3RhbmNlIC8gb2JqZWN0XG52YXIgSU5JVF9NT0RVTEUgID0gMDtcbnZhciBJTklUX1NOSVBQRVQgPSAxO1xuXG52YXIgSURFTlRJVFlfRlVOQyA9IGZ1bmN0aW9uKHgpIHtyZXR1cm4geDt9O1xudmFyIE5PT1BfRlVOQyA9IGZ1bmN0aW9uKCkge307XG5cbi8qKiBAY29uc3QgKi8gdmFyIFBSSU1BUllfSU5TVEFOQ0VfTkFNRSA9ICdtaXhwYW5lbCc7XG5cblxuLypcbiAqIER5bmFtaWMuLi4gY29uc3RhbnRzPyBJcyB0aGF0IGFuIG94eW1vcm9uP1xuICovXG4vLyBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3dpdGhDcmVkZW50aWFsc1xudmFyIFVTRV9YSFIgPSAod2luZG93JDEuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpO1xuXG4vLyBJRTwxMCBkb2VzIG5vdCBzdXBwb3J0IGNyb3NzLW9yaWdpbiBYSFIncyBidXQgc2NyaXB0IHRhZ3Ncbi8vIHdpdGggZGVmZXIgd29uJ3QgYmxvY2sgd2luZG93Lm9ubG9hZDsgRU5RVUVVRV9SRVFVRVNUU1xuLy8gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgT3BlcmE8MTJcbnZhciBFTlFVRVVFX1JFUVVFU1RTID0gIVVTRV9YSFIgJiYgKHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgPT09IC0xKSAmJiAodXNlckFnZW50LmluZGV4T2YoJ01vemlsbGEnKSA9PT0gLTEpO1xuXG4vLyBzYXZlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBzbyBpdCBjYW4gYmUgbWluaWZpZWRcbnZhciBzZW5kQmVhY29uID0gbnVsbDtcbmlmIChuYXZpZ2F0b3IkMVsnc2VuZEJlYWNvbiddKSB7XG4gICAgc2VuZEJlYWNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsYXRlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiB0byBhbGxvdyBwYXRjaGluZy9zcHlpbmdcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvciQxWydzZW5kQmVhY29uJ10uYXBwbHkobmF2aWdhdG9yJDEsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLypcbiAqIE1vZHVsZS1sZXZlbCBnbG9iYWxzXG4gKi9cbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICAnYXBpX2hvc3QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLWpzLm1peHBhbmVsLmNvbScsXG4gICAgJ2FwaV9tZXRob2QnOiAgICAgICAgICAgICAgICAgICAgICAgICdQT1NUJyxcbiAgICAnYXBpX3RyYW5zcG9ydCc6ICAgICAgICAgICAgICAgICAgICAgJ1hIUicsXG4gICAgJ2FwcF9ob3N0JzogICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL21peHBhbmVsLmNvbScsXG4gICAgJ2Nkbic6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20nLFxuICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6ICAgICAgICAgICAgdHJ1ZSxcbiAgICAncGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgICAgICAgICAgJ2Nvb2tpZScsXG4gICAgJ3BlcnNpc3RlbmNlX25hbWUnOiAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfZG9tYWluJzogICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX25hbWUnOiAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2xvYWRlZCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5PT1BfRlVOQyxcbiAgICAnc3RvcmVfZ29vZ2xlJzogICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnc2F2ZV9yZWZlcnJlcic6ICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAndGVzdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3ZlcmJvc2UnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpbWcnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGVidWcnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3RyYWNrX2xpbmtzX3RpbWVvdXQnOiAgICAgICAgICAgICAgIDMwMCxcbiAgICAnY29va2llX2V4cGlyYXRpb24nOiAgICAgICAgICAgICAgICAgMzY1LFxuICAgICd1cGdyYWRlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9wZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfY29va2llJzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzZWN1cmVfY29va2llJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaXAnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0JzogICAgICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCc6ICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnOiAnbG9jYWxTdG9yYWdlJyxcbiAgICAnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4JzogICAgbnVsbCxcbiAgICAncHJvcGVydHlfYmxhY2tsaXN0JzogICAgICAgICAgICAgICAgW10sXG4gICAgJ3hocl9oZWFkZXJzJzogICAgICAgICAgICAgICAgICAgICAgIHt9LCAvLyB7IGhlYWRlcjogdmFsdWUsIGhlYWRlcjI6IHZhbHVlIH1cbiAgICAnaW5hcHBfcHJvdG9jb2wnOiAgICAgICAgICAgICAgICAgICAgJy8vJyxcbiAgICAnaW5hcHBfbGlua19uZXdfd2luZG93JzogICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lnbm9yZV9kbnQnOiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdiYXRjaF9yZXF1ZXN0cyc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSwgLy8gZm9yIG5vd1xuICAgICdiYXRjaF9zaXplJzogICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAgICAgICAgICAgNTAwMCxcbiAgICAnYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJzogICAgICAgICAgOTAwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6ICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2hvb2tzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9XG59O1xuXG52YXIgRE9NX0xPQURFRCA9IGZhbHNlO1xuXG4vKipcbiAqIE1peHBhbmVsIExpYnJhcnkgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsTGliID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIGNyZWF0ZV9tcGxpYih0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgaW5pdCBtZXRob2Qgb2YgTWl4cGFuZWxMaWIgb2JqZWN0c1xuICogYXMgd2VsbCBhcyB0aGUgbWFpbiBpbml0aWFsaXplciBhdCB0aGUgZW5kIG9mIHRoZSBKU0xpYiAodGhhdFxuICogaW5pdGlhbGl6ZXMgZG9jdW1lbnQubWl4cGFuZWwgYXMgd2VsbCBhcyBhbnkgYWRkaXRpb25hbCBpbnN0YW5jZXNcbiAqIGRlY2xhcmVkIGJlZm9yZSB0aGlzIGZpbGUgaGFzIGxvYWRlZCkuXG4gKi9cbnZhciBjcmVhdGVfbXBsaWIgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIGluc3RhbmNlLFxuICAgICAgICB0YXJnZXQgPSAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG1peHBhbmVsX21hc3RlciA6IG1peHBhbmVsX21hc3RlcltuYW1lXTtcblxuICAgIGlmICh0YXJnZXQgJiYgaW5pdF90eXBlID09PSBJTklUX01PRFVMRSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICFfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBpbml0aWFsaXplZCAnICsgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgTWl4cGFuZWxMaWIoKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5fY2FjaGVkX2dyb3VwcyA9IHt9OyAvLyBjYWNoZSBncm91cHMgaW4gYSBwb29sXG4gICAgaW5zdGFuY2UuX3VzZXJfZGVjaWRlX2NoZWNrX2NvbXBsZXRlID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuX2V2ZW50c190cmFja2VkX2JlZm9yZV91c2VyX2RlY2lkZV9jaGVja19jb21wbGV0ZSA9IFtdO1xuXG4gICAgaW5zdGFuY2UuX2luaXQodG9rZW4sIGNvbmZpZywgbmFtZSk7XG5cbiAgICBpbnN0YW5jZVsncGVvcGxlJ10gPSBuZXcgTWl4cGFuZWxQZW9wbGUoKTtcbiAgICBpbnN0YW5jZVsncGVvcGxlJ10uX2luaXQoaW5zdGFuY2UpO1xuXG4gICAgLy8gaWYgYW55IGluc3RhbmNlIG9uIHRoZSBwYWdlIGhhcyBkZWJ1ZyA9IHRydWUsIHdlIHNldCB0aGVcbiAgICAvLyBnbG9iYWwgZGVidWcgdG8gYmUgdHJ1ZVxuICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCBpbnN0YW5jZS5nZXRfY29uZmlnKCdkZWJ1ZycpO1xuXG4gICAgLy8gaWYgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkLCB3ZSBjYWxsZWQgaW5pdCBhZnRlciB0aGUgbGliIGFscmVhZHlcbiAgICAvLyBsb2FkZWQsIHNvIHRoZXJlIHdvbid0IGJlIGFuIGFycmF5IG9mIHRoaW5ncyB0byBleGVjdXRlXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRhcmdldCkgJiYgXy5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgLy8gQ3J1bmNoIHRocm91Z2ggdGhlIHBlb3BsZSBxdWV1ZSBmaXJzdCAtIHdlIHF1ZXVlIHRoaXMgZGF0YSB1cCAmXG4gICAgICAgIC8vIGZsdXNoIG9uIGlkZW50aWZ5LCBzbyBpdCdzIGJldHRlciB0byBkbyBhbGwgdGhlc2Ugb3BlcmF0aW9ucyBmaXJzdFxuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheS5jYWxsKGluc3RhbmNlWydwZW9wbGUnXSwgdGFyZ2V0WydwZW9wbGUnXSk7XG4gICAgICAgIGluc3RhbmNlLl9leGVjdXRlX2FycmF5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xufTtcblxudmFyIGVuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBqc29uX2RhdGEgPSBfLkpTT05FbmNvZGUoZGF0YSk7XG4gICAgdmFyIGVuY29kZWRfZGF0YSA9IF8uYmFzZTY0RW5jb2RlKGpzb25fZGF0YSk7XG4gICAgcmV0dXJuIHsnZGF0YSc6IGVuY29kZWRfZGF0YX07XG59O1xuXG4vLyBJbml0aWFsaXphdGlvbiBtZXRob2RzXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWl4cGFuZWwgdHJhY2tpbmcgb2JqZWN0LlxuICogQWxsIG5ldyBpbnN0YW5jZXMgYXJlIGFkZGVkIHRvIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCBhcyBzdWIgcHJvcGVydGllcyAoc3VjaCBhc1xuICogbWl4cGFuZWwubGlicmFyeV9uYW1lKSBhbmQgYWxzbyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBkZWZpbmUgYVxuICogc2Vjb25kIGluc3RhbmNlIG9uIHRoZSBwYWdlLCB5b3Ugd291bGQgY2FsbDpcbiAqXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnbmV3IHRva2VuJywgeyB5b3VyOiAnY29uZmlnJyB9LCAnbGlicmFyeV9uYW1lJyk7XG4gKlxuICogYW5kIHVzZSBpdCBsaWtlIHNvOlxuICpcbiAqICAgICBtaXhwYW5lbC5saWJyYXJ5X25hbWUudHJhY2soLi4uKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gICBZb3VyIE1peHBhbmVsIEFQSSB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddICBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGUuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vbWl4cGFuZWwvbWl4cGFuZWwtanMvYmxvYi84YjJlMWY3Yi9zcmMvbWl4cGFuZWwtY29yZS5qcyNMODctTDExMFwiPlNlZSBhIGxpc3Qgb2YgZGVmYXVsdCBjb25maWcgb3B0aW9uczwvYT4uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdICAgIFRoZSBuYW1lIGZvciB0aGUgbmV3IG1peHBhbmVsIGluc3RhbmNlIHRoYXQgeW91IHdhbnQgY3JlYXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignWW91IG11c3QgbmFtZSB5b3VyIG5ldyBsaWJyYXJ5OiBpbml0KHRva2VuLCBjb25maWcsIG5hbWUpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgbXVzdCBpbml0aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCByaWdodCBhZnRlciB5b3UgaW5jbHVkZSB0aGUgTWl4cGFuZWwganMgc25pcHBldCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIG1peHBhbmVsLl9pbml0KHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtaXhwYW5lbFxuLy8gbGlicmFyeS4gIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIHRoZSBpbml0KC4uLilcbi8vIG1ldGhvZCBpcyB0aGlzIG9uZSBpbml0aWFsaXplcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB3aGVyZWFzIHRoZVxuLy8gaW5pdCguLi4pIG1ldGhvZCBzZXRzIHVwIGEgbmV3IGxpYnJhcnkgYW5kIGNhbGxzIF9pbml0IG9uIGl0LlxuLy9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICB0aGlzWydfX2xvYWRlZCddID0gdHJ1ZTtcbiAgICB0aGlzWydjb25maWcnXSA9IHt9O1xuICAgIHRoaXNbJ190cmlnZ2VyZWRfbm90aWZzJ10gPSBbXTtcblxuICAgIC8vIHJvbGxvdXQ6IGVuYWJsZSBiYXRjaF9yZXF1ZXN0cyBieSBkZWZhdWx0IGZvciA2MCUgb2YgcHJvamVjdHNcbiAgICAvLyAob25seSBpZiB0aGV5IGhhdmUgbm90IHNwZWNpZmllZCBhIHZhbHVlIGluIHRoZWlyIGluaXQgY29uZmlnXG4gICAgLy8gYW5kIHRoZXkgYXJlbid0IHVzaW5nIGEgY3VzdG9tIEFQSSBob3N0KVxuICAgIHZhciB2YXJpYWJsZV9mZWF0dXJlcyA9IHt9O1xuICAgIHZhciBhcGlfaG9zdCA9IGNvbmZpZ1snYXBpX2hvc3QnXTtcbiAgICB2YXIgaXNfY3VzdG9tX2FwaSA9ICEhYXBpX2hvc3QgJiYgIWFwaV9ob3N0Lm1hdGNoKC9cXC5taXhwYW5lbFxcLmNvbSQvKTtcbiAgICBpZiAoISgnYmF0Y2hfcmVxdWVzdHMnIGluIGNvbmZpZykgJiYgIWlzX2N1c3RvbV9hcGkgJiYgZGV0ZXJtaW5lX2VsaWdpYmlsaXR5KHRva2VuLCAnYmF0Y2gnLCA2MCkpIHtcbiAgICAgICAgdmFyaWFibGVfZmVhdHVyZXNbJ2JhdGNoX3JlcXVlc3RzJ10gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0X2NvbmZpZyhfLmV4dGVuZCh7fSwgREVGQVVMVF9DT05GSUcsIHZhcmlhYmxlX2ZlYXR1cmVzLCBjb25maWcsIHtcbiAgICAgICAgJ25hbWUnOiBuYW1lLFxuICAgICAgICAndG9rZW4nOiB0b2tlbixcbiAgICAgICAgJ2NhbGxiYWNrX2ZuJzogKChuYW1lID09PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpID8gbmFtZSA6IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSArICcuJyArIG5hbWUpICsgJy5fanNjJ1xuICAgIH0pKTtcblxuICAgIHRoaXNbJ19qc2MnXSA9IE5PT1BfRlVOQztcblxuICAgIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlID0gW107XG4gICAgdGhpcy5fX3JlcXVlc3RfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gW107XG4gICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICdkaXNhYmxlX2FsbF9ldmVudHMnOiBmYWxzZSxcbiAgICAgICAgJ2lkZW50aWZ5X2NhbGxlZCc6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCByZXF1ZXN0IHF1ZXVlaW5nL2JhdGNoaW5nXG4gICAgdGhpcy5yZXF1ZXN0X2JhdGNoZXJzID0ge307XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0aGlzLmdldF9jb25maWcoJ2JhdGNoX3JlcXVlc3RzJyk7XG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzKSB7XG4gICAgICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKHRydWUpIHx8ICFVU0VfWEhSKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1R1cm5pbmcgb2ZmIE1peHBhbmVsIHJlcXVlc3QtcXVldWVpbmc7IG5lZWRzIFhIUiBhbmQgbG9jYWxTdG9yYWdlIHN1cHBvcnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdF9iYXRjaGVycygpO1xuICAgICAgICAgICAgaWYgKHNlbmRCZWFjb24gJiYgd2luZG93JDEuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdyQxLmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVmb3JlIHBhZ2UgY2xvc2VzLCBhdHRlbXB0IHRvIGZsdXNoIGFueSBldmVudHMgcXVldWVkIHVwIHZpYSBuYXZpZ2F0b3Iuc2VuZEJlYWNvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugc2VuZEJlYWNvbiBkb2Vzbid0IHJlcG9ydCBzdWNjZXNzL2ZhaWx1cmUsIGV2ZW50cyB3aWxsIG5vdCBiZSByZW1vdmVkIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBlcnNpc3RlbnQgc3RvcmU7IGlmIHRoZSBzaXRlIGlzIGxvYWRlZCBhZ2FpbiwgdGhlIGV2ZW50cyB3aWxsIGJlIGZsdXNoZWQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gb24gc3RhcnR1cCBhbmQgZGVkdXBsaWNhdGVkIG9uIHRoZSBNaXhwYW5lbCBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMuZmx1c2goe3VubG9hZGluZzogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXSA9IHRoaXNbJ2Nvb2tpZSddID0gbmV3IE1peHBhbmVsUGVyc2lzdGVuY2UodGhpc1snY29uZmlnJ10pO1xuICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyA9IHt9O1xuICAgIHRoaXMuX2dkcHJfaW5pdCgpO1xuXG4gICAgdmFyIHV1aWQgPSBfLlVVSUQoKTtcbiAgICBpZiAoIXRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCkpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBzZXQgdGhlIGRpc3RpbmN0IGlkXG4gICAgICAgIC8vIG9yIHRoZSBkZXZpY2UgaWQgaWYgc29tZXRoaW5nIHdhcyBhbHJlYWR5IHN0b3JlZFxuICAgICAgICAvLyBpbiB0aGUgcGVyc2l0ZW5jZVxuICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uoe1xuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogdXVpZCxcbiAgICAgICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxufTtcblxuLy8gUHJpdmF0ZSBtZXRob2RzXG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRfY29uZmlnKCdsb2FkZWQnKSh0aGlzKTtcbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG59O1xuXG4vLyB1cGRhdGUgcGVyc2lzdGVuY2Ugd2l0aCBpbmZvIG9uIHJlZmVycmVyLCBVVE0gcGFyYW1zLCBldGNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3NlYXJjaF9rZXl3b3JkKGRvY3VtZW50JDEucmVmZXJyZXIpO1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ3N0b3JlX2dvb2dsZScpKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX2NhbXBhaWduX3BhcmFtcygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdzYXZlX3JlZmVycmVyJykpIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfcmVmZXJyZXJfaW5mbyhkb2N1bWVudCQxLnJlZmVycmVyKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2RvbV9sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICBfLmVhY2godGhpcy5fX2RvbV9sb2FkZWRfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fdHJhY2tfZG9tLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICBfLmVhY2godGhpcy5fX3JlcXVlc3RfcXVldWUsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRfcmVxdWVzdC5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlO1xuICAgIGRlbGV0ZSB0aGlzLl9fcmVxdWVzdF9xdWV1ZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfZG9tID0gZnVuY3Rpb24oRG9tQ2xhc3MsIGFyZ3MpIHtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgY2FuXFwndCB1c2UgRE9NIHRyYWNraW5nIGZ1bmN0aW9ucyB3aXRoIGltZyA9IHRydWUuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIURPTV9MT0FERUQpIHtcbiAgICAgICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUucHVzaChbRG9tQ2xhc3MsIGFyZ3NdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkdCA9IG5ldyBEb21DbGFzcygpLmluaXQodGhpcyk7XG4gICAgcmV0dXJuIGR0LnRyYWNrLmFwcGx5KGR0LCBhcmdzKTtcbn07XG5cbi8qKlxuICogX3ByZXBhcmVfY2FsbGJhY2soKSBzaG91bGQgYmUgY2FsbGVkIGJ5IGNhbGxlcnMgb2YgX3NlbmRfcmVxdWVzdCBmb3IgdXNlXG4gKiBhcyB0aGUgY2FsbGJhY2sgYXJndW1lbnQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gY2FsbGJhY2ssIHRoaXMgcmV0dXJucyBudWxsLlxuICogSWYgd2UgYXJlIGdvaW5nIHRvIG1ha2UgWEhSL1hEUiByZXF1ZXN0cywgdGhpcyByZXR1cm5zIGEgZnVuY3Rpb24uXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gdXNlIHNjcmlwdCB0YWdzLCB0aGlzIHJldHVybnMgYSBzdHJpbmcgdG8gdXNlIGFzIHRoZVxuICogY2FsbGJhY2sgR0VUIHBhcmFtLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3ByZXBhcmVfY2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgZGF0YSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoVVNFX1hIUikge1xuICAgICAgICB2YXIgY2FsbGJhY2tfZnVuY3Rpb24gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfZnVuY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZ2l2ZXMgdXMgYSBjYWxsYmFjaywgd2Ugc3RvcmUgYXMgYSByYW5kb21cbiAgICAgICAgLy8gcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZXMganNjIGZ1bmN0aW9uIGFuZCB1cGRhdGUgb3VyXG4gICAgICAgIC8vIGNhbGxiYWNrIHN0cmluZyB0byByZWZsZWN0IHRoYXQuXG4gICAgICAgIHZhciBqc2MgPSB0aGlzWydfanNjJ107XG4gICAgICAgIHZhciByYW5kb21pemVkX2NiID0gJycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xuICAgICAgICB2YXIgY2FsbGJhY2tfc3RyaW5nID0gdGhpcy5nZXRfY29uZmlnKCdjYWxsYmFja19mbicpICsgJ1snICsgcmFuZG9taXplZF9jYiArICddJztcbiAgICAgICAganNjW3JhbmRvbWl6ZWRfY2JdID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBqc2NbcmFuZG9taXplZF9jYl07XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdHJpbmc7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgICBpZiAoRU5RVUVVRV9SRVFVRVNUUykge1xuICAgICAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgfVxuXG4gICAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldF9jb25maWcoJ2FwaV9tZXRob2QnKSxcbiAgICAgICAgdHJhbnNwb3J0OiB0aGlzLmdldF9jb25maWcoJ2FwaV90cmFuc3BvcnQnKSxcbiAgICAgICAgdmVyYm9zZTogdGhpcy5nZXRfY29uZmlnKCd2ZXJib3NlJylcbiAgICB9O1xuICAgIHZhciBib2R5X2RhdGEgPSBudWxsO1xuXG4gICAgaWYgKCFjYWxsYmFjayAmJiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnMpIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKCFVU0VfWEhSKSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgfVxuICAgIHZhciB1c2VfcG9zdCA9IG9wdGlvbnMubWV0aG9kID09PSAnUE9TVCc7XG4gICAgdmFyIHVzZV9zZW5kQmVhY29uID0gc2VuZEJlYWNvbiAmJiB1c2VfcG9zdCAmJiBvcHRpb25zLnRyYW5zcG9ydC50b0xvd2VyQ2FzZSgpID09PSAnc2VuZGJlYWNvbic7XG5cbiAgICAvLyBuZWVkZWQgdG8gY29ycmVjdGx5IGZvcm1hdCByZXNwb25zZXNcbiAgICB2YXIgdmVyYm9zZV9tb2RlID0gb3B0aW9ucy52ZXJib3NlO1xuICAgIGlmIChkYXRhWyd2ZXJib3NlJ10pIHsgdmVyYm9zZV9tb2RlID0gdHJ1ZTsgfVxuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7IGRhdGFbJ3Rlc3QnXSA9IDE7IH1cbiAgICBpZiAodmVyYm9zZV9tb2RlKSB7IGRhdGFbJ3ZlcmJvc2UnXSA9IDE7IH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdpbWcnKSkgeyBkYXRhWydpbWcnXSA9IDE7IH1cbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBkYXRhWydjYWxsYmFjayddID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyYm9zZV9tb2RlIHx8IHRoaXMuZ2V0X2NvbmZpZygndGVzdCcpKSB7XG4gICAgICAgICAgICAvLyBWZXJib3NlIG91dHB1dCAoZnJvbSB2ZXJib3NlIG1vZGUsIG9yIGFuIGVycm9yIGluIHRlc3QgbW9kZSkgaXMgYSBqc29uIGJsb2IsXG4gICAgICAgICAgICAvLyB3aGljaCBieSBpdHNlbGYgaXMgbm90IHZhbGlkIGphdmFzY3JpcHQuIFdpdGhvdXQgYSBjYWxsYmFjaywgdGhpcyB2ZXJib3NlIG91dHB1dCB3aWxsXG4gICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciB3aGVuIHJldHVybmVkIHZpYSBqc29ucCwgc28gd2UgZm9yY2UgYSBuby1vcCBjYWxsYmFjayBwYXJhbS5cbiAgICAgICAgICAgIC8vIFNlZSB0aGUgRUNNQSBzY3JpcHQgc3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTEyLjRcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSAnKGZ1bmN0aW9uKCl7fSknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF0YVsnaXAnXSA9IHRoaXMuZ2V0X2NvbmZpZygnaXAnKT8xOjA7XG4gICAgZGF0YVsnXyddID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoKTtcblxuICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICBib2R5X2RhdGEgPSAnZGF0YT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFbJ2RhdGEnXSk7XG4gICAgICAgIGRlbGV0ZSBkYXRhWydkYXRhJ107XG4gICAgfVxuXG4gICAgdXJsICs9ICc/JyArIF8uSFRUUEJ1aWxkUXVlcnkoZGF0YSk7XG5cbiAgICBpZiAoJ2ltZycgaW4gZGF0YSkge1xuICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgZG9jdW1lbnQkMS5ib2R5LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSBlbHNlIGlmICh1c2Vfc2VuZEJlYWNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gc2VuZEJlYWNvbih1cmwsIGJvZHlfZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc3VjY2VlZGVkID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldF9jb25maWcoJ3hocl9oZWFkZXJzJyk7XG4gICAgICAgICAgICBpZiAodXNlX3Bvc3QpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXy5lYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlclZhbHVlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXRfbXMgJiYgdHlwZW9mIHJlcS50aW1lb3V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0X21zO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydF90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1wX29wdG91dCBjb29raWVcbiAgICAgICAgICAgIC8vIHdpdGhDcmVkZW50aWFscyBjYW5ub3QgYmUgbW9kaWZpZWQgdW50aWwgYWZ0ZXIgY2FsbGluZyAub3BlbiBvbiBBbmRyb2lkIGFuZCBNb2JpbGUgU2FmYXJpXG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7IC8vIFhNTEh0dHBSZXF1ZXN0LkRPTkUgPT0gNCwgZXhjZXB0IGluIHNhZmFyaSA0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlX21vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfLkpTT05EZWNvZGUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVfanNvbl9lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soTnVtYmVyKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcmVxLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZSA+PSByZXEudGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAndGltZW91dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ0JhZCBIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnICcgKyByZXEuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAwLCBlcnJvcjogZXJyb3IsIHhocl9yZXE6IHJlcX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZChib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG4vKipcbiAqIF9leGVjdXRlX2FycmF5KCkgZGVhbHMgd2l0aCBwcm9jZXNzaW5nIGFueSBtaXhwYW5lbCBmdW5jdGlvblxuICogY2FsbHMgdGhhdCB3ZXJlIGNhbGxlZCBiZWZvcmUgdGhlIE1peHBhbmVsIGxpYnJhcnkgd2VyZSBsb2FkZWRcbiAqIChhbmQgYXJlIHRodXMgc3RvcmVkIGluIGFuIGFycmF5IHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBsYXRlcilcbiAqXG4gKiBOb3RlOiB3ZSBmaXJlIG9mZiBhbGwgdGhlIG1peHBhbmVsIGZ1bmN0aW9uIGNhbGxzICYmIHVzZXIgZGVmaW5lZFxuICogZnVuY3Rpb25zIEJFRk9SRSB3ZSBmaXJlIG9mZiBtaXhwYW5lbCB0cmFja2luZyBjYWxscy4gVGhpcyBpcyBzb1xuICogaWRlbnRpZnkvcmVnaXN0ZXIvc2V0X2NvbmZpZyBjYWxscyBjYW4gcHJvcGVybHkgbW9kaWZ5IGVhcmx5XG4gKiB0cmFja2luZyBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V4ZWN1dGVfYXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBmbl9uYW1lLCBhbGlhc19jYWxscyA9IFtdLCBvdGhlcl9jYWxscyA9IFtdLCB0cmFja2luZ19jYWxscyA9IFtdO1xuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm5fbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZuX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTsgLy8gY2hhaW5lZCBjYWxsIGUuZy4gbWl4cGFuZWwuZ2V0X2dyb3VwKCkuc2V0KClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGl0ZW0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgICAgIGFsaWFzX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xICYmIHR5cGVvZih0aGlzW2ZuX25hbWVdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBleGVjdXRlID0gZnVuY3Rpb24oY2FsbHMsIGNvbnRleHQpIHtcbiAgICAgICAgXy5lYWNoKGNhbGxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGl0ZW1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCBjYWxsXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uKGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gY2FsbGVyW2NhbGxbMF1dLmFwcGx5KGNhbGxlciwgY2FsbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaXRlbVswXV0uYXBwbHkodGhpcywgaXRlbS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBleGVjdXRlKGFsaWFzX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKG90aGVyX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKHRyYWNraW5nX2NhbGxzLCB0aGlzKTtcbn07XG5cbi8vIHJlcXVlc3QgcXVldWVpbmcgdXRpbHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaW5pdF9iYXRjaGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICBpZiAoIXRoaXMuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgdmFyIGJhdGNoZXJfZm9yID0gXy5iaW5kKGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3RCYXRjaGVyKFxuICAgICAgICAgICAgICAgICdfX21wcV8nICsgdG9rZW4gKyBhdHRycy5xdWV1ZV9zdWZmaXgsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaWJDb25maWc6IHRoaXNbJ2NvbmZpZyddLFxuICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZChmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArIGF0dHJzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYiwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kSG9vazogXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIGF0dHJzLnR5cGUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKHt0eXBlOiAnZXZlbnRzJywgZW5kcG9pbnQ6ICcvdHJhY2svJywgcXVldWVfc3VmZml4OiAnX2V2J30pLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2Zvcih7dHlwZTogJ3Blb3BsZScsIGVuZHBvaW50OiAnL2VuZ2FnZS8nLCBxdWV1ZV9zdWZmaXg6ICdfcHAnfSksXG4gICAgICAgICAgICBncm91cHM6IGJhdGNoZXJfZm9yKHt0eXBlOiAnZ3JvdXBzJywgZW5kcG9pbnQ6ICcvZ3JvdXBzLycsIHF1ZXVlX3N1ZmZpeDogJ19ncid9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdiYXRjaF9hdXRvc3RhcnQnKSkge1xuICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG4vLyBpbnRlcm5hbCBtZXRob2QgZm9yIGhhbmRsaW5nIHRyYWNrIHZzIGJhdGNoLWVucXVldWUgbG9naWNcbk1peHBhbmVsTGliLnByb3RvdHlwZS5fdHJhY2tfb3JfYmF0Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0cnVuY2F0ZWRfZGF0YSA9IF8udHJ1bmNhdGUob3B0aW9ucy5kYXRhLCAyNTUpO1xuICAgIHZhciBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnQ7XG4gICAgdmFyIGJhdGNoZXIgPSBvcHRpb25zLmJhdGNoZXI7XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9ucy5zaG91bGRfc2VuZF9pbW1lZGlhdGVseTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X29wdGlvbnMgPSBvcHRpb25zLnNlbmRfcmVxdWVzdF9vcHRpb25zIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgTk9PUF9GVU5DO1xuXG4gICAgdmFyIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5ID0gXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbmRfcmVxdWVzdF9vcHRpb25zLnNraXBfaG9va3MpIHtcbiAgICAgICAgICAgIHRydW5jYXRlZF9kYXRhID0gdGhpcy5fcnVuX2hvb2soJ2JlZm9yZV9zZW5kXycgKyBvcHRpb25zLnR5cGUsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1bmNhdGVkX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICBlbmNvZGVfZGF0YV9mb3JfcmVxdWVzdCh0cnVuY2F0ZWRfZGF0YSksXG4gICAgICAgICAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYWxsYmFjaywgdHJ1bmNhdGVkX2RhdGEpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICh0aGlzLl9iYXRjaF9yZXF1ZXN0cyAmJiAhc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgYmF0Y2hlci5lbnF1ZXVlKHRydW5jYXRlZF9kYXRhLCBmdW5jdGlvbihzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygxLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCAmJiB0cnVuY2F0ZWRfZGF0YTtcbn07XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQuIFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGFuZFxuICogZnJlcXVlbnRseSB1c2VkIE1peHBhbmVsIGZ1bmN0aW9uLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ1JlZ2lzdGVyZWQnLCB7J0dlbmRlcic6ICdNYWxlJywgJ0FnZSc6IDIxfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IHVzaW5nIG5hdmlnYXRvci5zZW5kQmVhY29uXG4gKiAgICAgbWl4cGFuZWwudHJhY2soJ0xlZnQgcGFnZScsIHsnZHVyYXRpb25fc2Vjb25kcyc6IDM1fSwge3RyYW5zcG9ydDogJ3NlbmRCZWFjb24nfSk7XG4gKlxuICogVG8gdHJhY2sgbGluayBjbGlja3Mgb3IgZm9ybSBzdWJtaXNzaW9ucywgc2VlIHRyYWNrX2xpbmtzKCkgb3IgdHJhY2tfZm9ybXMoKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHRyYWNrIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNwb3J0XSBUcmFuc3BvcnQgbWV0aG9kIGZvciBuZXR3b3JrIHJlcXVlc3QgKCd4aHInIG9yICdzZW5kQmVhY29uJykuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlbmRfaW1tZWRpYXRlbHldIFdoZXRoZXIgdG8gYnlwYXNzIGJhdGNoaW5nL3F1ZXVlaW5nIGFuZCBzZW5kIHRyYWNrIHJlcXVlc3QgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFjayA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0cmFuc3BvcnQgPSBvcHRpb25zWyd0cmFuc3BvcnQnXTsgLy8gZXh0ZXJuYWwgQVBJLCBkb24ndCBtaW5pZnkgJ3RyYW5zcG9ydCcgcHJvcFxuICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7IC8vICd0cmFuc3BvcnQnIHByb3AgbmFtZSBjYW4gYmUgbWluaWZpZWQgaW50ZXJuYWxseVxuICAgIH1cbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zWydzZW5kX2ltbWVkaWF0ZWx5J107XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IE5PT1BfRlVOQztcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRyYWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRfaXNfZGlzYWJsZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgICBwcm9wZXJ0aWVzWyd0b2tlbiddID0gdGhpcy5nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgLy8gc2V0ICRkdXJhdGlvbiBpZiB0aW1lX2V2ZW50IHdhcyBwcmV2aW91c2x5IGNhbGxlZCBmb3IgdGhpcyBldmVudFxuICAgIHZhciBzdGFydF90aW1lc3RhbXAgPSB0aGlzWydwZXJzaXN0ZW5jZSddLnJlbW92ZV9ldmVudF90aW1lcihldmVudF9uYW1lKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhcnRfdGltZXN0YW1wKSkge1xuICAgICAgICB2YXIgZHVyYXRpb25faW5fbXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0X3RpbWVzdGFtcDtcbiAgICAgICAgcHJvcGVydGllc1snJGR1cmF0aW9uJ10gPSBwYXJzZUZsb2F0KChkdXJhdGlvbl9pbl9tcyAvIDEwMDApLnRvRml4ZWQoMykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldF9kZWZhdWx0X3N1cGVycHJvcHMoKTtcblxuICAgIC8vIG5vdGU6IGV4dGVuZCB3cml0ZXMgdG8gdGhlIGZpcnN0IG9iamVjdCwgc28gbGV0cyBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCB3cml0ZSB0byB0aGUgcGVyc2lzdGVuY2UgcHJvcGVydGllcyBvYmplY3QgYW5kIGluZm9cbiAgICAvLyBwcm9wZXJ0aWVzIG9iamVjdCBieSBwYXNzaW5nIGluIGEgbmV3IG9iamVjdFxuXG4gICAgLy8gdXBkYXRlIHByb3BlcnRpZXMgd2l0aCBwYWdldmlldyBpbmZvIGFuZCBzdXBlci1wcm9wZXJ0aWVzXG4gICAgcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnByb3BlcnRpZXMoKSxcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5wcm9wZXJ0aWVzKCksXG4gICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICB2YXIgcHJvcGVydHlfYmxhY2tsaXN0ID0gdGhpcy5nZXRfY29uZmlnKCdwcm9wZXJ0eV9ibGFja2xpc3QnKTtcbiAgICBpZiAoXy5pc0FycmF5KHByb3BlcnR5X2JsYWNrbGlzdCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3BlcnR5X2JsYWNrbGlzdCwgZnVuY3Rpb24oYmxhY2tsaXN0ZWRfcHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbYmxhY2tsaXN0ZWRfcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3BlcnR5X2JsYWNrbGlzdCBjb25maWc6ICcgKyBwcm9wZXJ0eV9ibGFja2xpc3QpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAnZXZlbnQnOiBldmVudF9uYW1lLFxuICAgICAgICAncHJvcGVydGllcyc6IHByb3BlcnRpZXNcbiAgICB9O1xuICAgIHZhciByZXQgPSB0aGlzLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdldmVudHMnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy90cmFjay8nLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLFxuICAgICAgICBzaG91bGRfc2VuZF9pbW1lZGlhdGVseTogc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHksXG4gICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zOiBvcHRpb25zXG4gICAgfSwgY2FsbGJhY2spO1xuXG4gICAgdGhpcy5fY2hlY2tfYW5kX2hhbmRsZV90cmlnZ2VyZWRfbm90aWZpY2F0aW9ucyhkYXRhKTtcblxuICAgIHJldHVybiByZXQ7XG59KTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY3VycmVudCB1c2VyIGludG8gb25lL21hbnkgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIFsnbWl4cGFuZWwnLCAnZ29vZ2xlJ10pIC8vIGFuIGFycmF5IG9mIElEc1xuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCAxMjg3NDYzMTIpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bWJlcn0gZ3JvdXBfaWRzIEFuIGFycmF5IG9mIGdyb3VwIElEcywgb3IgYSBzaW5ndWxhciBncm91cCBJRFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KGdyb3VwX2lkcykpIHtcbiAgICAgICAgZ3JvdXBfaWRzID0gW2dyb3VwX2lkc107XG4gICAgfVxuICAgIHZhciBwcm9wID0ge307XG4gICAgcHJvcFtncm91cF9rZXldID0gZ3JvdXBfaWRzO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnNldChncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogQWRkIGEgbmV3IGdyb3VwIGZvciB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuYWRkX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZXMgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIGlmIChvbGRfdmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHByb3AgPSB7fTtcbiAgICAgICAgcHJvcFtncm91cF9rZXldID0gW2dyb3VwX2lkXTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2xkX3ZhbHVlcy5pbmRleE9mKGdyb3VwX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZXMucHVzaChncm91cF9pZCk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS51bmlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBncm91cCBmcm9tIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5yZW1vdmVfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICAvLyBpZiB0aGUgdmFsdWUgZG9lc24ndCBleGlzdCwgdGhlIHBlcnNpc3RlbnQgc3RvcmUgaXMgdW5jaGFuZ2VkXG4gICAgaWYgKG9sZF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpZHggPSBvbGRfdmFsdWUuaW5kZXhPZihncm91cF9pZCk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgb2xkX3ZhbHVlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcih7Z3JvdXBfa2V5OiBvbGRfdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkX3ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGdyb3VwX2tleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnJlbW92ZShncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudCB3aXRoIHNwZWNpZmljIGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC50cmFja193aXRoX2dyb3VwcygncHVyY2hhc2UnLCB7J3Byb2R1Y3QnOiAnaXBob25lJ30sIHsnVW5pdmVyc2l0eSc6IFsnVUNCJywgJ1VDTEEnXX0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZyAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gZ3JvdXBzIEFuIG9iamVjdCBtYXBwaW5nIGdyb3VwIG5hbWUga2V5cyB0byBvbmUgb3IgbW9yZSB2YWx1ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3VwcyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZXZlbnRfbmFtZSwgcHJvcGVydGllcywgZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIHZhciB0cmFja2luZ19wcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICBfLmVhY2goZ3JvdXBzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICh2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2tpbmdfcHJvcHNba10gPSB2O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgdHJhY2tpbmdfcHJvcHMsIGNhbGxiYWNrKTtcbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NyZWF0ZV9tYXBfa2V5ID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICByZXR1cm4gZ3JvdXBfa2V5ICsgJ18nICsgSlNPTi5zdHJpbmdpZnkoZ3JvdXBfaWQpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZW1vdmVfZ3JvdXBfZnJvbV9jYWNoZSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZF9ncm91cHNbdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCldO1xufTtcblxuLyoqXG4gKiBMb29rIHVwIHJlZmVyZW5jZSB0byBhIE1peHBhbmVsIGdyb3VwXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgIG1peHBhbmVsLmdldF9ncm91cChncm91cF9rZXksIGdyb3VwX2lkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIE1peHBhbmVsR3JvdXAgaWRlbnRpZmllclxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2dyb3VwID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICB2YXIgbWFwX2tleSA9IHRoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgIHZhciBncm91cCA9IHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV07XG4gICAgaWYgKGdyb3VwID09PSB1bmRlZmluZWQgfHwgZ3JvdXAuX2dyb3VwX2tleSAhPT0gZ3JvdXBfa2V5IHx8IGdyb3VwLl9ncm91cF9pZCAhPT0gZ3JvdXBfaWQpIHtcbiAgICAgICAgZ3JvdXAgPSBuZXcgTWl4cGFuZWxHcm91cCgpO1xuICAgICAgICBncm91cC5faW5pdCh0aGlzLCBncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqIFRyYWNrIG1wX3BhZ2VfdmlldyBldmVudC4gVGhpcyBpcyBub3cgaWdub3JlZCBieSB0aGUgc2VydmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFnZV0gVGhlIHVybCBvZiB0aGUgcGFnZSB0byByZWNvcmQuIElmIHlvdSBkb24ndCBpbmNsdWRlIHRoaXMsIGl0IGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHVybC5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYWdlKSkge1xuICAgICAgICBwYWdlID0gZG9jdW1lbnQkMS5sb2NhdGlvbi5ocmVmO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrKCdtcF9wYWdlX3ZpZXcnLCBfLmluZm8ucGFnZXZpZXdJbmZvKHBhZ2UpKTtcbn07XG5cbi8qKlxuICogVHJhY2sgY2xpY2tzIG9uIGEgc2V0IG9mIGRvY3VtZW50IGVsZW1lbnRzLiBTZWxlY3RvciBtdXN0IGJlIGFcbiAqIHZhbGlkIHF1ZXJ5LiBFbGVtZW50cyBtdXN0IGV4aXN0IG9uIHRoZSBwYWdlIGF0IHRoZSB0aW1lIHRyYWNrX2xpbmtzIGlzIGNhbGxlZC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGNsaWNrIGZvciBsaW5rIGlkICNuYXZcbiAqICAgICBtaXhwYW5lbC50cmFja19saW5rcygnI25hdicsICdDbGlja2VkIE5hdiBMaW5rJyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIE1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQuIElmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBBIHByb3BlcnRpZXMgb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgcHJvcGVydGllcyB3aGVuIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIExpbmtUcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUcmFjayBmb3JtIHN1Ym1pc3Npb25zLiBTZWxlY3RvciBtdXN0IGJlIGEgdmFsaWQgcXVlcnkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBzdWJtaXNzaW9uIGZvciBmb3JtIGlkICdyZWdpc3RlcidcbiAqICAgICBtaXhwYW5lbC50cmFja19mb3JtcygnI3JlZ2lzdGVyJywgJ0NyZWF0ZWQgQWNjb3VudCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBtaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLCBpZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gVGhpcyBjYW4gYmUgYSBzZXQgb2YgcHJvcGVydGllcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgcHJvcGVydGllcyBhZnRlciBiZWluZyBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3JtcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBGb3JtVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVGltZSBhbiBldmVudCBieSBpbmNsdWRpbmcgdGhlIHRpbWUgYmV0d2VlbiB0aGlzIGNhbGwgYW5kIGFcbiAqIGxhdGVyICd0cmFjaycgY2FsbCBmb3IgdGhlIHNhbWUgZXZlbnQgaW4gdGhlIHByb3BlcnRpZXMgc2VudFxuICogd2l0aCB0aGUgZXZlbnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0aW1lIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRpbWVfZXZlbnQoJ1JlZ2lzdGVyZWQnKTtcbiAqICAgICBtaXhwYW5lbC50cmFjaygnUmVnaXN0ZXJlZCcsIHsnR2VuZGVyJzogJ01hbGUnLCAnQWdlJzogMjF9KTtcbiAqXG4gKiBXaGVuIGNhbGxlZCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIHRoZSBuZXh0IHRyYWNrIGNhbGwgZm9yIHRoYXQgZXZlbnRcbiAqIG5hbWUgd2lsbCBpbmNsdWRlIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aGUgJ3RpbWVfZXZlbnQnIGFuZCAndHJhY2snXG4gKiBjYWxscy4gVGhpcyB2YWx1ZSBpcyBzdG9yZWQgYXMgc2Vjb25kcyBpbiB0aGUgJyRkdXJhdGlvbicgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRpbWVfZXZlbnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSwgIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbn07XG5cbnZhciBSRUdJU1RFUl9ERUZBVUxUUyA9IHtcbiAgICAncGVyc2lzdGVudCc6IHRydWVcbn07XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBvcHRpb25zIHBhcmFtIGZvciByZWdpc3RlciBtZXRob2RzLCBtYWludGFpbmluZ1xuICogbGVnYWN5IHN1cHBvcnQgZm9yIHBsYWluIFwiZGF5c1wiIHBhcmFtIGluc3RlYWQgb2Ygb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gJ2RheXMnIG9wdGlvbiAoTnVtYmVyKSwgb3IgT3B0aW9ucyBvYmplY3QgZm9yIHJlZ2lzdGVyIG1ldGhvZHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKi9cbnZhciBvcHRpb25zX2Zvcl9yZWdpc3RlciA9IGZ1bmN0aW9uKGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChfLmlzT2JqZWN0KGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRheXNfb3Jfb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsnZGF5cyc6IGRheXNfb3Jfb3B0aW9uc307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gXy5leHRlbmQoe30sIFJFR0lTVEVSX0RFRkFVTFRTLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcywgd2hpY2ggYXJlIGluY2x1ZGVkIHdpdGggYWxsXG4gKiBldmVudHMuIFRoaXMgd2lsbCBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgJ0dlbmRlcicgYXMgYSBzdXBlciBwcm9wZXJ0eVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnR2VuZGVyJzogJ0ZlbWFsZSd9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgc2V2ZXJhbCBzdXBlciBwcm9wZXJ0aWVzIHdoZW4gYSB1c2VyIHNpZ25zIHVwXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoe1xuICogICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbScsXG4gKiAgICAgICAgICdBY2NvdW50IFR5cGUnOiAnRnJlZSdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J05hbWUnOiAnUGF0J30sIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcihwcm9wcywgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsIHByb3BzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMgb25seSBvbmNlLiBUaGlzIHdpbGwgbm90XG4gKiBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2UgcmVnaXN0ZXIoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIGEgc3VwZXIgcHJvcGVydHkgZm9yIHRoZSBmaXJzdCB0aW1lIG9ubHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25jZSwgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IGludGVyYWN0aW9uIHRpbWUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9LCAnTm9uZScsIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiBkZWZhdWx0X3ZhbHVlIGlzIHNwZWNpZmllZCwgY3VycmVudCBzdXBlciBwcm9wZXJ0aWVzXG4gKiB3aXRoIHRoYXQgdmFsdWUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSBWYWx1ZSB0byBvdmVycmlkZSBpZiBhbHJlYWR5IHNldCBpbiBzdXBlciBwcm9wZXJ0aWVzIChleDogJ0ZhbHNlJykgRGVmYXVsdDogJ05vbmUnXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcl9vbmNlKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGEgc3VwZXIgcHJvcGVydHkgc3RvcmVkIHdpdGggdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBsb29rIGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udW5yZWdpc3Rlcihwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wZXJ0eV07XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZWdpc3Rlcl9zaW5nbGUgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHByb3BzW3Byb3BdID0gdmFsdWU7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wcyk7XG59O1xuXG4vKipcbiAqIElkZW50aWZ5IGEgdXNlciB3aXRoIGEgdW5pcXVlIElEIHRvIHRyYWNrIHVzZXIgYWN0aXZpdHkgYWNyb3NzXG4gKiBkZXZpY2VzLCB0aWUgYSB1c2VyIHRvIHRoZWlyIGV2ZW50cywgYW5kIGNyZWF0ZSBhIHVzZXIgcHJvZmlsZS5cbiAqIElmIHlvdSBuZXZlciBjYWxsIHRoaXMgbWV0aG9kLCB1bmlxdWUgdmlzaXRvcnMgYXJlIHRyYWNrZWQgdXNpbmdcbiAqIGEgVVVJRCBnZW5lcmF0ZWQgdGhlIGZpcnN0IHRpbWUgdGhleSB2aXNpdCB0aGUgc2l0ZS5cbiAqXG4gKiBDYWxsIGlkZW50aWZ5IHdoZW4geW91IGtub3cgdGhlIGlkZW50aXR5IG9mIHRoZSBjdXJyZW50IHVzZXIsXG4gKiB0eXBpY2FsbHkgYWZ0ZXIgbG9naW4gb3Igc2lnbnVwLiBXZSByZWNvbW1lbmQgYWdhaW5zdCB1c2luZ1xuICogaWRlbnRpZnkgZm9yIGFub255bW91cyB2aXNpdG9ycyB0byB5b3VyIHNpdGUuXG4gKlxuICogIyMjIE5vdGVzOlxuICogSWYgeW91ciBwcm9qZWN0IGhhc1xuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgaWRlbnRpZnkgbWV0aG9kIHdpbGwgY29ubmVjdCBwcmUtIGFuZFxuICogcG9zdC1hdXRoZW50aWNhdGlvbiBldmVudHMgd2hlbiBhcHByb3ByaWF0ZS5cbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZSBJRCBNZXJnZSBlbmFibGVkLCBpZGVudGlmeSB3aWxsXG4gKiBjaGFuZ2UgdGhlIHVzZXIncyBsb2NhbCBkaXN0aW5jdF9pZCB0byB0aGUgdW5pcXVlIElEIHlvdSBwYXNzLlxuICogRXZlbnRzIHRyYWNrZWQgcHJpb3IgdG8gYXV0aGVudGljYXRpb24gd2lsbCBub3QgYmUgY29ubmVjdGVkXG4gKiB0byB0aGUgc2FtZSB1c2VyIGlkZW50aXR5LiBJZiBJRCBNZXJnZSBpcyBkaXNhYmxlZCwgYWxpYXMgY2FuXG4gKiBiZSB1c2VkIHRvIGNvbm5lY3QgcHJlLSBhbmQgcG9zdC1yZWdpc3RyYXRpb24gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pcXVlX2lkXSBBIHN0cmluZyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSB1c2VyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkaXN0aW5jdF9pZCBjdXJyZW50bHkgaW4gdGhlIHBlcnNpc3RlbnQgc3RvcmUgKGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UpIHdpbGwgYmUgdXNlZC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24oXG4gICAgbmV3X2Rpc3RpbmN0X2lkLCBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgLy8gIF9zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0IHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FkZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhZGQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYXBwZW5kX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFwcGVuZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9zZXRfb25jZV9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXRfb25jZSBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bmlvbl9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bmlvbiBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bnNldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bnNldCBxdWV1ZSBpcyBmbHVzaGVkXG5cbiAgICB2YXIgcHJldmlvdXNfZGlzdGluY3RfaWQgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIHRoaXMucmVnaXN0ZXIoeyckdXNlcl9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuXG4gICAgaWYgKCF0aGlzLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpKSB7XG4gICAgICAgIC8vIFRoZSBwZXJzaXN0ZWQgZGlzdGluY3QgaWQgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgZGV2aWNlIGlkIGF0IGFsbFxuICAgICAgICAvLyBpdCBtaWdodCBiZSBhIGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyIGZyb20gYmVmb3JlXG4gICAgICAgIHZhciBkZXZpY2VfaWQgPSBwcmV2aW91c19kaXN0aW5jdF9pZDtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc6IHRydWUsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IGRldmljZV9pZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpZnkgb25seSBjaGFuZ2VzIHRoZSBkaXN0aW5jdCBpZCBpZiBpdCBkb2Vzbid0IG1hdGNoIGVpdGhlciB0aGUgZXhpc3Rpbmcgb3IgdGhlIGFsaWFzO1xuICAgIC8vIGlmIGl0J3MgbmV3LCBibG93IGF3YXkgdGhlIGFsaWFzIGFzIHdlbGwuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQgJiYgbmV3X2Rpc3RpbmN0X2lkICE9PSB0aGlzLmdldF9wcm9wZXJ0eShBTElBU19JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcihBTElBU19JRF9LRVkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG4gICAgdGhpcy5fY2hlY2tfYW5kX2hhbmRsZV9ub3RpZmljYXRpb25zKHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCkpO1xuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IHRydWU7XG4gICAgLy8gRmx1c2ggYW55IHF1ZXVlZCB1cCBwZW9wbGUgcmVxdWVzdHNcbiAgICB0aGlzWydwZW9wbGUnXS5fZmx1c2goX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFjayk7XG5cbiAgICAvLyBzZW5kIGFuICRpZGVudGlmeSBldmVudCBhbnkgdGltZSB0aGUgZGlzdGluY3RfaWQgaXMgY2hhbmdpbmcgLSBsb2dpYyBvbiB0aGUgc2VydmVyXG4gICAgLy8gd2lsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZG8gYW55dGhpbmcgd2l0aCBpdC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCkge1xuICAgICAgICB0aGlzLnRyYWNrKCckaWRlbnRpZnknLCB7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWQsXG4gICAgICAgICAgICAnJGFub25fZGlzdGluY3RfaWQnOiBwcmV2aW91c19kaXN0aW5jdF9pZFxuICAgICAgICB9LCB7c2tpcF9ob29rczogdHJ1ZX0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHN1cGVyIHByb3BlcnRpZXMgYW5kIGdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGlzdGluY3RfaWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gKiBVc2VmdWwgZm9yIGNsZWFyaW5nIGRhdGEgd2hlbiBhIHVzZXIgbG9ncyBvdXQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uY2xlYXIoKTtcbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICdkaXN0aW5jdF9pZCc6IHV1aWQsXG4gICAgICAgICckZGV2aWNlX2lkJzogdXVpZFxuICAgIH0sICcnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlci4gVGhpcyBpcyBlaXRoZXIgdGhlIGlkIGF1dG9tYXRpY2FsbHlcbiAqIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeSBvciB0aGUgaWQgdGhhdCBoYXMgYmVlbiBwYXNzZWQgYnkgYSBjYWxsIHRvIGlkZW50aWZ5KCkuXG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIGdldF9kaXN0aW5jdF9pZCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgTWl4cGFuZWwgbGlicmFyeSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqIGluaXQoKSBoYXMgYSBsb2FkZWQgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAvLyBzZXQgZGlzdGluY3RfaWQgYWZ0ZXIgdGhlIG1peHBhbmVsIGxpYnJhcnkgaGFzIGxvYWRlZFxuICogICAgIG1peHBhbmVsLmluaXQoJ1lPVVIgUFJPSkVDVCBUT0tFTicsIHtcbiAqICAgICAgICAgbG9hZGVkOiBmdW5jdGlvbihtaXhwYW5lbCkge1xuICogICAgICAgICAgICAgZGlzdGluY3RfaWQgPSBtaXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0X3Byb3BlcnR5KCdkaXN0aW5jdF9pZCcpO1xufTtcblxuLyoqXG4gKiBUaGUgYWxpYXMgbWV0aG9kIGNyZWF0ZXMgYW4gYWxpYXMgd2hpY2ggTWl4cGFuZWwgd2lsbCB1c2UgdG9cbiAqIHJlbWFwIG9uZSBpZCB0byBhbm90aGVyLiBNdWx0aXBsZSBhbGlhc2VzIGNhbiBwb2ludCB0byB0aGVcbiAqIHNhbWUgaWRlbnRpZmllci5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgdXNlIG9mIGFsaWFzOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gWW91IGNhbiBhZGQgbXVsdGlwbGUgaWQgYWxpYXNlcyB0byB0aGUgZXhpc3RpbmcgSURcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqXG4gKiBBbGlhc2VzIGNhbiBhbHNvIGJlIGNoYWluZWQgLSB0aGUgZm9sbG93aW5nIGlzIGEgdmFsaWQgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIGNoYWluIG5ld2VyX2lkIC0gbmV3X2lkIC0gZXhpc3RpbmdfaWRcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3ZXJfaWQnLCAnbmV3X2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW5ub3QgcG9pbnQgdG8gbXVsdGlwbGUgaWRlbnRpZmllcnMgLSB0aGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHdpbGwgbm90IHdvcms6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyB0aGlzIGlzIGludmFsaWQgYXMgJ25ld19pZCcgYWxyZWFkeSBwb2ludHMgdG8gJ2V4aXN0aW5nX2lkJ1xuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnbmV3ZXJfaWQnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmVcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gY2FsbCBhbGlhcyBvbmNlIHdoZW4gYSB1bmlxdWVcbiAqIElEIGlzIGZpcnN0IGNyZWF0ZWQgZm9yIGEgdXNlciAoZS5nLiwgd2hlbiBhIHVzZXIgZmlyc3QgcmVnaXN0ZXJzXG4gKiBmb3IgYW4gYWNjb3VudCkuIERvIG5vdCB1c2UgYWxpYXMgbXVsdGlwbGUgdGltZXMgZm9yIGEgc2luZ2xlXG4gKiB1c2VyIHdpdGhvdXQgSUQgTWVyZ2UgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWxpYXMgQSB1bmlxdWUgaWRlbnRpZmllciB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgdGhpcyB1c2VyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29yaWdpbmFsXSBUaGUgY3VycmVudCBpZGVudGlmaWVyIGJlaW5nIHVzZWQgZm9yIHRoaXMgdXNlci5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24oYWxpYXMsIG9yaWdpbmFsKSB7XG4gICAgLy8gSWYgdGhlICRwZW9wbGVfZGlzdGluY3RfaWQga2V5IGV4aXN0cyBpbiBwZXJzaXN0ZW5jZSwgdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgIC8vIG1peHBhbmVsLnBlb3BsZS5pZGVudGlmeSgpIGNhbGwgbWFkZSBmb3IgdGhpcyB1c2VyLiBJdCBpcyBWRVJZIEJBRCB0byBtYWtlIGFuIGFsaWFzIHdpdGhcbiAgICAvLyB0aGlzIElELCBhcyBpdCB3aWxsIGR1cGxpY2F0ZSB1c2Vycy5cbiAgICBpZiAoYWxpYXMgPT09IHRoaXMuZ2V0X3Byb3BlcnR5KFBFT1BMRV9ESVNUSU5DVF9JRF9LRVkpKSB7XG4gICAgICAgIGNvbnNvbGUuY3JpdGljYWwoJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGFsaWFzIGZvciBleGlzdGluZyBQZW9wbGUgdXNlciAtIGFib3J0aW5nLicpO1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcmlnaW5hbCkpIHtcbiAgICAgICAgb3JpZ2luYWwgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX3NpbmdsZShBTElBU19JRF9LRVksIGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2soJyRjcmVhdGVfYWxpYXMnLCB7XG4gICAgICAgICAgICAnYWxpYXMnOiBhbGlhcyxcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG9yaWdpbmFsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHNraXBfaG9va3M6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCB0aGUgcGVvcGxlIHF1ZXVlXG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmeShhbGlhcyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FsaWFzIG1hdGNoZXMgY3VycmVudCBkaXN0aW5jdF9pZCAtIHNraXBwaW5nIGFwaSBjYWxsLicpO1xuICAgICAgICB0aGlzLmlkZW50aWZ5KGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIHN0cmluZyB0byByZWNvZ25pemUgdGhlIHVzZXIgYnkuIFRoZSBzdHJpbmcgcGFzc2VkIHRvXG4gKiB0aGlzIG1ldGhvZCB3aWxsIGFwcGVhciBpbiB0aGUgTWl4cGFuZWwgU3RyZWFtcyBwcm9kdWN0IHJhdGhlclxuICogdGhhbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lLiBOYW1lIHRhZ3MgZG8gbm90IGhhdmUgdG9cbiAqIGJlIHVuaXF1ZS5cbiAqXG4gKiBUaGlzIHZhbHVlIHdpbGwgb25seSBiZSBpbmNsdWRlZCBpbiBTdHJlYW1zIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVfdGFnIEEgaHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIHVzZXJcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZyA9IGZ1bmN0aW9uKG5hbWVfdGFnKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJfc2luZ2xlKCdtcF9uYW1lX3RhZycsIG5hbWVfdGFnKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgbWl4cGFuZWwgbGlicmFyeSBpbnN0YW5jZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBjb25maWcgaXM6XG4gKlxuICogICAgIHtcbiAqICAgICAgIC8vIEhUVFAgbWV0aG9kIGZvciB0cmFja2luZyByZXF1ZXN0c1xuICogICAgICAgYXBpX21ldGhvZDogJ1BPU1QnXG4gKlxuICogICAgICAgLy8gdHJhbnNwb3J0IGZvciBzZW5kaW5nIHJlcXVlc3RzICgnWEhSJyBvciAnc2VuZEJlYWNvbicpXG4gKiAgICAgICAvLyBOQjogc2VuZEJlYWNvbiBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzY2VuYXJpb3Mgc3VjaCBhc1xuICogICAgICAgLy8gcGFnZSB1bmxvYWQgd2hlcmUgYSBcImJlc3QtZWZmb3J0XCIgYXR0ZW1wdCB0byBzZW5kIGlzXG4gKiAgICAgICAvLyBhY2NlcHRhYmxlOyB0aGUgc2VuZEJlYWNvbiBBUEkgZG9lcyBub3Qgc3VwcG9ydCBjYWxsYmFja3NcbiAqICAgICAgIC8vIG9yIGFueSB3YXkgdG8ga25vdyB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LiBNaXhwYW5lbFxuICogICAgICAgLy8gdHJhY2tpbmcgdmlhIHNlbmRCZWFjb24gd2lsbCBub3Qgc3VwcG9ydCBhbnkgZXZlbnQtXG4gKiAgICAgICAvLyBiYXRjaGluZyBvciByZXRyeSBtZWNoYW5pc21zLlxuICogICAgICAgYXBpX3RyYW5zcG9ydDogJ1hIUidcbiAqXG4gKiAgICAgICAvLyB0dXJuIG9uIHJlcXVlc3QtYmF0Y2hpbmcvcXVldWVpbmcvcmV0cnlcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RzOiBmYWxzZSxcbiAqXG4gKiAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBldmVudHMvdXBkYXRlcyB0byBzZW5kIGluIGEgc2luZ2xlXG4gKiAgICAgICAvLyBuZXR3b3JrIHJlcXVlc3RcbiAqICAgICAgIGJhdGNoX3NpemU6IDUwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gc2VuZGluZyBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXM6IDUwMDAsXG4gKlxuICogICAgICAgLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIG5ldHdvcmsgcmVzcG9uc2VzIHRvIGJhdGNoIHJlcXVlc3RzXG4gKiAgICAgICAvLyBiZWZvcmUgdGhleSBhcmUgY29uc2lkZXJlZCB0aW1lZC1vdXQgYW5kIHJldHJpZWRcbiAqICAgICAgIGJhdGNoX3JlcXVlc3RfdGltZW91dF9tczogOTAwMDAsXG4gKlxuICogICAgICAgLy8gb3ZlcnJpZGUgdmFsdWUgZm9yIGNvb2tpZSBkb21haW4sIG9ubHkgdXNlZnVsIGZvciBlbnN1cmluZ1xuICogICAgICAgLy8gY29ycmVjdCBjcm9zcy1zdWJkb21haW4gY29va2llcyBvbiB1bnVzdWFsIGRvbWFpbnMgbGlrZVxuICogICAgICAgLy8gc3ViZG9tYWluLm1haW5zaXRlLmF2b2NhdC5mcjsgTkIgdGhpcyBjYW5ub3QgYmUgdXNlZCB0b1xuICogICAgICAgLy8gc2V0IGNvb2tpZXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgb3JpZ2luXG4gKiAgICAgICBjb29raWVfZG9tYWluOiAnJ1xuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgY29va2llIGV4cGlyYXRpb24gKGluIGRheXMpXG4gKiAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzY1XG4gKlxuICogICAgICAgLy8gaWYgdHJ1ZSwgY29va2llIHdpbGwgYmUgc2V0IHdpdGggU2FtZVNpdGU9Tm9uZTsgU2VjdXJlXG4gKiAgICAgICAvLyB0aGlzIGlzIG9ubHkgdXNlZnVsIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgbGlrZSBlbWJlZGRlZFxuICogICAgICAgLy8gM3JkLXBhcnR5IGlmcmFtZXMgdGhhdCBzZXQgdXAgYSBNaXhwYW5lbCBpbnN0YW5jZVxuICogICAgICAgY3Jvc3Nfc2l0ZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gc3VwZXIgcHJvcGVydGllcyBzcGFuIHN1YmRvbWFpbnNcbiAqICAgICAgIGNyb3NzX3N1YmRvbWFpbl9jb29raWU6IHRydWVcbiAqXG4gKiAgICAgICAvLyBkZWJ1ZyBtb2RlXG4gKiAgICAgICBkZWJ1ZzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIHRoZSBtaXhwYW5lbCBjb29raWUgb3IgbG9jYWxTdG9yYWdlIGVudHJ5XG4gKiAgICAgICAvLyB3aWxsIGJlIGRlbGV0ZWQsIGFuZCBubyB1c2VyIHBlcnNpc3RlbmNlIHdpbGwgdGFrZSBwbGFjZVxuICogICAgICAgZGlzYWJsZV9wZXJzaXN0ZW5jZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIE1peHBhbmVsIHdpbGwgYXV0b21hdGljYWxseSBkZXRlcm1pbmVcbiAqICAgICAgIC8vIENpdHksIFJlZ2lvbiBhbmQgQ291bnRyeSBkYXRhIHVzaW5nIHRoZSBJUCBhZGRyZXNzIG9mXG4gKiAgICAgICAvL3RoZSBjbGllbnRcbiAqICAgICAgIGlwOiB0cnVlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiB0cmFja2luZyBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBvcHQgdXNlcnMgb3V0IG9mIGJyb3dzZXIgZGF0YSBzdG9yYWdlIGJ5IHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UgYnkgZGVmYXVsdFxuICogICAgICAgb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0OiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIGJ5IG9wdC1pbi9vcHQtb3V0IG1ldGhvZHMgLSBjb29raWVcbiAqICAgICAgIC8vIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogICAgICAgb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlOiAnbG9jYWxTdG9yYWdlJ1xuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZSB0aGUgbmFtZSBvZiBjb29raWUvbG9jYWxTdG9yYWdlIHNldCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzXG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXg6IG51bGxcbiAqXG4gKiAgICAgICAvLyB0eXBlIG9mIHBlcnNpc3RlbnQgc3RvcmUgZm9yIHN1cGVyIHByb3BlcnRpZXMgKGNvb2tpZS9cbiAqICAgICAgIC8vIGxvY2FsU3RvcmFnZSkgaWYgc2V0IHRvICdsb2NhbFN0b3JhZ2UnLCBhbnkgZXhpc3RpbmdcbiAqICAgICAgIC8vIG1peHBhbmVsIGNvb2tpZSB2YWx1ZSB3aXRoIHRoZSBzYW1lIHBlcnNpc3RlbmNlX25hbWVcbiAqICAgICAgIC8vIHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gbG9jYWxTdG9yYWdlIGFuZCBkZWxldGVkXG4gKiAgICAgICBwZXJzaXN0ZW5jZTogJ2Nvb2tpZSdcbiAqXG4gKiAgICAgICAvLyBuYW1lIGZvciBzdXBlciBwcm9wZXJ0aWVzIHBlcnNpc3RlbnQgc3RvcmVcbiAqICAgICAgIHBlcnNpc3RlbmNlX25hbWU6ICcnXG4gKlxuICogICAgICAgLy8gbmFtZXMgb2YgcHJvcGVydGllcy9zdXBlcnByb3BlcnRpZXMgd2hpY2ggc2hvdWxkIG5ldmVyXG4gKiAgICAgICAvLyBiZSBzZW50IHdpdGggdHJhY2soKSBjYWxsc1xuICogICAgICAgcHJvcGVydHlfYmxhY2tsaXN0OiBbXVxuICpcbiAqICAgICAgIC8vIGlmIHRoaXMgaXMgdHJ1ZSwgbWl4cGFuZWwgY29va2llcyB3aWxsIGJlIG1hcmtlZCBhc1xuICogICAgICAgLy8gc2VjdXJlLCBtZWFuaW5nIHRoZXkgd2lsbCBvbmx5IGJlIHRyYW5zbWl0dGVkIG92ZXIgaHR0cHNcbiAqICAgICAgIHNlY3VyZV9jb29raWU6IGZhbHNlXG4gKlxuICogICAgICAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIHRyYWNrX2xpbmtzIHdpbGxcbiAqICAgICAgIC8vIHdhaXQgZm9yIE1peHBhbmVsJ3Mgc2VydmVycyB0byByZXNwb25kXG4gKiAgICAgICB0cmFja19saW5rc190aW1lb3V0OiAzMDBcbiAqXG4gKiAgICAgICAvLyBpZiB5b3Ugc2V0IHVwZ3JhZGUgdG8gYmUgdHJ1ZSwgdGhlIGxpYnJhcnkgd2lsbCBjaGVjayBmb3JcbiAqICAgICAgIC8vIGEgY29va2llIGZyb20gb3VyIG9sZCBqcyBsaWJyYXJ5IGFuZCBpbXBvcnQgc3VwZXJcbiAqICAgICAgIC8vIHByb3BlcnRpZXMgZnJvbSBpdCwgdGhlbiB0aGUgb2xkIGNvb2tpZSBpcyBkZWxldGVkXG4gKiAgICAgICAvLyBUaGUgdXBncmFkZSBjb25maWcgb3B0aW9uIG9ubHkgd29ya3MgaW4gdGhlIGluaXRpYWxpemF0aW9uLFxuICogICAgICAgLy8gc28gbWFrZSBzdXJlIHlvdSBzZXQgaXQgd2hlbiB5b3UgY3JlYXRlIHRoZSBsaWJyYXJ5LlxuICogICAgICAgdXBncmFkZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBleHRyYSBIVFRQIHJlcXVlc3QgaGVhZGVycyB0byBzZXQgZm9yIGVhY2ggQVBJIHJlcXVlc3QsIGluXG4gKiAgICAgICAvLyB0aGUgZm9ybWF0IHsnSGVhZGVyLU5hbWUnOiB2YWx1ZX1cbiAqICAgICAgIHhocl9oZWFkZXJzOiB7fVxuICpcbiAqICAgICAgIC8vIHByb3RvY29sIGZvciBmZXRjaGluZyBpbi1hcHAgbWVzc2FnZSByZXNvdXJjZXMsIGUuZy5cbiAqICAgICAgIC8vICdodHRwczovLycgb3IgJ2h0dHA6Ly8nOyBkZWZhdWx0cyB0byAnLy8nICh3aGljaCBkZWZlcnMgdG8gdGhlXG4gKiAgICAgICAvLyBjdXJyZW50IHBhZ2UncyBwcm90b2NvbClcbiAqICAgICAgIGluYXBwX3Byb3RvY29sOiAnLy8nXG4gKlxuICogICAgICAgLy8gd2hldGhlciB0byBvcGVuIGluLWFwcCBtZXNzYWdlIGxpbmsgaW4gbmV3IHRhYi93aW5kb3dcbiAqICAgICAgIGluYXBwX2xpbmtfbmV3X3dpbmRvdzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyB3aGV0aGVyIHRvIGlnbm9yZSBvciByZXNwZWN0IHRoZSB3ZWIgYnJvd3NlcidzIERvIE5vdCBUcmFjayBzZXR0aW5nXG4gKiAgICAgICBpZ25vcmVfZG50OiBmYWxzZVxuICogICAgIH1cbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGRpY3Rpb25hcnkgb2YgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzIHRvIHVwZGF0ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgICAgXy5leHRlbmQodGhpc1snY29uZmlnJ10sIGNvbmZpZyk7XG5cbiAgICAgICAgdmFyIG5ld19iYXRjaF9zaXplID0gY29uZmlnWydiYXRjaF9zaXplJ107XG4gICAgICAgIGlmIChuZXdfYmF0Y2hfc2l6ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgICAgIGJhdGNoZXIucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ3BlcnNpc3RlbmNlX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ3BlcnNpc3RlbmNlX25hbWUnXSA9IHRoaXNbJ2NvbmZpZyddWydjb29raWVfbmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX3BlcnNpc3RlbmNlJykpIHtcbiAgICAgICAgICAgIHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb25maWcnXVsnZGlzYWJsZV9jb29raWUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzWydwZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9jb25maWcodGhpc1snY29uZmlnJ10pO1xuICAgICAgICB9XG4gICAgICAgIENvbmZpZy5ERUJVRyA9IENvbmZpZy5ERUJVRyB8fCB0aGlzLmdldF9jb25maWcoJ2RlYnVnJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsaWJyYXJ5LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKHByb3BfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydjb25maWcnXVtwcm9wX25hbWVdO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGhvb2sgZnVuY3Rpb24gZnJvbSBjb25maWcsIHdpdGggc2FmZSBkZWZhdWx0LCBhbmQgcnVuIGl0XG4gKiBhZ2FpbnN0IHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rX25hbWUgd2hpY2ggaG9vayB0byByZXRyaWV2ZVxuICogQHJldHVybnMge2FueXxudWxsfSByZXR1cm4gdmFsdWUgb2YgdXNlci1wcm92aWRlZCBob29rLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIHJldHVybmVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcnVuX2hvb2sgPSBmdW5jdGlvbihob29rX25hbWUpIHtcbiAgICB2YXIgcmV0ID0gKHRoaXNbJ2NvbmZpZyddWydob29rcyddW2hvb2tfbmFtZV0gfHwgSURFTlRJVFlfRlVOQykuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihob29rX25hbWUgKyAnIGhvb2sgZGlkIG5vdCByZXR1cm4gYSB2YWx1ZScpO1xuICAgICAgICByZXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgbmFtZWQgcHJvcGVydHlfbmFtZS4gSWYgbm8gc3VjaFxuICogcHJvcGVydHkgaXMgc2V0LCBnZXRfcHJvcGVydHkoKSB3aWxsIHJldHVybiB0aGUgdW5kZWZpbmVkIHZhbHVlLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBnZXRfcHJvcGVydHkoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIE1peHBhbmVsIGxpYnJhcnkgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKiBpbml0KCkgaGFzIGEgbG9hZGVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBoYW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZ3JhYiB2YWx1ZSBmb3IgJ3VzZXJfaWQnIGFmdGVyIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGhhcyBsb2FkZWRcbiAqICAgICBtaXhwYW5lbC5pbml0KCdZT1VSIFBST0pFQ1QgVE9LRU4nLCB7XG4gKiAgICAgICAgIGxvYWRlZDogZnVuY3Rpb24obWl4cGFuZWwpIHtcbiAqICAgICAgICAgICAgIHVzZXJfaWQgPSBtaXhwYW5lbC5nZXRfcHJvcGVydHkoJ3VzZXJfaWQnKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eV9uYW1lIFRoZSBuYW1lIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSB5b3Ugd2FudCB0byByZXRyaWV2ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHlfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydwZXJzaXN0ZW5jZSddWydwcm9wcyddW3Byb3BlcnR5X25hbWVdO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmdldF9jb25maWcoJ25hbWUnKTtcbiAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIG5hbWUgPSBQUklNQVJZX0lOU1RBTkNFX05BTUUgKyAnLicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZXZlbnRfaXNfZGlzYWJsZWQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgcmV0dXJuIF8uaXNCbG9ja2VkVUEodXNlckFnZW50KSB8fFxuICAgICAgICB0aGlzLl9mbGFncy5kaXNhYmxlX2FsbF9ldmVudHMgfHxcbiAgICAgICAgXy5pbmNsdWRlKHRoaXMuX19kaXNhYmxlZF9ldmVudHMsIGV2ZW50X25hbWUpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9jaGVja19hbmRfaGFuZGxlX3RyaWdnZXJlZF9ub3RpZmljYXRpb25zID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihldmVudF9kYXRhKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyX2RlY2lkZV9jaGVja19jb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9ldmVudHNfdHJhY2tlZF9iZWZvcmVfdXNlcl9kZWNpZGVfY2hlY2tfY29tcGxldGUucHVzaChldmVudF9kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyID0gdGhpc1snX3RyaWdnZXJlZF9ub3RpZnMnXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub3RpZiA9IG5ldyBNaXhwYW5lbE5vdGlmaWNhdGlvbihhcnJbaV0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKG5vdGlmLl9tYXRjaGVzX2V2ZW50X2RhdGEoZXZlbnRfZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93X25vdGlmaWNhdGlvbihhcnJbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2NoZWNrX2FuZF9oYW5kbGVfbm90aWZpY2F0aW9ucyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZGlzdGluY3RfaWQpIHtcbiAgICBpZiAoXG4gICAgICAgICFkaXN0aW5jdF9pZCB8fFxuICAgICAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgfHxcbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdkaXNhYmxlX25vdGlmaWNhdGlvbnMnKVxuICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ01JWFBBTkVMIE5PVElGSUNBVElPTiBDSEVDSycpO1xuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICd2ZXJib3NlJzogICAgIHRydWUsXG4gICAgICAgICd2ZXJzaW9uJzogICAgICczJyxcbiAgICAgICAgJ2xpYic6ICAgICAgICAgJ3dlYicsXG4gICAgICAgICd0b2tlbic6ICAgICAgIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKSxcbiAgICAgICAgJ2Rpc3RpbmN0X2lkJzogZGlzdGluY3RfaWRcbiAgICB9O1xuICAgIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy9kZWNpZGUvJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAge21ldGhvZDogJ0dFVCcsIHRyYW5zcG9ydDogJ1hIUid9LFxuICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKF8uYmluZChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbJ25vdGlmaWNhdGlvbnMnXSAmJiByZXN1bHRbJ25vdGlmaWNhdGlvbnMnXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1snX3RyaWdnZXJlZF9ub3RpZnMnXSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgXy5lYWNoKHJlc3VsdFsnbm90aWZpY2F0aW9ucyddLCBmdW5jdGlvbihub3RpZikge1xuICAgICAgICAgICAgICAgICAgICAobm90aWZbJ2Rpc3BsYXlfdHJpZ2dlcnMnXSAmJiBub3RpZlsnZGlzcGxheV90cmlnZ2VycyddLmxlbmd0aCA+IDAgPyB0aGlzWydfdHJpZ2dlcmVkX25vdGlmcyddIDogbm90aWZpY2F0aW9ucykucHVzaChub3RpZik7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93X25vdGlmaWNhdGlvbi5jYWxsKHRoaXMsIG5vdGlmaWNhdGlvbnNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZV91c2VyX2RlY2lkZV9jaGVja19jb21wbGV0ZSgpO1xuICAgICAgICB9LCB0aGlzKSlcbiAgICApO1xufSk7XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faGFuZGxlX3VzZXJfZGVjaWRlX2NoZWNrX2NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXNlcl9kZWNpZGVfY2hlY2tfY29tcGxldGUgPSB0cnVlO1xuXG4gICAgLy8gY2hlY2sgbm90aWZpY2F0aW9ucyBhZ2FpbnN0IGV2ZW50cyB0aGF0IHdlcmUgdHJhY2tlZCBiZWZvcmUgZGVjaWRlIGNhbGwgY29tcGxldGVkXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c190cmFja2VkX2JlZm9yZV91c2VyX2RlY2lkZV9jaGVja19jb21wbGV0ZTtcbiAgICB3aGlsZSAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudHMuc2hpZnQoKTsgLy8gcmVwbGF5IGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgY2FtZSBpblxuICAgICAgICB0aGlzLl9jaGVja19hbmRfaGFuZGxlX3RyaWdnZXJlZF9ub3RpZmljYXRpb25zKGRhdGEpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2hvd19ub3RpZmljYXRpb24gPSBmdW5jdGlvbihub3RpZl9kYXRhKSB7XG4gICAgdmFyIG5vdGlmaWNhdGlvbiA9IG5ldyBNaXhwYW5lbE5vdGlmaWNhdGlvbihub3RpZl9kYXRhLCB0aGlzKTtcbiAgICBub3RpZmljYXRpb24uc2hvdygpO1xufTtcblxuLy8gcGVyZm9ybSBzb21lIGhvdXNla2VlcGluZyBhcm91bmQgR0RQUiBvcHQtaW4vb3V0IHN0YXRlXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkID0gdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSA9PT0gJ2xvY2FsU3RvcmFnZSc7XG5cbiAgICAvLyB0cnkgdG8gY29udmVydCBvcHQtaW4vb3V0IGNvb2tpZXMgdG8gbG9jYWxTdG9yYWdlIGlmIHBvc3NpYmxlXG4gICAgaWYgKGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgJiYgXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X2luX3RyYWNraW5nKHsnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZScsXG4gICAgICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgYWxyZWFkeSBvcHRlZCBvdXQgLSBpZiBzbywgY2xlYXIgJiBkaXNhYmxlIHBlcnNpc3RlbmNlXG4gICAgaWYgKHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlfSk7XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHdlIHNob3VsZCBvcHQgb3V0IGJ5IGRlZmF1bHRcbiAgICAvLyBub3RlOiB3ZSBkb24ndCBjbGVhciBwZXJzaXN0ZW5jZSBoZXJlIGJ5IGRlZmF1bHQgc2luY2Ugb3B0LW91dCBkZWZhdWx0IHN0YXRlIGlzIG9mdGVuXG4gICAgLy8gICAgICAgdXNlZCBhcyBhbiBpbml0aWFsIHN0YXRlIHdoaWxlIEdEUFIgaW5mb3JtYXRpb24gaXMgYmVpbmcgY29sbGVjdGVkXG4gICAgfSBlbHNlIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiAoXG4gICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0JykgfHwgXy5jb29raWUuZ2V0KCdtcF9vcHRvdXQnKVxuICAgICkpIHtcbiAgICAgICAgXy5jb29raWUucmVtb3ZlKCdtcF9vcHRvdXQnKTtcbiAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JylcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBwZXJzaXN0ZW5jZSBiYXNlZCBvbiBvcHRpb25zXG4gKiBvbmx5IGVuYWJsZS9kaXNhYmxlIGlmIHBlcnNpc3RlbmNlIGlzIG5vdCBhbHJlYWR5IGluIHRoaXMgc3RhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlIGFuZCBkaXNhYmxlIGl0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRpc2FibGVkO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2NsZWFyX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydlbmFibGVfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpICYmIHRoaXNbJ3BlcnNpc3RlbmNlJ10uZGlzYWJsZWQgIT09IGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uc2V0X2Rpc2FibGVkKGRpc2FibGVkKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5jbGVhcigpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyBjYWxsIGEgYmFzZSBnZHByIGZ1bmN0aW9uIGFmdGVyIGNvbnN0cnVjdGluZyB0aGUgYXBwcm9wcmlhdGUgdG9rZW4gYW5kIG9wdGlvbnMgYXJnc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2NhbGxfZnVuYyA9IGZ1bmN0aW9uKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAndHJhY2snOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcyksXG4gICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSxcbiAgICAgICAgJ2Nvb2tpZV9wcmVmaXgnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfY29va2llX3ByZWZpeCcpLFxuICAgICAgICAnY29va2llX2V4cGlyYXRpb24nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9leHBpcmF0aW9uJyksXG4gICAgICAgICdjcm9zc19zaXRlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc2l0ZV9jb29raWUnKSxcbiAgICAgICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnKSxcbiAgICAgICAgJ2Nvb2tpZV9kb21haW4nOiB0aGlzLmdldF9jb25maWcoJ2Nvb2tpZV9kb21haW4nKSxcbiAgICAgICAgJ3NlY3VyZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ3NlY3VyZV9jb29raWUnKSxcbiAgICAgICAgJ2lnbm9yZV9kbnQnOiB0aGlzLmdldF9jb25maWcoJ2lnbm9yZV9kbnQnKVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgbG9jYWxTdG9yYWdlIGNhbiBiZSB1c2VkIGZvciByZWNvcmRpbmcgb3B0IG91dCBzdGF0dXMsIGZhbGwgYmFjayB0byBjb29raWUgaWYgbm90XG4gICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYyh0aGlzLmdldF9jb25maWcoJ3Rva2VuJyksIHtcbiAgICAgICAgdHJhY2s6IG9wdGlvbnNbJ3RyYWNrJ10sXG4gICAgICAgIHRyYWNrRXZlbnROYW1lOiBvcHRpb25zWyd0cmFja19ldmVudF9uYW1lJ10sXG4gICAgICAgIHRyYWNrUHJvcGVydGllczogb3B0aW9uc1sndHJhY2tfcHJvcGVydGllcyddLFxuICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IG9wdGlvbnNbJ2Nvb2tpZV9wcmVmaXgnXSxcbiAgICAgICAgY29va2llRG9tYWluOiBvcHRpb25zWydjb29raWVfZG9tYWluJ10sXG4gICAgICAgIGNvb2tpZUV4cGlyYXRpb246IG9wdGlvbnNbJ2Nvb2tpZV9leHBpcmF0aW9uJ10sXG4gICAgICAgIGNyb3NzU2l0ZUNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc2l0ZV9jb29raWUnXSxcbiAgICAgICAgY3Jvc3NTdWJkb21haW5Db29raWU6IG9wdGlvbnNbJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnXSxcbiAgICAgICAgc2VjdXJlQ29va2llOiBvcHRpb25zWydzZWN1cmVfY29va2llJ10sXG4gICAgICAgIGlnbm9yZURudDogb3B0aW9uc1snaWdub3JlX2RudCddXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBpbiB0byBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqICAgICAvLyBvcHQgdXNlciBpblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBpbiB3aXRoIHNwZWNpZmljIGV2ZW50IG5hbWUsIHByb3BlcnRpZXMsIGNvb2tpZSBjb25maWd1cmF0aW9uXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKHtcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfbmFtZTogJ1VzZXIgb3B0ZWQgaW4nLFxuICogICAgICAgICB0cmFja19ldmVudF9wcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSBGdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvbiAoZGVmYXVsdCBpcyB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgdHJhY2sgbWV0aG9kKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrX2V2ZW50X25hbWU9JG9wdF9pbl0gRXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrX3Byb3BlcnRpZXNdIFNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0SW4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dFxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0IHdpdGggZGlmZmVyZW50IGNvb2tpZSBjb25maWd1cmF0aW9uIGZyb20gTWl4cGFuZWwgaW5zdGFuY2VcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsZXRlX3VzZXI9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgdGhlIGN1cnJlbnRseSBpZGVudGlmaWVkIHVzZXIncyBwcm9maWxlIGFuZCBjbGVhciBhbGwgY2hhcmdlcyBhZnRlciBvcHRpbmcgdGhlIHVzZXIgb3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZSxcbiAgICAgICAgJ2RlbGV0ZV91c2VyJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gZGVsZXRlIHVzZXIgYW5kIGNsZWFyIGNoYXJnZXMgc2luY2UgdGhlc2UgbWV0aG9kcyBtYXkgYmUgZGlzYWJsZWQgYnkgb3B0LW91dFxuICAgIGlmIChvcHRpb25zWydkZWxldGVfdXNlciddICYmIHRoaXNbJ3Blb3BsZSddICYmIHRoaXNbJ3Blb3BsZSddLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5kZWxldGVfdXNlcigpO1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5jbGVhcl9jaGFyZ2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0T3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiAgICAgdmFyIGhhc19vcHRlZF9pbiA9IG1peHBhbmVsLmhhc19vcHRlZF9pbl90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfaW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IG9wdC1pbiBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRJbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX291dCA9IG1peHBhbmVsLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX291dCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LW91dCBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkT3V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXNcbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1cyB3aXRoIHNwZWNpZmljIGNvb2tpZSBjb25maWd1cmF0aW9uIC0gc2hvdWxkIG1hdGNoXG4gKiAgICAgLy8gY29uZmlndXJhdGlvbiB1c2VkIHdoZW4gb3B0X2luX3RyYWNraW5nL29wdF9vdXRfdHJhY2tpbmcgbWV0aG9kcyB3ZXJlIGNhbGxlZC5cbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhjbGVhck9wdEluT3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuXG4vLyBNaXhwYW5lbExpYiBFeHBvcnRzXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2luaXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZXNldCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2Rpc2FibGUnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0aW1lX2V2ZW50J10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2snXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19saW5rcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3M7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2Zvcm1zJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3Jtcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfcGFnZXZpZXcnXSAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyX29uY2UnXSAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd1bnJlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaWRlbnRpZnknXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhbGlhcyddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ25hbWVfdGFnJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfcHJvcGVydHknXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZGlzdGluY3RfaWQnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ19jaGVja19hbmRfaGFuZGxlX25vdGlmaWNhdGlvbnMnXSAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5fY2hlY2tfYW5kX2hhbmRsZV9ub3RpZmljYXRpb25zO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydfaGFuZGxlX3VzZXJfZGVjaWRlX2NoZWNrX2NvbXBsZXRlJ10gPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuX2hhbmRsZV91c2VyX2RlY2lkZV9jaGVja19jb21wbGV0ZTtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnX3Nob3dfbm90aWZpY2F0aW9uJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zaG93X25vdGlmaWNhdGlvbjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X291dF90cmFja2luZyddICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9pbl90cmFja2luZyddICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydjbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nJ10gICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWRkX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFkZF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVtb3ZlX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfd2l0aF9ncm91cHMnXSAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3dpdGhfZ3JvdXBzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3BfYmF0Y2hfc2VuZGVycztcblxuLy8gTWl4cGFuZWxQZXJzaXN0ZW5jZSBFeHBvcnRzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsncHJvcGVydGllcyddICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9zZWFyY2hfa2V5d29yZCddID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9yZWZlcnJlcl9pbmZvJ10gID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm87XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnZ2V0X2Nyb3NzX3N1YmRvbWFpbiddICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2NsZWFyJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXI7XG5cbl8uc2FmZXdyYXBfY2xhc3MoTWl4cGFuZWxMaWIsIFsnaWRlbnRpZnknLCAnX2NoZWNrX2FuZF9oYW5kbGVfbm90aWZpY2F0aW9ucycsICdfc2hvd19ub3RpZmljYXRpb24nXSk7XG5cblxudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGV4dGVuZF9tcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFkZCBhbGwgdGhlIHN1YiBtaXhwYW5lbCBpbnN0YW5jZXNcbiAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7IG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlOyB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcHJpdmF0ZSBmdW5jdGlvbnMgYXMgX1xuICAgIG1peHBhbmVsX21hc3RlclsnXyddID0gXztcbn07XG5cbnZhciBvdmVycmlkZV9tcF9pbml0X2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGUgc25pcHBldHMgaW5pdCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYVxuICAgIC8vIHVzZXIgaW5pdGlhbGl6ZXMgdGhlIG1peHBhbmVsIGxpYnJhcnkgYWZ0ZXIgdGhlIHNjcmlwdCBsb2FkcyAmIHJ1bnNcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgYSBzdWIgbGlicmFyeVxuICAgICAgICAgICAgaWYgKCFtaXhwYW5lbF9tYXN0ZXJbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZXNbbmFtZV0gPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdLl9sb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBtaXhwYW5lbF9tYXN0ZXI7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSkge1xuICAgICAgICAgICAgICAgIC8vIG1haW4gbWl4cGFuZWwgbGliIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGludGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBsaWJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBQUklNQVJZX0lOU1RBTkNFX05BTUUpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXIgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbml0X3R5cGUgPT09IElOSVRfU05JUFBFVCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdyQxW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBtaXhwYW5lbF9tYXN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRfbXAoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgYWRkX2RvbV9sb2FkZWRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENyb3NzIGJyb3dzZXIgRE9NIExvYWRlZCBzdXBwb3J0XG4gICAgZnVuY3Rpb24gZG9tX2xvYWRlZF9oYW5kbGVyKCkge1xuICAgICAgICAvLyBmdW5jdGlvbiBmbGFnIHNpbmNlIHdlIG9ubHkgd2FudCB0byBleGVjdXRlIHRoaXMgb25jZVxuICAgICAgICBpZiAoZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlci5kb25lID0gdHJ1ZTtcblxuICAgICAgICBET01fTE9BREVEID0gdHJ1ZTtcbiAgICAgICAgRU5RVUVVRV9SRVFVRVNUUyA9IGZhbHNlO1xuXG4gICAgICAgIF8uZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3QpIHtcbiAgICAgICAgICAgIGluc3QuX2RvbV9sb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9fc2Nyb2xsX2NoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoJ2xlZnQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvX3Njcm9sbF9jaGVjaywgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCQxLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIC8vIHNhZmFyaSA0IGNhbiBmaXJlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGJlZm9yZSBsb2FkaW5nIGFsbFxuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgSlMgKGluY2x1ZGluZyB0aGlzIGZpbGUpLiB5b3Ugd2lsbCBzZWUgc29tZSBjb3B5cGFzdGFcbiAgICAgICAgICAgIC8vIG9uIHRoZSBpbnRlcm5ldCB0aGF0IGNoZWNrcyBmb3IgJ2NvbXBsZXRlJyBhbmQgJ2xvYWRlZCcsIGJ1dFxuICAgICAgICAgICAgLy8gJ2xvYWRlZCcgaXMgYW4gSUUgdGhpbmdcbiAgICAgICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50JDEuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgLy8gSUVcbiAgICAgICAgZG9jdW1lbnQkMS5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZG9tX2xvYWRlZF9oYW5kbGVyKTtcblxuICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgd2UgYXJuJ3QgaW4gYSBmcmFtZVxuICAgICAgICB2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvcGxldmVsID0gd2luZG93JDEuZnJhbWVFbGVtZW50ID09PSBudWxsO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudCQxLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgZG9fc2Nyb2xsX2NoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBoYW5kbGVyLCBhbHdheXMgd2lsbCB3b3JrXG4gICAgXy5yZWdpc3Rlcl9ldmVudCh3aW5kb3ckMSwgJ2xvYWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gaW5pdF9hc19tb2R1bGUoKSB7XG4gICAgaW5pdF90eXBlID0gSU5JVF9NT0RVTEU7XG4gICAgbWl4cGFuZWxfbWFzdGVyID0gbmV3IE1peHBhbmVsTGliKCk7XG5cbiAgICBvdmVycmlkZV9tcF9pbml0X2Z1bmMoKTtcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSgpO1xuICAgIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIoKTtcblxuICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXI7XG59XG5cbnZhciBtaXhwYW5lbCA9IGluaXRfYXNfbW9kdWxlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWl4cGFuZWw7IiwiaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCdcbmltcG9ydCB7IFBsYXllciB9IGZyb20gJy4vbW9kZWxzL3BsYXllcidcbmltcG9ydCB7IEVuZW15LCBCb3NzIH0gZnJvbSAnLi9tb2RlbHMvZW5lbWllcydcbmltcG9ydCB7IFBvd2VyVXAgfSBmcm9tICcuL21vZGVscy9wb3dlcnVwcydcbmltcG9ydCB7IFByb2plY3RpbGUsIFBhcnRpY2xlLCBCYWNrZ3JvdW5kUGFydGljbGUgfSBmcm9tICcuL21vZGVscy9wYXJ0aWNsZXMnXG52YXIgbWl4cGFuZWwgPSByZXF1aXJlKCdtaXhwYW5lbC1icm93c2VyJyk7XG5taXhwYW5lbC5pbml0KFwiYTJhODFhYmQxNDEyZTUxOGIyNzdlMGJmYmFiNDE0YmNcIik7XG5cbi8vIEhUTUwgZWxlbWVudHNcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcycpXG5jb25zdCBzY29yZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Njb3JlRWwnKVxuY29uc3QgbGV2ZWxFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsZXZlbEVsJylcbmNvbnN0IG1vZGFsRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbW9kYWxFbCcpIGFzIEhUTUxFbGVtZW50XG5jb25zdCBjb21ib0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbWJvRWwnKVxuY29uc3QgYmlnU2NvcmVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNiaWdTY29yZUVsJylcbmNvbnN0IHN0YXJ0R2FtZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGFydEdhbWVCdG4nKVxuY29uc3QgaW5mb3JCYXJFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbmZvQmFyJylcbmNvbnN0IGxvbmdDb21ib0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xvbmdlc3RDb21ib0VsJylcbmNvbnN0IHJ1bnRpbWVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0aW1lRWwnKVxuY29uc3QgdmljdG9yeUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ZpY3RvcnlFbCcpIGFzIEhUTUxFbGVtZW50XG5cbi8vIFNvbmdzXG5jb25zdCBhbGJhdHJvc3NTb25nVVJMID0gJy4vYXVkaW8vYWxiYXRyb3NzLm1wMydcbmNvbnN0IG1vdmluZ01pYW1pU29uZ1VSTCA9ICcuL2F1ZGlvL21vdmluZ190b19taWFtaS5tcDMnXG5jb25zdCBpbkNsb3Vkc1NvbmdVUkwgPSAnLi9hdWRpby9pbl9jbG91ZHMubXAzJ1xubGV0IGN1cnJlbnRTb25nID0gYWxiYXRyb3NzU29uZ1VSTFxuY29uc3QgYmFja2dyb3VuZE11c2ljID0gbmV3IEF1ZGlvKGN1cnJlbnRTb25nKVxuYmFja2dyb3VuZE11c2ljLnZvbHVtZSA9IDAuNjZcbmJhY2tncm91bmRNdXNpYy5jdXJyZW50VGltZSA9IDBcbmNvbnN0IGJvc3NNdXNpYyA9IG5ldyBBdWRpbygnLi9hdWRpby9hbHRCb3NzLm1wMycpXG5ib3NzTXVzaWMubG9vcCA9IHRydWVcbmNvbnN0IHZpY3RvcnlNdXNpY1VSTCA9ICcuL2F1ZGlvL3Jpc2luZ19zdGFycy5tcDMnXG5jb25zdCB2aWN0b3J5U29uZyA9IG5ldyBBdWRpbyh2aWN0b3J5TXVzaWNVUkwpXG5jb25zdCB3aW5Tb3VuZCA9IG5ldyBBdWRpbygnL2F1ZGlvL2FjdGl2YXRpb24ubXAzJylcblxuZnVuY3Rpb24gbmV4dFNvbmcoKSB7XG4gICAgc3dpdGNoIChjdXJyZW50U29uZykge1xuICAgICAgICBjYXNlIGFsYmF0cm9zc1NvbmdVUkw6IGRlZmF1bHQ6XG4gICAgICAgICAgICBiYWNrZ3JvdW5kTXVzaWMuc3JjID0gbW92aW5nTWlhbWlTb25nVVJMXG4gICAgICAgICAgICBiYWNrZ3JvdW5kTXVzaWMudm9sdW1lID0gMC40XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIGluQ2xvdWRzU29uZ1VSTDpcbiAgICAgICAgICAgIGJhY2tncm91bmRNdXNpYy5zcmMgPSBhbGJhdHJvc3NTb25nVVJMXG4gICAgICAgICAgICBiYWNrZ3JvdW5kTXVzaWMudm9sdW1lID0gMC41XG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIG1vdmluZ01pYW1pU29uZ1VSTDpcbiAgICAgICAgICAgIGJhY2tncm91bmRNdXNpYy5zcmMgPSBpbkNsb3Vkc1NvbmdVUkxcbiAgICAgICAgICAgIGJhY2tncm91bmRNdXNpYy52b2x1bWUgPSAwLjMzXG4gICAgICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoIXNjZW5lLmJvc3MpIHtcbiAgICAgICAgYmFja2dyb3VuZE11c2ljLnNyYyA9IGN1cnJlbnRTb25nXG4gICAgICAgIGJhY2tncm91bmRNdXNpYy5wYXVzZSgpXG4gICAgICAgIGJhY2tncm91bmRNdXNpYy5sb2FkKClcbiAgICAgICAgYmFja2dyb3VuZE11c2ljLnBsYXkoKVxuXG4gICAgfVxufVxuXG4vLyBTb3VuZCBGWFxuY29uc3Qgc3RhcnRHYW1lQXVkaW8gPSBuZXcgQXVkaW8oJy4vYXVkaW8vc3RhcnQubXAzJylcbmNvbnN0IGVuZEdhbWVBdWRpbyA9IG5ldyBBdWRpbygnLi9hdWRpby9hbHRFbmQubXAzJylcbmNvbnN0IGNvbWJvQnJlYWsgPSBuZXcgQXVkaW8oJy4vYXVkaW8vZGVzdHJveS5tcDMnKVxuY29uc3QgZGVzdHJveUVuZW15ID0gbmV3IEF1ZGlvKCcuL2F1ZGlvL2NvbnRpbnVlLm1wMycpXG5jb25zdCBvYnRhaW5Qb3dlcnVwQXVkaW8gPSBuZXcgQXVkaW8oJy4vYXVkaW8vcG93ZXJ1cC5tcDMnKVxuY29uc3QgYWxhcm1BdWRpbyA9IG5ldyBBdWRpbygnLi9hdWRpby93YXJuaW5nLm1wMycpXG5cbmJhY2tncm91bmRNdXNpYy5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIG5leHRTb25nKVxudmljdG9yeVNvbmcuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBuZXh0U29uZylcblxuY29uc3Qgc2NlbmUgPSB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBib3NzOiBmYWxzZSxcbiAgICBjb2xvcjogdW5kZWZpbmVkLFxufVxuY29uc3Qga2V5cyA9IHtcbiAgICB1cDogZmFsc2UsXG4gICAgZG93bjogZmFsc2UsXG4gICAgcmlnaHQ6IGZhbHNlLFxuICAgIGxlZnQ6IGZhbHNlXG59XG5jb25zdCBtb3VzZSA9IHtcbiAgICBkb3duOiBmYWxzZSxcbiAgICB4OiB1bmRlZmluZWQsXG4gICAgeTogdW5kZWZpbmVkLFxufVxuY29uc3QgYyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5jYW52YXMud2lkdGggPSBpbm5lcldpZHRoXG5jYW52YXMuaGVpZ2h0ID0gaW5uZXJIZWlnaHQgLSBpbmZvckJhckVsLmNsaWVudEhlaWdodFxubGV0IHRvcExlZnQgPSB7IHg6IDAsIHk6IDAgfVxubGV0IGJvdHRvbVJpZ2h0ID0geyB4OiAwLCB5OiAwIH1cbmxldCBhbmltYXRpb25JZDogbnVtYmVyXG5sZXQgcGxheWVyOiBQbGF5ZXJcbmxldCBwb3dlclVwczogUG93ZXJVcFtdXG5sZXQgcGFydGljbGVzOiBQYXJ0aWNsZVtdXG5sZXQgZW5lbWllczogYW55W11cbmxldCBwcm9qZWN0aWxlczogUHJvamVjdGlsZVtdXG5sZXQgYmFja2dyb3VuZFBhcnRpY2xlczogQmFja2dyb3VuZFBhcnRpY2xlW11cbmxldCBmcmFtZTogbnVtYmVyXG5sZXQgc2NvcmU6IG51bWJlclxubGV0IGxldmVsOiBudW1iZXJcbmxldCBjb21ibzogbnVtYmVyXG5sZXQgbGl0Q291bnQ6IG51bWJlclxubGV0IHBhcnRpY2xlQ291bnQ6IG51bWJlclxubGV0IHBvd2VydXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApIC8vIGxldCB0eXBlIGluZmVyZW5jZSBkbyBpdHMgdGhpbmdcbmNvbnN0IHNwYWNpbmcgPSAzMFxuY29uc3QgcGFkZGluZyA9IDUwXG5sZXQgZW5hYmxlTWl4cGFuZWwgPSB0cnVlXG5cbi8vIHN0YXRzXG5sZXQgbG9uZ2VzdENvbWJvOiBudW1iZXJcbmxldCBzdGFydFRpbWU6IGFueVxuXG5mdW5jdGlvbiBpbml0KCkge1xuICAgIGlmICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICAgIGVuYWJsZU1peHBhbmVsID0gZmFsc2VcbiAgICB9XG4gICAgY29uc29sZS5sb2cod2luZG93LmxvY2F0aW9uKVxuICAgIGNhbnZhcy53aWR0aCA9IGlubmVyV2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW5uZXJIZWlnaHQgLSBpbmZvckJhckVsLmNsaWVudEhlaWdodFxuICAgIHRvcExlZnQgPSB7XG4gICAgICAgIHg6IDAgKyBwYWRkaW5nLFxuICAgICAgICB5OiAwICsgcGFkZGluZ1xuICAgIH1cbiAgICBib3R0b21SaWdodCA9IHtcbiAgICAgICAgeDogY2FudmFzLndpZHRoIC0gcGFkZGluZyxcbiAgICAgICAgeTogY2FudmFzLmhlaWdodCAtIHBhZGRpbmdcbiAgICB9XG4gICAgc2NvcmUgPSAwXG4gICAgY29tYm8gPSAwXG4gICAgZnJhbWUgPSAwXG4gICAgbGV2ZWwgPSAxXG4gICAgbG9uZ2VzdENvbWJvID0gMFxuICAgIHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBjb21ib0VsLmlubmVySFRNTCA9IGNvbWJvLnRvU3RyaW5nKClcbiAgICB2aWN0b3J5RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGdzYXAudG8oYm9zc011c2ljLCB7XG4gICAgICAgIHZvbHVtZTogMC4wLFxuICAgICAgICBkdXJhdGlvbjogNCxcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgYm9zc011c2ljLnBhdXNlKClcbiAgICAgICAgICAgIGJvc3NNdXNpYy5jdXJyZW50VGltZSA9IDBcbiAgICAgICAgICAgIGJvc3NNdXNpYy52b2x1bWUgPSAxLjBcbiAgICAgICAgfVxuICAgIH0pXG4gICAgYmFja2dyb3VuZE11c2ljLnZvbHVtZSA9IDAuNVxuICAgIGJhY2tncm91bmRNdXNpYy5wbGF5KClcbiAgICBzY2VuZS5ib3NzID0gZmFsc2VcbiAgICBsZXZlbEVsLmlubmVySFRNTCA9IGxldmVsLnRvU3RyaW5nKClcbiAgICBwbGF5ZXIgPSBuZXcgUGxheWVyKHRvcExlZnQsIGJvdHRvbVJpZ2h0LCAxMCwgJ2l2b3J5JylcbiAgICBwcm9qZWN0aWxlcyA9IFtdXG4gICAgcGFydGljbGVzID0gW11cbiAgICBlbmVtaWVzID0gW11cbiAgICBwb3dlclVwcyA9IFtdXG4gICAgYmFja2dyb3VuZFBhcnRpY2xlcyA9IFtdXG4gICAgZm9yICh2YXIgaSA9IHRvcExlZnQueDsgaSA8IGJvdHRvbVJpZ2h0Lng7IGkgKz0gc3BhY2luZykge1xuICAgICAgICBmb3IgKGxldCBqID0gdG9wTGVmdC55OyBqIDwgYm90dG9tUmlnaHQueTsgaiArPSBzcGFjaW5nKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kUGFydGljbGVzLnB1c2gobmV3IEJhY2tncm91bmRQYXJ0aWNsZShpLCBqLCAzLCAnaXZvcnknKSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNsZUNvdW50ID0gYmFja2dyb3VuZFBhcnRpY2xlcy5sZW5ndGhcbiAgICBsaXRDb3VudCA9IDBcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICBhbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKVxuICAgIGZyYW1lKytcbiAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuNSknIC8vIGNyZWF0ZSBtb3Rpb24gYmx1ciBlZmZlY3RcbiAgICBjLmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBpZiAoZnJhbWUgJSAzMDAgPT09IDApIHtcbiAgICAgICAgc2V0TGV2ZWwoc2NvcmUpXG4gICAgICAgIHNwYXduRW5lbWllcyhsZXZlbClcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjIwKSBzcGF3blBvd2VyVXAoKVxuICAgIH1cbiAgICBsaWdodFVwQmFja2dyb3VuZFBhcnRpY2xlcygpXG4gICAgdXBkYXRlUG93ZXJ1cHMoKVxuICAgIHVwZGF0ZUVuZW1pZXMoKVxuICAgIHBsYXllci51cGRhdGUoYywga2V5cylcbiAgICBpZiAocGxheWVyLnBvd2VyVXAgPT09ICdBdXRvbWF0aWMnICYmIG1vdXNlLmRvd24gJiYgZnJhbWUgJSA0ID09PSAwKSB7XG4gICAgICAgIHByb2plY3RpbGVzLnB1c2gocGxheWVyLnNob290KG1vdXNlKSlcbiAgICB9XG4gICAgY2xlYW51cCgpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVuZW1pZXMoKSB7XG4gICAgZW5lbWllcy5mb3JFYWNoKChlbmVteSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguaHlwb3QocGxheWVyLnggLSBlbmVteS54LCBwbGF5ZXIueSAtIGVuZW15LnkpXG4gICAgICAgIGlmIChkaXN0IC0gZW5lbXkucmFkaXVzIC0gcGxheWVyLnJhZGl1cyA8IDEpIGVuZEdhbWUoKVxuXG4gICAgICAgIGVuZW15LnVwZGF0ZShjLCBwbGF5ZXIueCwgcGxheWVyLnkpXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZW5lbXkgaGl0IGFueSBwcm9qZWN0aWxlc1xuICAgICAgICBwcm9qZWN0aWxlcy5mb3JFYWNoKChwcm9qZWN0aWxlLCBwcm9qZWN0aWxlSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmh5cG90KHByb2plY3RpbGUueCAtIGVuZW15LngsIHByb2plY3RpbGUueSAtIGVuZW15LnkpXG4gICAgICAgICAgICBpZiAoZGlzdCAtIGVuZW15LnJhZGl1cyAtIHByb2plY3RpbGUucmFkaXVzIDwgMC4xICYmIGVuZW15LnJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxhc2hBbW91bnQgPSBNYXRoLm1heCgxNiwgZW5lbXkucmFkaXVzIC8gNilcbiAgICAgICAgICAgICAgICBjb25zdCBzcGxhc2hBbmdsZSA9IE1hdGguYXRhbjIocHJvamVjdGlsZS55IC0gZW5lbXkueSwgcHJvamVjdGlsZS54IC0gZW5lbXkueClcbiAgICAgICAgICAgICAgICBoaXRTcGxhc2gocHJvamVjdGlsZS54LCBwcm9qZWN0aWxlLnksIGVuZW15LmNvbG9yLCBzcGxhc2hBbW91bnQsIHNwbGFzaEFuZ2xlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJvamVjdGlsZXMuc3BsaWNlKHByb2plY3RpbGVJbmRleCwgMSksIDApXG4gICAgICAgICAgICAgICAgaWYgKGVuZW15LmhpdChwcm9qZWN0aWxlLnBvd2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpLmUuIGVuZW15IHN1cnZpdmVkIGhpdFxuICAgICAgICAgICAgICAgICAgICBhZGRTY29yZSgxMDAsIHByb2plY3RpbGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkuY29sb3IgPT09IHNjZW5lLmNvbG9yID8gY29udGludWVDb21ibygpIDogYnJlYWtDb21ibyhlbmVteSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZW15LmlzQm9zcykgd2luR2FtZSgpXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIHNwbGFzaCBmb3Iga2lsbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxhc2hBbW91bnQgPSBNYXRoLnJhbmRvbSgpICogMTIgKyA2XG4gICAgICAgICAgICAgICAgICAgIGhpdFNwbGFzaChwcm9qZWN0aWxlLngsIHByb2plY3RpbGUueSwgZW5lbXkuY29sb3IsIHNwbGFzaEFtb3VudCwgc3BsYXNoQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNjb3JlKGVuZW15LnBvaW50cywgcHJvamVjdGlsZSlcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmVteUluZGV4ID0gZW5lbWllcy5maW5kSW5kZXgoZSA9PiBlLmlkID09PSBlbmVteS5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmVteUluZGV4ID49IDApIGVuZW1pZXMuc3BsaWNlKGVuZW15SW5kZXgsIDEpXG4gICAgICAgICAgICAgICAgICAgIH0sIDI1MClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIGNoZWNrIGZvciBjb2xsaXNpb25zIHdpdGggb3RoZXIgZW5lbWllcy4gRm9yIGxvb3AgdG8gbm90IGRvdWJsZSBjb2xsaWRlLlxuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgZW5lbWllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGUgPSBlbmVtaWVzW2ldXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChlbmVteS54IC0gZS54LCBlbmVteS55IC0gZS55KVxuICAgICAgICAgICAgaWYgKGRpc3QgLSBlbmVteS5yYWRpdXMgLSBlLnJhZGl1cyA8IDAuMSAmJiBlbmVteS5yYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbihlLCBlbmVteSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBib3VuY2Ugb2ZmIHdhbGxzXG4gICAgICAgIGNvbnN0IGNvbGxpZGVkV2l0aFggPSBlbmVteS54IC0gZW5lbXkucmFkaXVzICsgZW5lbXkudmVsb2NpdHkueCA8IHRvcExlZnQueCB8fCBlbmVteS54ICsgZW5lbXkucmFkaXVzICsgZW5lbXkudmVsb2NpdHkueCA+IGJvdHRvbVJpZ2h0LnhcbiAgICAgICAgY29uc3QgY29sbGlkZWRXaXRoWSA9IGVuZW15LnkgLSBlbmVteS5yYWRpdXMgKyBlbmVteS52ZWxvY2l0eS55IDwgdG9wTGVmdC55IHx8IGVuZW15LnkgKyBlbmVteS5yYWRpdXMgKyBlbmVteS52ZWxvY2l0eS55ID4gYm90dG9tUmlnaHQueVxuICAgICAgICBpZiAoZW5lbXkuaW5QbGF5KSB7XG4gICAgICAgICAgICBpZiAoY29sbGlkZWRXaXRoWCkge1xuICAgICAgICAgICAgICAgIGVuZW15LnZlbG9jaXR5LnggPSAtZW5lbXkudmVsb2NpdHkueFxuICAgICAgICAgICAgICAgIGlmIChlbmVteS50eXBlID09PSAnb3NjaWxhdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBlbmVteS5kcml2ZS54ID0gLWVuZW15LmRyaXZlLnhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sbGlkZWRXaXRoWSkge1xuICAgICAgICAgICAgICAgIGVuZW15LnZlbG9jaXR5LnkgPSAtZW5lbXkudmVsb2NpdHkueVxuICAgICAgICAgICAgICAgIGlmIChlbmVteS50eXBlID09PSAnb3NjaWxhdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBlbmVteS5kcml2ZS55ID0gLWVuZW15LmRyaXZlLnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmVteS5pblBsYXkgPSAhKGNvbGxpZGVkV2l0aFggfHwgY29sbGlkZWRXaXRoWSlcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvd2VydXBzKCkge1xuICAgIHBvd2VyVXBzLmZvckVhY2goKHBvd2VyVXAsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmh5cG90KHBsYXllci54IC0gcG93ZXJVcC54LCBwbGF5ZXIueSAtIHBvd2VyVXAueSlcbiAgICAgICAgaWYgKGRpc3QgLSBwbGF5ZXIucmFkaXVzIC0gcG93ZXJVcC53aWR0aCAvIDIgPCAxKSB7XG4gICAgICAgICAgICBsZXQgb2J0YWluU291bmQgPSBvYnRhaW5Qb3dlcnVwQXVkaW8uY2xvbmVOb2RlKCkgYXMgSFRNTEF1ZGlvRWxlbWVudFxuICAgICAgICAgICAgb2J0YWluU291bmQucGxheSgpXG4gICAgICAgICAgICBwbGF5ZXIucG93ZXJVcCA9ICdBdXRvbWF0aWMnXG4gICAgICAgICAgICBwbGF5ZXIuY29sb3IgPSAnI0ZGRjUwMCdcbiAgICAgICAgICAgIHBvd2VyVXBzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwb3dlcnVwVGltZW91dClcbiAgICAgICAgICAgIHBvd2VydXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGxheWVyLnBvd2VyVXAgPSAnJ1xuICAgICAgICAgICAgICAgIHBsYXllci5jb2xvciA9ICcjRkZGJ1xuICAgICAgICAgICAgfSwgNTAwMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvd2VyVXAudXBkYXRlKGMpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sbGlkZWRXaXRoWCA9IHBvd2VyVXAueCAtIHBvd2VyVXAud2lkdGggLyAyIDw9IHRvcExlZnQueCB8fCBwb3dlclVwLnggKyBwb3dlclVwLndpZHRoIC8gMiA+PSBib3R0b21SaWdodC54XG4gICAgICAgIGNvbnN0IGNvbGxpZGVkV2l0aFkgPSBwb3dlclVwLnkgLSBwb3dlclVwLmhlaWdodCAvIDMgPD0gdG9wTGVmdC55IHx8IHBvd2VyVXAueSArIHBvd2VyVXAuaGVpZ2h0IC8gMiA+PSBib3R0b21SaWdodC54XG4gICAgICAgIGlmIChwb3dlclVwLmluUGxheSkge1xuICAgICAgICAgICAgaWYgKGNvbGxpZGVkV2l0aFgpIHtcbiAgICAgICAgICAgICAgICBwb3dlclVwLnZlbG9jaXR5LnggPSAtcG93ZXJVcC52ZWxvY2l0eS54XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sbGlkZWRXaXRoWSkge1xuICAgICAgICAgICAgICAgIHBvd2VyVXAudmVsb2NpdHkueSA9IC1wb3dlclVwLnZlbG9jaXR5LnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvd2VyVXAuaW5QbGF5ID0gIShjb2xsaWRlZFdpdGhYIHx8IGNvbGxpZGVkV2l0aFkpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5mdW5jdGlvbiBsaWdodFVwQmFja2dyb3VuZFBhcnRpY2xlcygpIHtcbiAgICBiYWNrZ3JvdW5kUGFydGljbGVzLmZvckVhY2goYnAgPT4ge1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5oeXBvdChwbGF5ZXIueCAtIGJwLngsIHBsYXllci55IC0gYnAueSlcbiAgICAgICAgY29uc3QgaGlkZVJhZGl1cyA9IDEyNVxuICAgICAgICBpZiAoZGlzdCA8IGhpZGVSYWRpdXMpIHtcbiAgICAgICAgICAgIC8vIGhpZGUgY2xvc2UgcGFydGljbGVzLCBpbGx1bWluYXRlIHJhZGl1c1xuICAgICAgICAgICAgYnAuYWxwaGEgPSBkaXN0IDwgNzAgPyAwIDogMC4zNVxuICAgICAgICAgICAgaWYgKCFicC50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgbGl0Q291bnQgKz0gMVxuICAgICAgICAgICAgICAgIGJwLnRvdWNoZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKGxpdENvdW50IC8gcGFydGljbGVDb3VudCA+IDAuNjApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnVubGVhc2goYnAuY29sb3IpXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRQYXJ0aWNsZXMuZm9yRWFjaChicCA9PiBicC50b3VjaCgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicC51cGRhdGUoYylcbiAgICB9KVxufVxuXG4vKipcbiAqIFJvdGF0ZXMgY29vcmRpbmF0ZSBzeXN0ZW0gZm9yIHZlbG9jaXRpZXNcbiAqXG4gKiBUYWtlcyB2ZWxvY2l0aWVzIGFuZCBhbHRlcnMgdGhlbSBhcyBpZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gdGhleSdyZSBvbiB3YXMgcm90YXRlZFxuICpcbiAqIEBwYXJhbSAgT2JqZWN0IHwgdmVsb2NpdHkgfCBUaGUgdmVsb2NpdHkgb2YgYW4gaW5kaXZpZHVhbCBwYXJ0aWNsZVxuICogQHBhcmFtICBGbG9hdCAgfCBhbmdsZSAgICB8IFRoZSBhbmdsZSBvZiBjb2xsaXNpb24gYmV0d2VlbiB0d28gb2JqZWN0cyBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIE9iamVjdCB8IFRoZSBhbHRlcmVkIHggYW5kIHkgdmVsb2NpdGllcyBhZnRlciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gaGFzIGJlZW4gcm90YXRlZFxuICovXG5cbmZ1bmN0aW9uIHJvdGF0ZSh2ZWxvY2l0eSwgYW5nbGUpIHtcbiAgICBjb25zdCByb3RhdGVkVmVsb2NpdGllcyA9IHtcbiAgICAgICAgeDogdmVsb2NpdHkueCAqIE1hdGguY29zKGFuZ2xlKSAtIHZlbG9jaXR5LnkgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIHk6IHZlbG9jaXR5LnggKiBNYXRoLnNpbihhbmdsZSkgKyB2ZWxvY2l0eS55ICogTWF0aC5jb3MoYW5nbGUpXG4gICAgfTtcblxuICAgIHJldHVybiByb3RhdGVkVmVsb2NpdGllcztcbn1cblxuLyoqXG4gKiBTd2FwcyBvdXQgdHdvIGNvbGxpZGluZyBwYXJ0aWNsZXMnIHggYW5kIHkgdmVsb2NpdGllcyBhZnRlciBydW5uaW5nIHRocm91Z2hcbiAqIGFuIGVsYXN0aWMgY29sbGlzaW9uIHJlYWN0aW9uIGVxdWF0aW9uXG4gKlxuICogQHBhcmFtICBPYmplY3QgfCBwYXJ0aWNsZSAgICAgIHwgQSBwYXJ0aWNsZSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLCBwbHVzIHZlbG9jaXR5XG4gKiBAcGFyYW0gIE9iamVjdCB8IG90aGVyUGFydGljbGUgfCBBIHBhcnRpY2xlIG9iamVjdCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMsIHBsdXMgdmVsb2NpdHlcbiAqIEByZXR1cm4gTnVsbCB8IERvZXMgbm90IHJldHVybiBhIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbihwYXJ0aWNsZSwgb3RoZXJQYXJ0aWNsZSkge1xuICAgIGNvbnN0IHhWZWxvY2l0eURpZmYgPSBwYXJ0aWNsZS52ZWxvY2l0eS54IC0gb3RoZXJQYXJ0aWNsZS52ZWxvY2l0eS54O1xuICAgIGNvbnN0IHlWZWxvY2l0eURpZmYgPSBwYXJ0aWNsZS52ZWxvY2l0eS55IC0gb3RoZXJQYXJ0aWNsZS52ZWxvY2l0eS55O1xuXG4gICAgY29uc3QgeERpc3QgPSBvdGhlclBhcnRpY2xlLnggLSBwYXJ0aWNsZS54O1xuICAgIGNvbnN0IHlEaXN0ID0gb3RoZXJQYXJ0aWNsZS55IC0gcGFydGljbGUueTtcbiAgICBkZWJ1Z2dlclxuICAgIC8vIFByZXZlbnQgYWNjaWRlbnRhbCBvdmVybGFwIG9mIHBhcnRpY2xlc1xuICAgIGlmICh4VmVsb2NpdHlEaWZmICogeERpc3QgKyB5VmVsb2NpdHlEaWZmICogeURpc3QgPj0gMCkge1xuXG4gICAgICAgIC8vIEdyYWIgYW5nbGUgYmV0d2VlbiB0aGUgdHdvIGNvbGxpZGluZyBwYXJ0aWNsZXNcbiAgICAgICAgY29uc3QgYW5nbGUgPSAtTWF0aC5hdGFuMihvdGhlclBhcnRpY2xlLnkgLSBwYXJ0aWNsZS55LCBvdGhlclBhcnRpY2xlLnggLSBwYXJ0aWNsZS54KTtcblxuICAgICAgICAvLyBTdG9yZSBtYXNzIGluIHZhciBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5IGluIGNvbGxpc2lvbiBlcXVhdGlvblxuICAgICAgICAvLyBhc3N1bWVzIHJhZGl1cyBhbHdheXMgZXF1YWwgbWFzc1xuICAgICAgICBjb25zdCBtMSA9IHBhcnRpY2xlLnJhZGl1cztcbiAgICAgICAgY29uc3QgbTIgPSBvdGhlclBhcnRpY2xlLnJhZGl1cztcblxuICAgICAgICAvLyBWZWxvY2l0eSBiZWZvcmUgZXF1YXRpb25cbiAgICAgICAgY29uc3QgdTEgPSByb3RhdGUocGFydGljbGUudmVsb2NpdHksIGFuZ2xlKTtcbiAgICAgICAgY29uc3QgdTIgPSByb3RhdGUob3RoZXJQYXJ0aWNsZS52ZWxvY2l0eSwgYW5nbGUpO1xuXG4gICAgICAgIC8vIFZlbG9jaXR5IGFmdGVyIDFkIGNvbGxpc2lvbiBlcXVhdGlvblxuICAgICAgICBjb25zdCB2MSA9IHsgeDogdTEueCAqIChtMSAtIG0yKSAvIChtMSArIG0yKSArIHUyLnggKiAyICogbTIgLyAobTEgKyBtMiksIHk6IHUxLnkgfTtcbiAgICAgICAgY29uc3QgdjIgPSB7IHg6IHUyLnggKiAobTEgLSBtMikgLyAobTEgKyBtMikgKyB1MS54ICogMiAqIG0yIC8gKG0xICsgbTIpLCB5OiB1Mi55IH07XG5cbiAgICAgICAgLy8gRmluYWwgdmVsb2NpdHkgYWZ0ZXIgcm90YXRpbmcgYXhpcyBiYWNrIHRvIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgIGNvbnN0IHZGaW5hbDEgPSByb3RhdGUodjEsIC1hbmdsZSk7XG4gICAgICAgIGNvbnN0IHZGaW5hbDIgPSByb3RhdGUodjIsIC1hbmdsZSk7XG5cbiAgICAgICAgLy8gU3dhcCBwYXJ0aWNsZSB2ZWxvY2l0aWVzIGZvciByZWFsaXN0aWMgYm91bmNlIGVmZmVjdFxuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS54ID0gdkZpbmFsMS54O1xuICAgICAgICBwYXJ0aWNsZS52ZWxvY2l0eS55ID0gdkZpbmFsMS55O1xuXG4gICAgICAgIG90aGVyUGFydGljbGUudmVsb2NpdHkueCA9IHZGaW5hbDIueDtcbiAgICAgICAgb3RoZXJQYXJ0aWNsZS52ZWxvY2l0eS55ID0gdkZpbmFsMi55O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkU2NvcmUoYmFzZVBvaW50czogbnVtYmVyLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKSB7XG4gICAgbGV0IG11bHRpcGxpZXIgPSAxICsgY29tYm8gLyAxMFxuICAgIGNvbnN0IHBvaW50cyA9IChiYXNlUG9pbnRzICogbXVsdGlwbGllcikgfCAwIC8vIGJpdHdpc2Ugb3IgMCBjYXN0cyB0byBpbnRcbiAgICBzY29yZSArPSBwb2ludHNcbiAgICBzY29yZUVsLmlubmVySFRNTCA9IHNjb3JlLnRvU3RyaW5nKClcbiAgICBjcmVhdGVTY29yZUxhYmVsKHByb2plY3RpbGUsIHBvaW50cylcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NvcmVMYWJlbChwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBzY29yZTogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2NvcmVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICBzY29yZUxhYmVsLmlubmVySFRNTCA9IHNjb3JlLnRvU3RyaW5nKClcbiAgICBzY29yZUxhYmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHNjb3JlTGFiZWwuc3R5bGUuY29sb3IgPSAnd2hpdGUnXG4gICAgc2NvcmVMYWJlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnXG4gICAgc2NvcmVMYWJlbC5zdHlsZS5sZWZ0ID0gcHJvamVjdGlsZS54ICsgJ3B4J1xuICAgIHNjb3JlTGFiZWwuc3R5bGUudG9wID0gcHJvamVjdGlsZS55ICsgJ3B4J1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NvcmVMYWJlbClcbiAgICBnc2FwLnRvKHNjb3JlTGFiZWwsIHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgeTogLTMwLFxuICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgc2NvcmVMYWJlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjb3JlTGFiZWwpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5mdW5jdGlvbiBzcGF3bkVuZW15KGxldmVsOiBudW1iZXIpIHtcbiAgICBlbmVtaWVzLnB1c2gobmV3IEVuZW15KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgbGV2ZWwpKVxufVxuXG5mdW5jdGlvbiBzcGF3bkJvc3MoKSB7XG4gICAgc2NlbmUuYm9zcyA9IHRydWVcbiAgICBnc2FwLnRvKGJhY2tncm91bmRNdXNpYywge1xuICAgICAgICB2b2x1bWU6IDAuMCxcbiAgICAgICAgZHVyYXRpb246IDYsXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRNdXNpYy5zcmMgPSBhbGJhdHJvc3NTb25nVVJMXG4gICAgICAgICAgICBiYWNrZ3JvdW5kTXVzaWMuY3VycmVudFRpbWUgPSAwXG4gICAgICAgICAgICBiYWNrZ3JvdW5kTXVzaWMucGF1c2UoKVxuICAgICAgICB9XG4gICAgfSlcbiAgICBzZXRUaW1lb3V0KCgpID0+IGFsYXJtQXVkaW8ucGxheSgpLCAyMDAwKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBnc2FwLnRvKGFsYXJtQXVkaW8ucGxheSgpLCB7XG4gICAgICAgICAgICB2b2x1bWU6IDAuMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA0LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFsYXJtQXVkaW8ucGF1c2UoKVxuICAgICAgICAgICAgICAgIGFsYXJtQXVkaW8uY3VycmVudFRpbWUgPSAyXG4gICAgICAgICAgICAgICAgYWxhcm1BdWRpby52b2x1bWUgPSAxLjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9LCA2MDAwKVxuICAgIHNldFRpbWVvdXQoKCkgPT4gYm9zc011c2ljLnBsYXkoKSwgMTAwMDApXG4gICAgbGV0IHB1c2hCb3NzID0gKCkgPT4gZW5lbWllcy5wdXNoKG5ldyBCb3NzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkpXG4gICAgc2V0VGltZW91dChwdXNoQm9zcywgMTEwMDApXG59XG5cbmZ1bmN0aW9uIHNwYXduRW5lbWllcyhsZXZlbDogbnVtYmVyKSB7XG4gICAgc3Bhd25FbmVteSgxKVxuICAgIGlmIChsZXZlbCA+IDEpIHNwYXduRW5lbXkoMSlcbiAgICBpZiAobGV2ZWwgPiAyKSBzcGF3bkVuZW15KDIpXG4gICAgaWYgKGxldmVsID4gMykgc3Bhd25FbmVteSgzKVxuICAgIGlmIChsZXZlbCA+IDQgJiYgIXNjZW5lLmJvc3MpIHNwYXduQm9zcygpXG59XG5cbmZ1bmN0aW9uIHNldExldmVsKHNjb3JlOiBudW1iZXIpIHtcbiAgICBpZiAoc2NvcmUgPiA1MDAwKSBsZXZlbCA9IDJcbiAgICBpZiAoc2NvcmUgPiAxMDAwMCkgbGV2ZWwgPSAzXG4gICAgaWYgKHNjb3JlID4gMjUwMDApIGxldmVsID0gNFxuICAgIGlmIChzY29yZSA+IDUwMDAwKSBsZXZlbCA9IDVcbiAgICBpZiAoc2NvcmUgPiAyNTAwMDApIGxldmVsID0gNlxuICAgIGlmIChzY29yZSA+IDEwMDAwMDApIGxldmVsID0gN1xuICAgIGxldmVsRWwuaW5uZXJIVE1MID0gbGV2ZWwudG9TdHJpbmcoKVxufVxuXG5mdW5jdGlvbiBzcGF3blBvd2VyVXAoKSB7XG4gICAgcG93ZXJVcHMucHVzaChuZXcgUG93ZXJVcChjYW52YXMpKVxufVxuXG5mdW5jdGlvbiBlbmRHYW1lKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKVxuICAgIG1vZGFsRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgIGJpZ1Njb3JlRWwuaW5uZXJIVE1MID0gc2NvcmUudG9TdHJpbmcoKVxuICAgIGVuZEdhbWVBdWRpby5wbGF5KClcbiAgICBzY2VuZS5hY3RpdmUgPSBmYWxzZVxuICAgIGdzYXAudG8oJyN3aGl0ZU1vZGFsRWwnLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBkdXJhdGlvbjogMC4zNSxcbiAgICB9KVxuICAgIHBvc3RFdmVudCgnZ2FtZSBsb3N0JywgZW5kU3RhdHMoKSlcbn1cblxuZnVuY3Rpb24gd2luR2FtZSgpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZClcbiAgICBtb2RhbEVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICBiaWdTY29yZUVsLmlubmVySFRNTCA9IHNjb3JlLnRvU3RyaW5nKClcbiAgICBiYWNrZ3JvdW5kTXVzaWMuc3JjID0gdmljdG9yeU11c2ljVVJMXG4gICAgYmFja2dyb3VuZE11c2ljLmxvYWQoKVxuICAgIGJhY2tncm91bmRNdXNpYy5wbGF5KClcbiAgICB3aW5Tb3VuZC5wbGF5KClcbiAgICB2aWN0b3J5U29uZy5wbGF5KClcbiAgICBzY2VuZS5hY3RpdmUgPSBmYWxzZVxuICAgIHZpY3RvcnlFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIGJpZ1Njb3JlRWwuaW5uZXJIVE1MID0gc2NvcmUudG9TdHJpbmcoKVxuICAgIGxvbmdDb21ib0VsLmlubmVySFRNTCA9IGxvbmdlc3RDb21iby50b1N0cmluZygpXG4gICAgLy8gbWVzc2V5IHdheSB0byBkbyB0aW1lICsgZG9lc24ndCBoYW5kbGUgaG91cisgdGltZVxuICAgIGxldCBwbGF5VGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICBjb25zdCB0aW1lU3RyaW5nID0gYCR7bmV3IERhdGUocGxheVRpbWUpLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDE0LCA4KX1gXG4gICAgcnVudGltZUVsLmlubmVySFRNTCA9IHRpbWVTdHJpbmdcblxuICAgIC8vIGlkZWEgdG8gYW5pbWF0ZSB3aGVuIHBsYXllciB3aW5zXG4gICAgLy8gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIC8vICAgICBoaXRTcGxhc2goTWF0aC5yYW5kb20oKSAqIGJvdHRvbVJpZ2h0LngsIE1hdGgucmFuZG9tKCkgKiBib3R0b21SaWdodC55LCAnaXZvcnknLCAyNCwgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyKVxuICAgIC8vIH0sIDI1MClcblxuICAgIGdzYXAudG8oYm9zc011c2ljLCB7XG4gICAgICAgIHZvbHVtZTogMC4wLFxuICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgYm9zc011c2ljLnBhdXNlKClcbiAgICAgICAgICAgIGJvc3NNdXNpYy52b2x1bWUgPSAxXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHNjZW5lLmFjdGl2ZSA9IGZhbHNlXG4gICAgZ3NhcC50bygnI3doaXRlTW9kYWxFbCcsIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjM1LFxuICAgIH0pXG4gICAgcG9zdEV2ZW50KCdnYW1lIHdvbicsIGVuZFN0YXRzKCkpXG59XG5cblxuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyByZW1vdmUgZmFkZWQgcGFydGljbGVzXG4gICAgcGFydGljbGVzLmZvckVhY2goKHAsIGkpID0+IHAuYWxwaGEgPD0gMCA/IHBhcnRpY2xlcy5zcGxpY2UoaSwgMSkgOiBwLnVwZGF0ZShjKSlcbiAgICAvLyByZW1vdmUgcHJvamVjdGlsZXMgb3V0IG9mIGJvdW5kc1xuICAgIHByb2plY3RpbGVzLmZvckVhY2goKHByb2plY3RpbGUsIGluZGV4KSA9PiB7XG4gICAgICAgIHByb2plY3RpbGUudXBkYXRlKGMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb2plY3RpbGUueCArIHByb2plY3RpbGUucmFkaXVzIDwgMCB8fFxuICAgICAgICAgICAgcHJvamVjdGlsZS54IC0gcHJvamVjdGlsZS5yYWRpdXMgPiBjYW52YXMud2lkdGggfHxcbiAgICAgICAgICAgIHByb2plY3RpbGUueSArIHByb2plY3RpbGUucmFkaXVzIDwgMCB8fFxuICAgICAgICAgICAgcHJvamVjdGlsZS55IC0gcHJvamVjdGlsZS5yYWRpdXMgPiBjYW52YXMuaGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcm9qZWN0aWxlcy5zcGxpY2UoaW5kZXgsIDEpLCAwKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gaGl0U3BsYXNoKHg6IG51bWJlciwgeTogbnVtYmVyLCBjb2xvcjogc3RyaW5nLCBhbW91bnQ6IG51bWJlciwgYW5nbGU6IG51bWJlcikge1xuICAgIC8vIHBhcnRpY2xlcyBzaG91bGQgYmUgYmlhcyB0byBicmVhayBhd2F5IGZyb20gZW5lbXlcbiAgICBjb25zdCB4QmlhcyA9IE1hdGguY29zKGFuZ2xlKSAqIDEuMVxuICAgIGNvbnN0IHlCaWFzID0gTWF0aC5zaW4oYW5nbGUpICogMS4xXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgICBwYXJ0aWNsZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQYXJ0aWNsZShcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDIsXG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKyB4QmlhcyxcbiAgICAgICAgICAgICAgICAgICAgeTogKE1hdGgucmFuZG9tKCkgLSAwLjUpICsgeUJpYXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRpbnVlQ29tYm8oKSB7XG4gICAgbGV0IGRlc3Ryb3lTb3VuZCA9IGRlc3Ryb3lFbmVteS5jbG9uZU5vZGUoKSBhcyBIVE1MQXVkaW9FbGVtZW50XG4gICAgZGVzdHJveVNvdW5kLnZvbHVtZSA9IDAuNzVcbiAgICBkZXN0cm95U291bmQucGxheSgpXG4gICAgY29tYm8gKz0gMVxuICAgIGxvbmdlc3RDb21ibyA9IGxvbmdlc3RDb21ibyA+IGNvbWJvID8gbG9uZ2VzdENvbWJvIDogY29tYm9cbiAgICBjb21ib0VsLmlubmVySFRNTCA9IGNvbWJvLnRvU3RyaW5nKClcbn1cblxuZnVuY3Rpb24gYnJlYWtDb21ibyhlbmVteTogRW5lbXkpIHtcbiAgICBjb25zdCBicmVha1NvdW5kID0gY29tYm9CcmVhay5jbG9uZU5vZGUoKSBhcyBIVE1MQXVkaW9FbGVtZW50XG4gICAgYnJlYWtTb3VuZC52b2x1bWUgPSAwLjMzXG4gICAgYnJlYWtTb3VuZC5wbGF5KClcbiAgICBwbGF5ZXIubGVhc2goKVxuICAgIGJhY2tncm91bmRQYXJ0aWNsZXMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5jb2xvciA9IGVuZW15LmNvbG9yXG4gICAgICAgIGdzYXAudG8ocCwge1xuICAgICAgICAgICAgYWxwaGE6IDAuMTUsXG4gICAgICAgICAgICBkdXJhdGlvbjogMC4wMyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBnc2FwLnRvKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGE6IHAuaW5pdGlhbEFscGhhLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAuMDNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG4gICAgY29tYm8gPSAwXG4gICAgY29tYm9FbC5pbm5lckhUTUwgPSBjb21iby50b1N0cmluZygpXG4gICAgbGl0Q291bnQgPSAwXG4gICAgc2NlbmUuY29sb3IgPSBlbmVteS5jb2xvclxufVxuXG4vLyBVc2VyIGlucHV0XG5zdGFydEdhbWVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICBpbml0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHNjb3JlRWwuaW5uZXJIVE1MID0gc2NvcmUudG9TdHJpbmcoKVxuICAgIGJpZ1Njb3JlRWwuaW5uZXJIVE1MID0gc2NvcmUudG9TdHJpbmcoKVxuICAgIHNjZW5lLmFjdGl2ZSA9IHRydWVcbiAgICBnc2FwLnRvKCcjd2hpdGVNb2RhbEVsJywge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZTogMC43NSxcbiAgICAgICAgZWFzZTogJ2V4cG8nLFxuICAgICAgICBkdXJhdGlvbjogMC4yNSxcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4gbW9kYWxFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgfSlcbiAgICBzdGFydEdhbWVBdWRpby5wbGF5KClcbiAgICBiYWNrZ3JvdW5kTXVzaWMucGxheSgpXG4gICAgYW5pbWF0ZSgpXG4gICAgcG9zdEV2ZW50KCdnYW1lIHN0YXJ0ZWQnLCB7IFwid2lkdGhcIjogYm90dG9tUmlnaHQueCwgXCJoZWlnaHRcIjogYm90dG9tUmlnaHQueSB9KVxufSlcblxuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKHsgY2xpZW50WCwgY2xpZW50WSB9KSA9PiB7XG4gICAgbW91c2UuZG93biA9IHRydWVcbiAgICBtb3VzZS54ID0gY2xpZW50WFxuICAgIG1vdXNlLnkgPSBjbGllbnRZXG59KVxuXG5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoeyBjbGllbnRYLCBjbGllbnRZIH0pID0+IHtcbiAgICBtb3VzZS54ID0gY2xpZW50WFxuICAgIG1vdXNlLnkgPSBjbGllbnRZXG59KVxuXG5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgIG1vdXNlLmRvd24gPSBmYWxzZVxufSlcblxuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChldmVudCkgPT4ge1xuICAgIG1vdXNlLmRvd24gPSB0cnVlXG4gICAgbW91c2UueCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WFxuICAgIG1vdXNlLnkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFlcbn0pXG5cbmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChldmVudCkgPT4ge1xuICAgIG1vdXNlLnggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFhcbiAgICBtb3VzZS55ID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXG59KVxuXG5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHtcbiAgICBtb3VzZS5kb3duID0gZmFsc2Vcbn0pXG5cbmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgbW91c2UueCA9IGV2ZW50LmNsaWVudFhcbiAgICBtb3VzZS55ID0gZXZlbnQuY2xpZW50WVxuICAgIGlmIChzY2VuZS5hY3RpdmUpIHByb2plY3RpbGVzLnB1c2gocGxheWVyLnNob290KG1vdXNlKSlcbn0pXG5cbmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICBjYW52YXMud2lkdGggPSBpbm5lcldpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGlubmVySGVpZ2h0XG4gICAgaW5pdCgpXG59KVxuXG5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKHsgY29kZSB9KSA9PiB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJ0tleVcnOiBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIGtleXMudXAgPSB0cnVlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdLZXlBJzogY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIGtleXMubGVmdCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ0tleVMnOiBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAga2V5cy5kb3duID0gdHJ1ZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnS2V5RCc6IGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAga2V5cy5yaWdodCA9IHRydWVcbiAgICAgICAgICAgIGJyZWFrXG4gICAgfVxufSlcblxuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoeyBjb2RlIH0pID0+IHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAnS2V5Vyc6IGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAga2V5cy51cCA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdLZXlBJzogY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIGtleXMubGVmdCA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdLZXlTJzogY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgIGtleXMuZG93biA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdLZXlEJzogY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICBrZXlzLnJpZ2h0ID0gZmFsc2VcbiAgICAgICAgICAgIGJyZWFrXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZW5kU3RhdHMoKSB7XG4gICAgbGV0IHBsYXlUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgIGNvbnN0IHRpbWVTdHJpbmcgPSBgJHtuZXcgRGF0ZShwbGF5VGltZSkudG9JU09TdHJpbmcoKS5zdWJzdHIoMTQsIDgpfWBcbiAgICByZXR1cm4ge1xuICAgICAgICAnc2NvcmUnOiBzY29yZSxcbiAgICAgICAgJ3BsYXlUaW1lJzogdGltZVN0cmluZyxcbiAgICAgICAgJ2xvbmdlc3RDb21ibyc6IGxvbmdlc3RDb21ib1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9zdEV2ZW50KG5hbWU6IHN0cmluZywgcGF5bG9hZDogb2JqZWN0KSB7XG4gICAgaWYgKGVuYWJsZU1peHBhbmVsKSB7XG4gICAgICAgIG1peHBhbmVsLnRyYWNrKG5hbWUsIHBheWxvYWQpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RldiB0cmFja2luZzogJywgbmFtZSwgcGF5bG9hZClcbiAgICB9XG59IiwiaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCdcbmV4cG9ydCB7XG4gICAgRW5lbXksXG4gICAgQm9zc1xufVxuXG5jb25zdCBtaW5FbmVteVNpemUgPSAxNVxuY29uc3QgZW5lbXlIaXRBdWRpbyA9IG5ldyBBdWRpbygnLi9hdWRpby9oaXQubXAzJylcbmNvbnN0IGVuZW15Q29sb3JzID0gW1xuICAgIGBoc2woMCwgNzAlLCAzMCUpYCxcbiAgICBgaHNsKDkwLCA3MCUsIDMwJSlgLFxuICAgIGBoc2woMjIwLCA3MCUsIDMwJSlgLFxuICAgIGBoc2woMzYsIDkwJSwgMzAlKWBcbl1cblxuY29uc3QgcmFuZG9tQ29sb3IgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGVuZW15Q29sb3JzW01hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiBlbmVteUNvbG9ycy5sZW5ndGgpKV1cbn1cbmNvbnN0IG9zY2lsYXRvclBhZGRpbmcgPSA3NSAvLyBkb250IHNwYXduIG9zY2lsYXRvcnMgb24gZWRnZXNcbmxldCBpZCA9IDFcbmNsYXNzIEVuZW15IHtcbiAgICBwdWJsaWMgaWQ6IG51bWJlclxuICAgIHByaXZhdGUgeDogbnVtYmVyXG4gICAgcHJpdmF0ZSB5OiBudW1iZXJcbiAgICBwdWJsaWMgcG9pbnRzOiBudW1iZXJcbiAgICBwdWJsaWMgcmFkaXVzOiBudW1iZXJcbiAgICBwcml2YXRlIGRyYXdSYWRpdXM6IG51bWJlclxuICAgIHB1YmxpYyBjb2xvcjogc3RyaW5nXG4gICAgcHVibGljIGluUGxheTogYm9vbGVhblxuICAgIHB1YmxpYyBpc0Jvc3M6IGJvb2xlYW5cbiAgICBwcml2YXRlIHR5cGU6IHN0cmluZ1xuICAgIHByaXZhdGUgcmFkaWFuczogbnVtYmVyXG4gICAgcHJpdmF0ZSBjZW50ZXI6IFZlbG9jaXR5IC8vIHByb2JhYmx5IG5lZWQgdG8gcmVuYW1lIHRoaXMgLyBuZXcgdHlwZVxuICAgIHByaXZhdGUgYmFzZVNwZWVkOiBudW1iZXJcbiAgICBwcml2YXRlIHNwaW5SYWRpdXM6IG51bWJlclxuICAgIHByaXZhdGUgc3BpblJhdGU6IG51bWJlclxuICAgIHByaXZhdGUgdmVsb2NpdHk6IFZlbG9jaXR5XG4gICAgcHJpdmF0ZSBhbHBoYTogbnVtYmVyXG4gICAgcHJpdmF0ZSBmcmljdGlvbjogbnVtYmVyXG4gICAgcHJpdmF0ZSBkcml2ZTogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9XG4gICAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGxldmVsOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5yYW5kb20oKSAqICg2MCAtIDEwKSArIDEwXG5cbiAgICAgICAgdGhpcy5pZCA9IGlkKytcbiAgICAgICAgdGhpcy5wb2ludHMgPSAyMDAgKyBsZXZlbCAqIDUwXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzICsgbGV2ZWwgKiAxMFxuICAgICAgICB0aGlzLmRyYXdSYWRpdXMgPSB0aGlzLnJhZGl1c1xuICAgICAgICB0aGlzLnNwaW5SYWRpdXMgPSBNYXRoLm1heCgzMCwgTWF0aC5yYW5kb20oKSAqIDEwMClcbiAgICAgICAgdGhpcy5zcGluUmF0ZSA9IDAuMDVcbiAgICAgICAgdGhpcy5jb2xvciA9IHJhbmRvbUNvbG9yKClcbiAgICAgICAgdGhpcy50eXBlID0gJ2hvbWluZydcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB7IHg6IHRoaXMueCwgeTogdGhpcy55IH1cbiAgICAgICAgdGhpcy5yYWRpYW5zID0gMFxuICAgICAgICB0aGlzLmJhc2VTcGVlZCA9IDAuNzUgKyAobGV2ZWwgKiAwLjE1KSArIChNYXRoLnJhbmRvbSgpICogMC4xNSlcbiAgICAgICAgdGhpcy5hbHBoYSA9IDFcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IDAuOTVcbiAgICAgICAgdGhpcy5pblBsYXkgPSBmYWxzZVxuICAgICAgICB0aGlzLmlzQm9zcyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZHJpdmUgPSB7IHg6IDAsIHk6IDAgfVxuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuNDApIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnXG4gICAgICAgICAgICBpZihNYXRoLnJhbmRvbSgpIDwgMC42MCAmJiBsZXZlbCA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnb3NjaWxhdG9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICB0aGlzLnggPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gMCAtIHJhZGl1cyA6IHdpZHRoICsgcmFkaXVzXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnb3NjaWxhdG9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJpdmUueCA9IHRoaXMueCA8IDAgPyB0aGlzLmJhc2VTcGVlZCA6IC10aGlzLmJhc2VTcGVlZFxuICAgICAgICAgICAgICAgIHRoaXMuZHJpdmUueCAqPSAwLjI1XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy55IC0gb3NjaWxhdG9yUGFkZGluZyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICs9IG9zY2lsYXRvclBhZGRpbmcgKyB0aGlzLnJhZGl1c1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy55ICsgb3NjaWxhdG9yUGFkZGluZyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgLT0gb3NjaWxhdG9yUGFkZGluZyArIHRoaXMucmFkaXVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54ID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodFxuICAgICAgICAgICAgdGhpcy55ID0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IDAgLSByYWRpdXMgOiBoZWlnaHQgKyByYWRpdXNcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdvc2NpbGF0b3InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcml2ZS55ID0gdGhpcy55IDwgMCA/IHRoaXMuYmFzZVNwZWVkIDogLXRoaXMuYmFzZVNwZWVkXG4gICAgICAgICAgICAgICAgdGhpcy5kcml2ZS55ICo9IDAuMjVcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnggLSBvc2NpbGF0b3JQYWRkaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0gb3NjaWxhdG9yUGFkZGluZyArIHRoaXMucmFkaXVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnggKyBvc2NpbGF0b3JQYWRkaW5nID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54IC09IG9zY2lsYXRvclBhZGRpbmcgKyB0aGlzLnJhZGl1c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoaGVpZ2h0IC8gMiAtIHRoaXMueSwgd2lkdGggLyAyIC0gdGhpcy54KVxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHRoaXMuYmFzZVNwZWVkKjMsXG4gICAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiB0aGlzLmJhc2VTcGVlZCozXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ29zY2lsYXRvcicpIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eVxuICAgIH1cblxuICAgIGRyYXcoYzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICAgIGMuYmVnaW5QYXRoKClcbiAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuZHJhd1JhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKVxuICAgICAgICBjLmZpbGxTdHlsZSA9IHRoaXMuY29sb3JcbiAgICAgICAgaWYgKHRoaXMuYWxwaGEgPT09IDEpIHtcbiAgICAgICAgICAgIGMuZmlsbCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnNhdmUoKVxuICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IHRoaXMuYWxwaGFcbiAgICAgICAgICAgIGMuZmlsbCgpXG4gICAgICAgICAgICBjLnJlc3RvcmUoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKGM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgdGFyZ2V0WDogbnVtYmVyLCB0YXJnZXRZOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5kcmF3KGMpXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxvY2l0eS54XG4gICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxvY2l0eS55XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAnb3NjaWxhdG9yJykge1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgICAgICB4OiAodGhpcy52ZWxvY2l0eS54ICogdGhpcy5mcmljdGlvbikgKyB0aGlzLmRyaXZlLngsXG4gICAgICAgICAgICAgICAgeTogKHRoaXMudmVsb2NpdHkueSAqIHRoaXMuZnJpY3Rpb24pICsgdGhpcy5kcml2ZS55LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsb2NpdHkueFxuICAgICAgICAgICAgdGhpcy55ICs9IHRoaXMudmVsb2NpdHkueVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2hvbWluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih0YXJnZXRZIC0gdGhpcy55LCB0YXJnZXRYIC0gdGhpcy54KVxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgICAgICB4OiAodGhpcy52ZWxvY2l0eS54ICogdGhpcy5mcmljdGlvbikgKyAoTWF0aC5jb3MoYW5nbGUpICogdGhpcy5iYXNlU3BlZWQpICogMC4yLFxuICAgICAgICAgICAgICAgIHk6ICh0aGlzLnZlbG9jaXR5LnkgKiB0aGlzLmZyaWN0aW9uKSArIChNYXRoLnNpbihhbmdsZSkgKiB0aGlzLmJhc2VTcGVlZCkgKiAwLjJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnZlbG9jaXR5LnhcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbG9jaXR5LnlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdzcGlubmluZycpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaWFucyArPSB0aGlzLnNwaW5SYXRlXG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIodGFyZ2V0WSAtIHRoaXMueSwgdGFyZ2V0WCAtIHRoaXMueClcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICAgICAgICAgICAgeDogKHRoaXMudmVsb2NpdHkueCAqIHRoaXMuZnJpY3Rpb24pICsgKE1hdGguY29zKGFuZ2xlKSAqIHRoaXMuYmFzZVNwZWVkKSAqIDAuMSxcbiAgICAgICAgICAgICAgICB5OiAodGhpcy52ZWxvY2l0eS55ICogdGhpcy5mcmljdGlvbikgKyAoTWF0aC5zaW4oYW5nbGUpICogdGhpcy5iYXNlU3BlZWQpICogMC4xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNlbnRlci54ICs9IHRoaXMudmVsb2NpdHkueFxuICAgICAgICAgICAgdGhpcy5jZW50ZXIueSArPSB0aGlzLnZlbG9jaXR5LnlcblxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5jZW50ZXIueCArIE1hdGguY29zKHRoaXMucmFkaWFucykgKiB0aGlzLnNwaW5SYWRpdXNcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuY2VudGVyLnkgKyBNYXRoLnNpbih0aGlzLnJhZGlhbnMpICogdGhpcy5zcGluUmFkaXVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoaXQoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgaGl0U291bmQgPSBlbmVteUhpdEF1ZGlvLmNsb25lTm9kZSgpIGFzIEhUTUxBdWRpb0VsZW1lbnRcbiAgICAgICAgaGl0U291bmQudm9sdW1lID0gMC4zM1xuICAgICAgICBoaXRTb3VuZC5wbGF5KClcbiAgICAgICAgdGhpcy5yYWRpdXMgLT0gYW1vdW50XG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA+IG1pbkVuZW15U2l6ZSkge1xuICAgICAgICAgICAgZ3NhcC50byh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZHJhd1JhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAuM1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnc2FwLnRvKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBhbHBoYTogMC4wLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjIwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEJvc3Mge1xuICAgIHByaXZhdGUgeDogbnVtYmVyXG4gICAgcHJpdmF0ZSB5OiBudW1iZXJcbiAgICBwdWJsaWMgcG9pbnRzOiBudW1iZXJcbiAgICBwdWJsaWMgcmFkaXVzOiBudW1iZXJcbiAgICBwdWJsaWMgaXNCb3NzOiB0cnVlXG4gICAgcHJpdmF0ZSBiYXNlU3BlZWQ6IG51bWJlclxuICAgIHByaXZhdGUgY29sb3I6IHN0cmluZ1xuICAgIHByaXZhdGUgdmVsb2NpdHk6IFZlbG9jaXR5XG4gICAgcHJpdmF0ZSBmcmFtZTogbnVtYmVyXG4gICAgcHJpdmF0ZSBkcmF3UmFkaXVzOiBudW1iZXJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDI1MFxuICAgICAgICB0aGlzLmRyYXdSYWRpdXMgPSAyNTBcbiAgICAgICAgdGhpcy5iYXNlU3BlZWQgPSAxLjJcbiAgICAgICAgdGhpcy5wb2ludHMgPSAxMDAwMFxuICAgICAgICB0aGlzLmZyYW1lID0gMFxuICAgICAgICB0aGlzLmlzQm9zcyA9IHRydWVcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAwIC0gdGhpcy5yYWRpdXMgOiB3aWR0aCArIHRoaXMucmFkaXVzXG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnggPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gMCAtIHRoaXMucmFkaXVzIDogaGVpZ2h0ICsgdGhpcy5yYWRpdXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXcoYzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICAgIGMuYmVnaW5QYXRoKClcbiAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuZHJhd1JhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKVxuICAgICAgICBjLmZpbGxTdHlsZSA9IHRoaXMuY29sb3JcbiAgICAgICAgYy5maWxsKClcbiAgICAgICAgYy5zdHJva2UoKVxuICAgIH1cblxuICAgIHVwZGF0ZShjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHRhcmdldFg6IG51bWJlciwgdGFyZ2V0WTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZHJhdyhjKVxuICAgICAgICB0aGlzLmZyYW1lKytcbiAgICAgICAgbGV0IGggPSB0aGlzLmZyYW1lICUgMzYwXG4gICAgICAgIGxldCBzID0gKHRoaXMuZnJhbWUgJSAyMCkgKyA0MFxuICAgICAgICB0aGlzLmNvbG9yID0gYGhzbCgke2h9ZGVnLCR7c30lLDUwJSlgXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih0YXJnZXRZIC0gdGhpcy55LCB0YXJnZXRYIC0gdGhpcy54KVxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0ge1xuICAgICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogdGhpcy5iYXNlU3BlZWQsXG4gICAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiB0aGlzLmJhc2VTcGVlZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMueCArPSB0aGlzLnZlbG9jaXR5LnhcbiAgICAgICAgdGhpcy55ICs9IHRoaXMudmVsb2NpdHkueVxuICAgIH1cblxuICAgIGhpdChhbW91bnQ6IG51bWJlcikge1xuICAgICAgICAvLyBib3NzIG9ubHkgdGFrZSBvbmUgZGFtYWdlXG4gICAgICAgIGNvbnN0IGhpdFNvdW5kID0gZW5lbXlIaXRBdWRpby5jbG9uZU5vZGUoKSBhcyBIVE1MQXVkaW9FbGVtZW50XG4gICAgICAgIGhpdFNvdW5kLnZvbHVtZSA9IDAuNTBcbiAgICAgICAgaGl0U291bmQucGxheSgpXG4gICAgICAgIHRoaXMucmFkaXVzIC09IDFcbiAgICAgICAgaWYgKHRoaXMucmFkaXVzID4gbWluRW5lbXlTaXplKSB7XG4gICAgICAgICAgICBnc2FwLnRvKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBkcmF3UmFkaXVzOiB0aGlzLnJhZGl1c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnc2FwLnRvKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBhbHBoYTogMC4wLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjIwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IHsgUHJvamVjdGlsZSwgUGFydGljbGUsIEJhY2tncm91bmRQYXJ0aWNsZSB9XG5cbmNsYXNzIFByb2plY3RpbGUge1xuICAgIHB1YmxpYyB4OiBudW1iZXJcbiAgICBwdWJsaWMgeTogbnVtYmVyXG4gICAgcHVibGljIHJhZGl1czogbnVtYmVyXG4gICAgcHVibGljIGNvbG9yOiBzdHJpbmdcbiAgICBwdWJsaWMgcG93ZXI6IG51bWJlclxuICAgIHByaXZhdGUgdmVsb2NpdHk6IFZlbG9jaXR5XG4gICAgY29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCBjb2xvcjogc3RyaW5nLCB2ZWxvY2l0eTogVmVsb2NpdHksIHBvd2VyOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy54ID0geFxuICAgICAgICB0aGlzLnkgPSB5XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHlcbiAgICAgICAgdGhpcy5wb3dlciA9IHBvd2VyXG4gICAgfVxuXG4gICAgZHJhdyhjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICAgICAgYy5iZWdpblBhdGgoKVxuICAgICAgICBjLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSlcbiAgICAgICAgYy5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGMuZmlsbCgpXG4gICAgICAgIGMucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgdXBkYXRlKGM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgICAgICB0aGlzLmRyYXcoYylcbiAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsb2NpdHkueFxuICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxvY2l0eS55XG4gICAgfVxufVxuXG5jbGFzcyBQYXJ0aWNsZSB7XG4gICAgcHJpdmF0ZSB4OiBudW1iZXJcbiAgICBwcml2YXRlIHk6IG51bWJlclxuICAgIHByaXZhdGUgcmFkaXVzOiBudW1iZXJcbiAgICBwdWJsaWMgY29sb3I6IHN0cmluZ1xuICAgIHB1YmxpYyBhbHBoYTogbnVtYmVyXG4gICAgcHJpdmF0ZSB2ZWxvY2l0eTogVmVsb2NpdHlcbiAgICBwcml2YXRlIGZyaWN0aW9uOiBudW1iZXJcbiAgICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgcmFkaXVzOiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIHZlbG9jaXR5OiBWZWxvY2l0eSkge1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXNcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eVxuICAgICAgICB0aGlzLmFscGhhID0gMVxuICAgICAgICB0aGlzLmZyaWN0aW9uID0gMC45OVxuICAgIH1cblxuICAgIGRyYXcoYzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICAgIGMuc2F2ZSgpXG4gICAgICAgIGMuZ2xvYmFsQWxwaGEgPSB0aGlzLmFscGhhXG4gICAgICAgIGMuYmVnaW5QYXRoKClcbiAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpXG4gICAgICAgIGMuZmlsbFN0eWxlID0gdGhpcy5jb2xvclxuICAgICAgICBjLmZpbGwoKVxuICAgICAgICBjLnJlc3RvcmUoKVxuICAgIH1cblxuICAgIHVwZGF0ZShjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ICo9IHRoaXMuZnJpY3Rpb25cbiAgICAgICAgdGhpcy52ZWxvY2l0eS55ICo9IHRoaXMuZnJpY3Rpb25cbiAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsb2NpdHkueFxuICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxvY2l0eS55XG4gICAgICAgIHRoaXMuYWxwaGEgLT0gMC4wMVxuICAgICAgICB0aGlzLmRyYXcoYylcbiAgICB9XG59XG5cbmNsYXNzIEJhY2tncm91bmRQYXJ0aWNsZSB7XG4gICAgcHVibGljIHg6IG51bWJlclxuICAgIHB1YmxpYyB5OiBudW1iZXJcbiAgICBwdWJsaWMgY29sb3I6IHN0cmluZ1xuICAgIHB1YmxpYyBhbHBoYTogbnVtYmVyXG4gICAgcHVibGljIGluaXRpYWxBbHBoYTogbnVtYmVyXG4gICAgcHJpdmF0ZSBzaGltbWVyQWxwaGE6IG51bWJlclxuICAgIHB1YmxpYyB0b3VjaGVkOiBib29sZWFuXG4gICAgcHJpdmF0ZSByYWRpdXM6IG51bWJlclxuICAgIGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCByYWRpdXM6IG51bWJlciwgY29sb3I6IHN0cmluZykge1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXNcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yXG4gICAgICAgIHRoaXMuYWxwaGEgPSAwLjA3NVxuICAgICAgICB0aGlzLmluaXRpYWxBbHBoYSA9IHRoaXMuYWxwaGFcbiAgICAgICAgdGhpcy5zaGltbWVyQWxwaGEgPSB0aGlzLmFscGhhICsgMC4yXG4gICAgICAgIHRoaXMudG91Y2hlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgZHJhdyhjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICAgICAgYy5zYXZlKClcbiAgICAgICAgYy5nbG9iYWxBbHBoYSA9IHRoaXMuYWxwaGFcbiAgICAgICAgYy5iZWdpblBhdGgoKVxuICAgICAgICBjLmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSlcbiAgICAgICAgYy5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGMuZmlsbCgpXG4gICAgICAgIGMucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgdXBkYXRlKGM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgICAgICB0aGlzLmRyYXcoYylcbiAgICAgICAgLy8gc2hpbW1lciBlZmZlY3RcbiAgICAgICAgaWYgKHRoaXMudG91Y2hlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxwaGEgPiB0aGlzLmluaXRpYWxBbHBoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgLT0gTWF0aC5yYW5kb20oKSowLjA1XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWxwaGEgPCB0aGlzLmluaXRpYWxBbHBoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgKz0gTWF0aC5yYW5kb20oKSowLjEwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b3VjaCgpIHtcbiAgICAgICAgdGhpcy50b3VjaGVkID0gdHJ1ZVxuICAgICAgICB0aGlzLmFscGhhID0gdGhpcy5zaGltbWVyQWxwaGFcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQcm9qZWN0aWxlIH0gZnJvbSAnLi9wYXJ0aWNsZXMnXG5jb25zdCBzaG9vdEF1ZGlvID0gbmV3IEF1ZGlvKCcuL2F1ZGlvL2FsdFNob290Lm1wMycpXG5jb25zdCB1bmxlYXNoZWRBdWRpbyA9IG5ldyBBdWRpbygnLi9hdWRpby91bmxvY2subXAzJylcbmV4cG9ydCB7IFBsYXllciB9XG5cbmNsYXNzIFBsYXllciB7XG4gICAgcHVibGljIHg6IG51bWJlclxuICAgIHB1YmxpYyB5OiBudW1iZXJcbiAgICBwdWJsaWMgcG93ZXJVcDogc3RyaW5nXG4gICAgcHVibGljIHZlbG9jaXR5OiBWZWxvY2l0eVxuICAgIHByaXZhdGUgdW5sZWFzaGVkQ29sb3I6IHN0cmluZ1xuICAgIHByaXZhdGUgc3BlZWQ6IG51bWJlclxuICAgIHByaXZhdGUgcG93ZXI6IG51bWJlclxuICAgIHByaXZhdGUgc2hvdFNwZWVkOiBudW1iZXJcbiAgICBwcml2YXRlIGZyaWN0aW9uOiBudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdG9wTGVmdDogYW55LCBwcml2YXRlIGJvdHRvbVJpZ2h0OiBhbnksIHB1YmxpYyByYWRpdXM6IG51bWJlciwgcHVibGljIGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy54ID0gKHRoaXMudG9wTGVmdC54ICsgdGhpcy5ib3R0b21SaWdodC54KSAvIDJcbiAgICAgICAgdGhpcy55ID0gKHRoaXMudG9wTGVmdC55ICsgdGhpcy5ib3R0b21SaWdodC55KSAvIDJcbiAgICAgICAgdGhpcy5wb3dlclVwID0gJydcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IDAuOTJcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcGVlZCA9IDAuNzBcbiAgICAgICAgdGhpcy5zaG90U3BlZWQgPSAxNlxuICAgICAgICB0aGlzLnBvd2VyID0gMTJcbiAgICAgICAgdGhpcy51bmxlYXNoZWRDb2xvciA9IG51bGxcbiAgICB9XG5cbiAgICBpc1VubGVhc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy51bmxlYXNoZWRDb2xvclxuICAgIH1cblxuICAgIGRyYXcoYzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICAgIGMuYmVnaW5QYXRoKClcbiAgICAgICAgYy5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpXG4gICAgICAgIGMuZmlsbFN0eWxlID0gdGhpcy5jb2xvclxuICAgICAgICBjLmZpbGwoKVxuICAgIH1cblxuICAgIHNob290KHsgeCwgeSB9KSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih5IC0gdGhpcy55LCB4IC0gdGhpcy54KVxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIHRoaXMuc2hvdFNwZWVkLFxuICAgICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogdGhpcy5zaG90U3BlZWRcbiAgICAgICAgfVxuICAgICAgICBsZXQgcyA9IHNob290QXVkaW8uY2xvbmVOb2RlKCkgYXMgSFRNTEF1ZGlvRWxlbWVudFxuICAgICAgICBzLnZvbHVtZSA9IDAuNVxuICAgICAgICBzLnBsYXkoKVxuICAgICAgICByZXR1cm4gbmV3IFByb2plY3RpbGUodGhpcy54LCB0aGlzLnksIDUsIHRoaXMuY29sb3IsIHZlbG9jaXR5LCB0aGlzLnBvd2VyKVxuICAgIH1cblxuICAgIHVwZGF0ZShjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGtleXM6IEtleXMpIHtcbiAgICAgICAgdGhpcy5kcmF3KGMpXG4gICAgICAgIGlmIChrZXlzLnVwKSB0aGlzLnZlbG9jaXR5LnkgLT0gdGhpcy5zcGVlZFxuICAgICAgICBpZiAoa2V5cy5kb3duKSB0aGlzLnZlbG9jaXR5LnkgKz0gdGhpcy5zcGVlZFxuICAgICAgICBpZiAoa2V5cy5yaWdodCkgdGhpcy52ZWxvY2l0eS54ICs9IHRoaXMuc3BlZWRcbiAgICAgICAgaWYgKGtleXMubGVmdCkgdGhpcy52ZWxvY2l0eS54IC09IHRoaXMuc3BlZWRcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ICo9IHRoaXMuZnJpY3Rpb25cbiAgICAgICAgdGhpcy52ZWxvY2l0eS55ICo9IHRoaXMuZnJpY3Rpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy54IC0gdGhpcy5yYWRpdXMgKyB0aGlzLnZlbG9jaXR5LnggPiB0aGlzLnRvcExlZnQueCAmJlxuICAgICAgICAgICAgdGhpcy54ICsgdGhpcy5yYWRpdXMgKyB0aGlzLnZlbG9jaXR5LnggPCB0aGlzLmJvdHRvbVJpZ2h0LnhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxvY2l0eS54XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnkgLSB0aGlzLnJhZGl1cyArIHRoaXMudmVsb2NpdHkueSA+IHRoaXMudG9wTGVmdC55ICYmXG4gICAgICAgICAgICB0aGlzLnkgKyB0aGlzLnJhZGl1cyArIHRoaXMudmVsb2NpdHkueSA8IHRoaXMuYm90dG9tUmlnaHQueVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbG9jaXR5LnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkueSA9IDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVubGVhc2godW5sZWFzaGVkQ29sb3I6IHN0cmluZykge1xuICAgICAgICBpZiAoIXRoaXMudW5sZWFzaGVkQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgKz0gMC4zM1xuICAgICAgICAgICAgdGhpcy5zaG90U3BlZWQgKz0gNlxuICAgICAgICAgICAgdW5sZWFzaGVkQXVkaW8ucGxheSgpXG4gICAgICAgICAgICB0aGlzLnVubGVhc2hlZENvbG9yID0gdW5sZWFzaGVkQ29sb3JcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxlYXNoKCkge1xuICAgICAgICBpZiAodGhpcy51bmxlYXNoZWRDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCAtPSAwLjMzXG4gICAgICAgICAgICB0aGlzLnNob3RTcGVlZCAtPSA2XG4gICAgICAgICAgICB0aGlzLnVubGVhc2hlZENvbG9yID0gbnVsbFxuICAgICAgICB9XG4gICAgfVxufSIsImV4cG9ydCB7IFBvd2VyVXAgfVxuXG5jb25zdCBwb3dlclVwSW1nID0gbmV3IEltYWdlKClcbnBvd2VyVXBJbWcuc3JjID0gJy4vaW1nL2xpZ2h0bmluZy5wbmcnXG5cbmNsYXNzIFBvd2VyVXAge1xuICAgIHB1YmxpYyB4OiBudW1iZXJcbiAgICBwdWJsaWMgeTogbnVtYmVyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXJcbiAgICBwdWJsaWMgdmVsb2NpdHk6IFZlbG9jaXR5XG4gICAgcHVibGljIGluUGxheTogYm9vbGVhblxuICAgIGNvbnN0cnVjdG9yKHsgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICB0aGlzLnggPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gMCAtIDcgOiB3aWR0aCAtIDdcbiAgICAgICAgICAgIHRoaXMueSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMueSA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAwIC0gOSA6IGhlaWdodCAtIDlcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoaGVpZ2h0IC8gMiAtIHRoaXMueSwgd2lkdGggLyAyIC0gdGhpcy54KVxuICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSArIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKyBNYXRoLnJhbmRvbSgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5XG4gICAgICAgIHRoaXMud2lkdGggPSAxNFxuICAgICAgICB0aGlzLmhlaWdodCA9IDE5XG4gICAgICAgIHRoaXMuaW5QbGF5ID0gZmFsc2VcbiAgICB9XG5cbiAgICBkcmF3KGM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgICAgICBjLmRyYXdJbWFnZShwb3dlclVwSW1nLCB0aGlzLngsIHRoaXMueSwgMTQsIDE4KVxuICAgIH1cblxuICAgIHVwZGF0ZShjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICAgICAgdGhpcy5kcmF3KGMpXG4gICAgICAgIHRoaXMueCArPSB0aGlzLnZlbG9jaXR5LnhcbiAgICAgICAgdGhpcy55ICs9IHRoaXMudmVsb2NpdHkueVxuICAgIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9